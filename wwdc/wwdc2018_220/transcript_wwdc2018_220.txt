  Good afternoon. Welcome. My name is Ken Ferry. Today Kasia Wawer and I are  going to talk to you about  performance in Auto Layout. Last time I was up here talking  about Auto Layout was in 2011  when we first introduced it. So it's really great to be back  up here chatting with you all  today. OK, so Auto Layout. This is how we position content  on iOS on the Mac. The main object involved as we  know are views and constraints,  constraints giving the  relationships between views. When it comes to performance, I  think the challenge here is that  if all you've said is the  distance between these two  buttons should be 20, it can be  hard to understand the  step-by-step process that the  machine goes through to do that  and that means it can be hard to  understand the expectations  around performance and  understand what's fast and  what's not and generally how  things are working. So that's our goal for this  talk. It's to really understand that,  to have a good feel for how  things are going to work. So we're going to start things  off by first showing some of the  work that we've been doing in  this release for iOS 12 around  performance. We've been doing a lot of work,  that's we get to give this talk. When that's done we're going to  move on to trying to build that  step-by-step understanding that  I was talking about. So we have good intuition and  good expectations around  performance. To do that we're going to do  something very unusual for us,  which is to go into internals. So enjoy that please. Last, if you only ever rely on  our intuition for performance,  it's not going to work out very  well. So we will then look -- Kasia  will take over and we'll analyze  code and we'll sort of show how  to merge your intuition with,  you know, practice.

下午好。欢迎。我叫肯渡船。今天，Kasia Wawer和我要和你们谈谈汽车布局的性能。上次我在这里谈论汽车布局是在2011，当我们第一次介绍它。所以今天回到这里和大家聊天真是太好了。好，所以自动布局。这就是我们如何在Mac上定位iOS上的内容。我们所知道的主要对象是视图和约束，给出视图之间的关系的约束。说到性能，我觉得这里的挑战在于，如果你只说这两个按钮之间的距离应该是20，那么就很难理解机器完成这个任务的逐步过程，也就意味着很难理解期望值。围绕性能和了解什么是快，什么不是，一般情况下如何工作。这就是我们演讲的目标。要真正理解这一点，对事情的运作有一个良好的感觉。所以我们首先要展示一些我们在iOS 12发布版中围绕性能所做的工作。我们已经做了很多工作，这就是我们的演讲。当这一切结束后，我们将继续努力去构建我正在谈论的逐步理解。所以我们对绩效有良好的直觉和良好的期望。要做到这一点，我们要做一些非常不寻常的事情，那就是进入内部。所以请享受它。最后，如果你只依赖我们的直觉来表现，那就不太好了。然后我们将看看--Kasia将接管，我们将分析代码，我们将展示如何将你的直觉和，你知道的，实践结合起来。

 But let's get to it. So first as is traditional for  an Apple presentation, we're  going to look at a bunch of  numbers and brag. Here we have, what we're looking  at here is a benchmark. So the way we approached this  work is we went out and looked a  bunch of third party apps as  well as our own apps and we  tried to isolate what we saw  happening into test cases that  we could then benchmark. So this one here, what we're  looking at, is UICollectionView  with self-sizing cells and on  the whichever side looks bad is  iOS 11, which hopefully looked  janky and bad. And on iOS 12 it's perfect. It's hitting full frame rate. So that's just one of the cases  we looked at. Here are some more, just another  sampling. We have a lot. These ones are all time. So what you're looking at is  that the gray bars are iOS 11. How much time it took on iOS 11  and the blue are iOS12. So what you take from this is  that we found a lot of places  where we could make things  really a lot better. And that will only improve your  apps.

但是，让我们开始吧。首先，对于传统的苹果介绍，我们要看一大堆数字并吹嘘。在这里，我们所看到的是一个基准。因此，我们着手这项工作的方式是，我们走出去，查看了一堆第三方应用程序以及我们自己的应用程序，并试图将我们所看到的情况隔离到测试用例中，然后对这些测试用例进行基准测试。所以我们现在看到的是UICollectionView，它具有自调整大小的单元格，无论哪一边看起来不好，都是iOS 11，希望它看起来既漂亮又糟糕。在iOS 12上它是完美的。它达到了全帧率。这只是我们看到的一个案例。这里还有一些，只是另一个采样。我们有很多。这些都是时间。所以你所看到的是灰色的酒吧是iOS 11。在iOS 11和蓝色上花费了多少时间是iOS12。所以你从中得到的是，我们发现了很多可以让事情变得更好的地方。这只会改善你的应用程序。

 That will make things quite a  bit better for you I hope. This is going all the way up and  down the stack. So some of it is in the real  guts that affect just absolutely  everything. Some of it's moving into UI  kits. Some of it's up in the client  layer so for in how people use  Auto Layout. So if you look at for example  that UICollectionView benchmark  that we were looking at that's  all of those. It does include stuff that's in  the real guts but it also  includes a lot of really  important changes in just how  UICollectionView uses Auto  Layout and is more performance  due to it. Which is a good segue to the  rest of the talk, which is how  you can do that too. So how to use it properly. When we were going through these  I think a lot of the time the  reason why we were able to make  all these improvements is that  we have a good mental model for  how things are put together and  how it performs, how it works. We want to help you develop that  model as well. So to frame this we're going to  go through an example case, some  client code, that is not -- that  has some issues and we're going  to discuss why. So your code may or may not have  this particular issue, but we  did choose what we thought was  the most common thing that we  saw when we went through all  these client apps. But even if you don't have this  particular issue, the work we do  to go through what's happening  should be meaningful to  everybody and probably new to  almost everybody. So let's do it.

我希望这会让事情变得更好。这是一路上上下下的堆栈。所以一些真正的胆量只会影响一切。其中一些正在进入UI工具包。有些是在客户端层，所以在人们如何使用自动布局。所以，如果你看一看我们所看到的UICLoopDeVIEW基准，那就是所有这些。它确实包含了真正的内核中的东西，但它也包含了很多真正重要的变化，只是UICLoDeNeVIEW如何使用自动布局，并且由于它而具有更多的性能。这是一个很好的部分，其余的谈话，这是你怎么能做到这一点。所以如何正确使用它。当我们经历这些的时候，我想很多时候我们之所以能够做出这些改进，是因为我们有一个很好的心理模型来解释事物是如何组合的以及它是如何运作的，它是如何运作的。我们也想帮助你开发这个模型。为了说明这个问题，我们将通过一个示例案例，一些客户端代码，这不是-这有一些问题，我们将讨论为什么。因此，您的代码可能有或可能没有这个特定的问题，但我们确实选择了我们认为是最常见的东西，当我们通过所有这些客户端应用程序时，我们看到。但是，即使你没有这个特别的问题，我们所做的工作应该对每个人都有意义，而且可能对几乎所有人都是新的。让我们来做吧。

 This is the case we're going to  go through so we're going to  produce this layout, obviously  very simple. Oftentimes I think you would  build this in interface builder. That's a great idea. It is such a good idea that it  would completely prevent the  performance issues that we'd  like to go through. So let's say we didn't do that. Let's say that we built it like  this. First let's just walk through --  before we try to analyze it,  let's walk through what this  code is doing. First, we are overriding the  UIView method updateConstraints,  whatever that does. So we'll talk about it. Next, we have an Ivar called  myConstraints.

这是我们要经历的情况，所以我们将生产这种布局，显然非常简单。通常我认为你会在界面构建器中构建这个。这是个好主意。这是一个很好的主意，它将完全阻止我们想通过的性能问题。让我们假设我们没有那样做。比如说我们是这样建造的。首先让我们走开——在我们分析它之前，让我们来看看这个代码在做什么。首先，我们将重写UIVIEW方法UPDATE CONDESTREST，无论它做什么。所以我们来讨论一下。接下来，我们有一个称为MyRe约束的IVAR。

 And we are taking everything in  that variable and we are  deactivating all those  constraints. We are then creating  constraints, which implement the  layout that we were just looking  at. That's fairly straightforward. It's using visual format  language here. We're then activating those  constraints, installing them,  and last we're calling  super.updateConstraints was an  important thing to do because  the UIView level implementation  that this method does do work. OK, that's the basic structure  of what it's doing and it does  work, it's functions. But let's talk about what it's  doing more concretely now so  that we can understand the  performance. So the first thing to understand  is what exactly is  updateConstraints, this method  we're overriding. Well, it's one component of the  Render Loop. The Render Loop is the process  that runs potentially at 120  times every second. That makes sure that all the  content is ready to go for each  frame. OK, so it consists of three  phases -- Update Constraints,  Layout, and Display. First every view that needs it  will receive updateConstraints. And that runs from the leaf most  views up to the view hierarchy  towards the window.

我们把这个变量中的每一个都拿走了，我们将解除所有这些限制。然后，我们创建约束，实现我们刚才看到的布局。这是相当简单的。这里使用的是视觉格式语言。然后我们激活这些约束，安装它们，最后我们调用super.updateConstraints，这是一件很重要的事情，因为这个方法所做的UIView级实现是有效的。好的，这就是它所做的和它所起作用的基本结构，它的功能。但是现在让我们更具体地讨论一下它的作用，这样我们就能了解性能。因此，首先要理解的是什么是更新数据，这个方法是我们最优先考虑的。嗯，它是渲染循环的一个组成部分。呈现循环是一个每秒120次运行的进程。这确保了每个帧的所有内容都准备好了。因此，它包括三个阶段：更新约束、布局和显示。首先，需要它的每个视图都将接收UpDATA约束。从叶子的大多数视图到视窗层次结构都向窗口运行。

 Next, every view receives layout  sub views. This runs the opposite direction  starting from the window going  down towards the leaves. Last, every view gets draw if it  needs it, that kind of thing. OK, what are these for?  Why do they exist?  Well, they all have the exact  same purpose and they have exact  parallel sets of methods. And that purpose is to avoid  wasted work, which I can explain  by example. So a label, a UI label needs to  have constraints that describe  the size of its text, OK?  But there are many properties  that contribute to that size. There's the text property  itself, there's the font, and  the text size, etcetera. One way to do this would be that  every time one of those  properties changes go re-measure  your text. However, that would often be  pretty inefficient because you  usually change a bunch of these  right in a row. When you're first setting up a  label, you're probably going to  call a bunch of these property  setters and if you're  re-measuring text on each one,  all the intermediate ones are  wasted, you really just want to  measure at the end. And that's what the Render Loop  gives you. Because what you can do instead  is that inside a set font you  can just call  setNeedsUpdateConstraints and  then you're guaranteed to get  update constraints at the end  before the frame goes to the  screen. And that's what it's for. So the couple things to  understand from this before we  move on is number one it runs a  lot, 120 frames a second.

接下来，每个视图接收布局子视图。这是从窗口朝着叶子开始的相反方向。最后，如果需要的话，每个视图都会被绘制出来。好的，这些是干什么用的？它们为什么存在？它们都有完全相同的目的，它们有精确的并行方法集。这样做的目的是避免浪费的工作，我可以举例说明。因此，一个标签，一个UI标签需要有描述文本大小的约束，好吗？但有许多属性有助于这一规模。有文本属性本身，有字体和文本大小等等。这样做的一个方法是每次改变这些属性时，重新测量你的文本。然而，这通常是非常低效的，因为你通常会连续地改变这些权利。当你第一次设置标签时，你可能会调用一堆属性设置器，如果你对每个属性设置器都重新测量文本，那么所有中间的属性都被浪费了，你最后只想测量。这就是渲染环给你的。因为您所能做的只是在设置字体内调用setNeedsUpdateConstraints，然后保证在框架进入屏幕之前在最后获得更新约束。这就是它的目的。因此，在我们前进之前，从这件事情中可以理解的事情是：第一，它运行很多，每秒120帧。

 Number two they're parallel. So you can use that for  intuition as well. If you feel like you understand  the layout pass or have some  feel for that, same deal when  you're thinking about  UpdateConstraints or you're  thinking about display. And then the last thing being  that the whole reason it's there  is to avoid wasted work, to  defer work and possibly skip it  entirely. All right, so having looked at  that we are now in position to  analyze the rest of this method. See how we are -- every time  it's called we're deactivating  constraints and then activating  them again new ones. We are saying this is analogous  to layoutSubviews. So if we wrote the exact same  code in layout Subviews that is  the analog, that would be as if  you -- every time layoutSubviews  was called you destroyed all  your Subviews, created them from  scratch and then added them  again. And I think a lot of people have  the completely accurate  intuition that that's not going  to perform very well. So the thing to really get is  that it's the same. Whatever intuition you take from  that apply it to  updateConstraints as well. When you are ripping down  constraints like that you're  doing a lot of extra work. So how do you fix it?  Well, you need to use -- as we  were saying, you need to make  sure that you're not doing it  more than once. It's for deferring work. So it should be something like  this, we say did we already do  this work?  If we did then just don't do  anything at all.

第二，它们是平行的。所以你也可以用直觉。如果你觉得自己理解了布局通行证或者对此有所感受，那么在考虑UpdateConstraints或者考虑显示时也要做同样的处理。最后一点是，它存在的全部原因是避免浪费工作，推迟工作，并可能完全跳过它。好了，看看我们现在的位置来分析剩下的方法。看看我们是怎样的——每次被调用，我们都会停用约束，然后再激活它们。我们说这类似于LayOutSubVIEW。因此，如果我们在布局子视图中编写与此类似的完全相同的代码，那么就好像每次调用layoutSubviews时，您都销毁了所有子视图，从头创建它们，然后再次添加它们。我认为很多人都有着完全正确的直觉，那是不太好的。所以真正得到的是它是一样的。无论你从中获得什么直觉，也将其应用到更新的约束。当你像这样做限制的时候，你在做很多额外的工作。那你怎么解决呢？嗯，你需要使用——正如我们所说的，你需要确保你不止一次这样做。这是为了推迟工作。所以应该是这样的，我们说我们已经做过这项工作了吗？如果我们做到了，那就什么也不要做。

 If we haven't done it yet, then  sure set up those constraints  once. And that will perform well, OK?  So this is again, this is  actually the most common error  that we see in client code,  which is we call it churning the  constraints. Unnecessarily ripping them down  and putting them back up. OK, great. We are going to do more but  stepping back for a second now  to think about the Render Loop  for a little bit. The Render Loop is great if you  actually need it. The purpose again, it's really  useful for avoiding that  redundant work.

如果我们还没有做到这一点，那么一定要设置这些约束一次。这会很好，好吗？所以这也是我们在客户机代码中看到的最常见的错误，我们称之为搅动约束。不必要地把它们撕下来放回去。好的，太好了。我们要做更多的事情，但现在退一步思考一下渲染循环。如果你真的需要它，渲染循环很好。再次，这真的是有用的，避免多余的工作。

 But it's also dangerous because  it runs to often. It's very sensitive code. So in a case like this usually  what you want to do about  sensitive code is not -- like,  you should take care if you're  writing it but you should also  try to minimize how often you  write sensitive code because,  you know, you're probably going  to screw it up. We all do. So in this case, in fact you  might be, you should really  think again like could I just do  it once and not put it in  updateConstraints?  And a good way to do that is use  Interface Builder. If you can use Interface Builder  you should. It's great for all sorts of  reasons. It puts you on a good path. OK, so that's great. We've now talked about that. I think we have a better  understanding for why that's  problematic, at least somewhat  by analogy sub use. But for the purposes of this  talk we want to do better than  that. We don't just want to say this  is bad.

但它也很危险，因为它经常运行。这是非常敏感的代码。因此，在通常情况下，对于敏感代码，您想做的不是.——比如.——如果您正在编写敏感代码，您应该小心，但是您还应该尽量减少您编写敏感代码的频率，因为.——您知道，您很可能会搞砸它。我们都这么做。因此，在这种情况下，实际上您可能真的应该重新考虑，比如，我能不能只做一次，而不把它放在updateConstraints中？这样做的好方法是使用界面生成器。如果你可以使用界面生成器，你应该。这是伟大的，因为各种各样的原因。它让你走上一条好路。好的，那太好了。我们现在已经谈到了这一点。我认为我们有更好的理解为什么这是有问题的，至少在某种程度上通过类比子使用。但为了这次谈话的目的，我们希望做得更好。我们不只是想说这是坏的。

 We want to really understand it  and understand the process. So to do that we're now going to  peel back the covers and start  to really see what really  happens. So when we activate these  constraints, when we add the  constraints, what is the process  that occurs?  Let's diagram it out at a high  level. So if this is the view that  we're adding the constraints to,  this view is in a window. Hanging off the window is an  internal object called the  engine. And the engine is the  computational core of Auto  Layout.

我们想真正理解它并理解这个过程。为了做到这一点，我们现在将剥去封面，开始真正了解到底发生了什么。因此，当我们激活这些约束时，当我们添加约束时，发生的过程是什么？让我们把它画在一个很高的水平上。如果这是我们添加约束的视图，这个视图在窗口中。悬挂在窗户上的是一个被称为发动机的内部物体。而发动机是汽车布局的计算核心。

 When the constraint is added  what will happen is that we make  an equation, which corresponds  to the constraints, and we add  that equation to the engine. The last object to understand in  the diagram is that the equation  is in terms of variables where a  variable is like, you know, if I  hand you an equation and I say  solve for X, X is a variable. The things that we need to solve  for in this case is the frame  data of a view. So there will be four variables  for every view, which is the min  X, the min Y, the width, and the  height. OK, so let's go into this  process. So this was the layout we were  going to do. We're going to focus just on the  horizontal constraints for  simplicity, but we're going to  follow through the process. So the first thing that happens,  as we said, is we make these  equations, which look like this. These are pretty straight  forward. The most interesting one is I  think the space between the two  text fields, which looks like  we're saying it looks very, very  similar to what you say with the  constraint but it's somewhat  lower level because it's in  terms of these variables. OK, then each of those equations  needs to get added to the  engine. And we're actually going to  follow along that process again  with the goal being to have a  good feel for the performance  characteristics. What is happening when we do  this?  So the engine is trying to solve  for these variables, which is  something you may have done in  algebra and it actually looks  exactly the same. So let's follow it. So first equation comes in, says  the first fields minX is 8.

当添加约束时，会发生这样的情况：我们创建一个与约束相对应的方程，并将该方程添加到引擎中。图中最后一个要理解的是，方程是根据变量表示的，其中变量是，你知道的，如果我给你一个方程，我说解X，X是一个变量。在这种情况下，我们需要解决的问题是视图的帧数据。因此，每个视图将有四个变量，即min x、min y、宽度和高度。好的，让我们进入这个过程。这就是我们要做的布局。为了简单起见，我们将只关注水平约束，但我们将遵循这一过程。所以，正如我们所说的，首先发生的是这些方程，看起来像这样。这些都是非常直接的。最有趣的一点是，我认为两个文本字段之间的空格，我们说它看起来非常非常，非常类似于约束条件，但是它稍微低一些，因为它是根据这些变量的。好的，那么每一个等式需要加到引擎上。实际上，我们将再次遵循这一过程，目标是对性能特性有一个良好的感觉。当我们这样做的时候发生了什么？所以引擎试图为这些变量求解，这在代数学上是可以做到的，实际上看起来完全一样。让我们跟随它。第一个方程进来了，第一个字段MIX是8。

 Cool. Its width is 100, fine. OK, when this one comes in we  say the second field's minX is  equal to the first minX plus the  width plus 20. What would you do in algebra if  somebody asked you to solve for  these variables?  You would substitute out for the  ones that you already had in  there. And that's exactly what's going  to happen. If you are profiling, you'll see  there is a genuine method in the  engine that contains the word  substitute as well as another  140 characters because we are  Cocoa Code Programmers. But and that's what it will do. And then, you know, and the last  equation comes in and this looks  done. it looks like that was all the  work that had to happen at least  in this case to solve for those  variables and that's true. That's what I want to understand  at this point is that the work  that happens is both not very  complicated. It corresponds very, very, very  closely to what you would do if  you were doing it by hand. And it's also not very  expensive. It's just sort of substituting  out like this. That's the work it does. OK, so now we have sort of  solved for these variables in  the engine but that's not  layout. So let's finish the process. What happens for the rest of the  process is that whenever the  engine sort of assigns a value  to one of these variables, it's  going to inform the view that  the variable came from and say,  this thing changed. What will the view do in  response to that?  Well, if you think about it for  a minute it will call it  Superview and say hey,  setNeedsLayout because it needs  to move. OK, that was all happening as  part of the update constraints  phase. We now just receive  setNeedsLayout, so at some point  it will move on to the layout  phase. Then, OK, so the last piece of  the puzzle is that we'll  receive, UIView will receive  layout Subviews will do is it  will copy that data from the  engine into the frame. So it will just say engine, what  are the values for those  variables?  Engine will tell it and it will  just call set Superview of that  view we'll call setBounds at  setCenter on that Subview.

酷。它的宽度是100，很好。好的，当这一个进来时，我们说第二个字段的MIX等于第一个MIX加上宽度加上20。如果有人要你解这些变量，你会在代数中做什么？你会代替你已经拥有的那些东西。这就是即将发生的事情。如果您正在分析，您将看到引擎中有一个真正的方法，它包含单词替换以及另外的140个字符，因为我们是可可代码程序员。但这就是它所要做的。然后，你知道，最后一个等式进来了，看起来已经完成了。看来这是所有的工作，至少在这种情况下要解决这些变量，这是真的。在这一点上，我想理解的是，所发生的工作并不是很复杂。它非常，非常，非常接近，如果你用手做的话，你会做什么。而且也不是很贵。就像这样替代。这就是它所做的工作。好的，现在我们已经解决了引擎中的这些变量，但这不是布局。让我们完成这个过程。这个过程的其余部分会发生这样的情况：每当引擎为这些变量之一赋值时，它将通知视图该变量来自，并且说，这个东西改变了。这个观点会如何回应呢？好吧，如果你考虑一下，它会称之为超视域，并说嘿，Stand需要布局，因为它需要移动。好的，这是作为更新约束阶段的一部分。现在我们只接收StaseDebug布局，所以在某个时候它将进入布局阶段。然后，好，那么最后一个难题就是我们将要接收的，UIView将接收布局子视图，子视图将把数据从引擎复制到框架中。所以它只会说引擎，这些变量的值是多少？引擎会告诉它，它会调用那个视图的set超视图，我们将调用Set Cube上的StEnset在该子视图上。

 And that is the entire process. So just step back and think for  a second. Like, that is the step-by-step  process of Layout. If you can try to internalize  that and get a feel for it,  you're going to have a much,  much, much better feel for  performance expectations around  this stuff. In fact, let's see how that's  going right now, because now  when we look at this and we look  at this method that we were  looking at that where we're  deactivating constraints and  we're reactivating constraints,  think about what we just did and  think about what the engine is  going to be doing. It's going to look like this. Which we call churning [laughs]. So each operation it's doing is  not super expensive, but it's  doing a lot of them and it's  just completely unnecessary. This work is wasted. So if you can feel this in your  heart, if you can really feel  that this is what is happening  when you do this, then you're  going to be in good shape. Then that's -- you're going to  be in the same position we are  to go through and really get a  good feel for this. OK, so I hope that's great. There's one other big topic that  we want to cover though. If we want to really have a good  performance model is this idea  that you only pay for what you  use with Auto Layout. And having looked at this, I  think we're in a good position  to understand what that means,  OK?  To do this, let's say we double  the situation we had before. So we have four text fields in  two sort of independent  hierarchies. Now something you can do is you  can make a constraint that  crosses the hierarchy like this. That goes -- that you can say,  well text field one should be  aligned with text field three  even though they don't have the  same Superview. I think sometimes people have  the impression that because this  possible, it means that things  are going to be generally quite  slow because anything could  affect anything at any time and  so it's just sort of a giant  ball of mud and performance  probably sucks. OK, but having looked at what  we've looked at, let's see what  happens in the common case where  you don't have this because most  of the time you don't.

这就是整个过程。所以，退一步思考一下。就像，这是一步一步的布局过程。如果你能试着将之内在化，并感受它，你将会对这些东西周围的性能期望有更好的感觉。事实上，让我们看看现在情况如何，因为当我们看这个，我们看这个方法，我们看那个，我们停用约束，我们重新激活约束的地方，想想我们刚刚做了什么，想想引擎将要做什么。看起来会像这样。我们称之为搅动[笑]。因此，它所做的每一项操作都不是非常昂贵，但它做了很多，这完全是多余的。这项工作被浪费了。所以，如果你能在心里感觉到这一点，如果你能真正感觉到当你这样做的时候正在发生这种情况，那么你将会处于良好的状态。那就是——你将处在我们要经历的同一个位置，并且真的得到了很好的感觉。好的，我希望这很好。还有另一个大的话题，我们想掩盖。如果我们真的想要一个好的性能模型，这个想法是你只支付你使用的自动布局。看了这个，我想我们能很好地理解这意味着什么，好吗？要做到这一点，让我们说我们的情况翻了一番。因此，我们在两种独立的层次结构中有四个文本字段。现在你可以做的是，你可以做一个跨越层次结构的约束。也就是说，文本字段1应该和文本字段3对齐，即使它们没有相同的Superview。我想，有时人们会觉得，因为这种可能，意味着事情会变得非常缓慢，因为任何事情在任何时候都可能影响任何事情，所以这只是一个巨大的泥球，性能可能很糟糕。好，但是看看我们看过的，让我们看看在通常情况下会发生什么，因为大多数时候你没有这样的情况。

 Most of the time views are only  constrained to their parent and  to their siblings. What you'll see there is that  since we have these two  independent blocks, that will  give, if you look inside the  engine it will be two  independent blocks of equations  that completely don't interact  with each other, that don't have  any overlapping variables. What that will do, is that  because they completely don' t  overlap, they just don't  interact. And if we have one of these it  will take some amount of time to  deal with. If we have two of them it will  just take twice the time because  they have nothing to do with  each other. Three of them, three times,  etcetera, the point is you're  going to see a line. You're going to see linear  performance, which is the best  you can get. That's perfect marks for this  kind of thing. So I want to stress this again,  the reason why it's linear is  because there aren't any  dependencies between these  pieces. If you do have a dependency,  then it will tie those blocks of  equations together and that will  be somewhat more, you know, more  computation to deal with but  that's only if you use it. And of course if you do have  something like that, you know,  if you're doing it by hand of  course it's going to be a little  bit more expensive that's what  you expect.

大多数时间的观点只局限于他们的父母和他们的兄弟姐妹。你们会看到，因为我们有这两个独立的块，如果你们观察引擎内部，就会发现两个独立的方程组，它们完全不相互作用，没有任何重叠的变量。这样做是因为它们完全不重叠，它们只是不相互作用。如果我们有一个，这将需要一些时间来处理。如果我们有两个，它们只需要两倍的时间，因为它们没有任何关系。他们中的三个，三次，等等，关键是你要看到一条线。你会看到线性性能，这是你能得到的最好的。这是这类东西的完美标志。所以我想再次强调一下，为什么它是线性的，因为这些片段之间没有任何依赖关系。如果你确实有依赖关系，那么它将把方程组块联系在一起，这需要更多的计算来处理，但前提是你使用它。当然，如果你有这样的东西，你知道，如果你用手做，当然会贵一点，这正是你所期望的。

 You're doing something more  complicated. So it's kind of this usual thing  that we often aim for in Cocoa,  which is that the simple things  are simple and the complex  things are possible. In this case it's more like they  cost a little more. But you're not paying for it if  you're not using it, which is  actually the right way to think  of the whole engine in terms of  intuition again, you can think  of it as a cache for layout and  as a dependency tracker. It's very, very targeted. It understands which constraints  affect which views, and when you  change things it just updates  exactly the things that are  needed. And this has implications on how  you write code too. Sometimes we see -- one issue we  sometimes see is people taking  great pains to avoid making  constraints because they have  the impression it's going to be  expensive. But actually, it's very, very  targeted. As long as the constraints that  you're making correspond closely  to the problem that's being  solved, it's pretty unlikely  that whatever you do, if you  tried to dodge it, it's going to  be more performance. Oftentimes we'll see people  doing very complicated  measurement and adding things up  and sort of trying to pull  information out and then push it  back in and that's almost always  more expensive than just  directly expressing as a  constraint what you're after.

你在做更复杂的事情。所以我们经常在《可可》中追求的就是简单而复杂的事物是可能的。在这种情况下，更像是花了一点钱。但是如果你不使用它，你不会为此付出代价，这实际上是从直觉的角度重新考虑整个引擎的正确方法，你可以把它看作布局的缓存和依赖项跟踪器。这是非常非常有针对性的。它理解哪些约束影响哪些视图，并且当您更改内容时，它只是更新所需的内容。这对你如何编写代码也有影响。有时我们看到--有时我们看到的一个问题是，人们会竭尽全力避免做出限制，因为他们觉得这样做会很昂贵。但实际上，这是非常非常有针对性的。只要你所做的限制与正在解决的问题紧密对应，那么无论你做什么，如果你想躲避它，它就不太可能表现得更好。通常我们会看到人们在做非常复杂的测量，把东西加起来，然后试着把信息提取出来，然后再推回去，这比直接把你要找的东西表达成约束要昂贵得多。

 Now the converse side of that is  that sometimes we see  hierarchies that look like  something like this where we see  lots and lots of constraints and  lots of priority and it's really  not clear what's happening and  this is a -- usually this is a  telltale sign of this being the  situation that there's actually  just two completely separate  layouts that someone has in mind  and we're trying to sort of pack  them together into one set of  constraints and do it all in  one. And that's also not a real good  idea. So that will -- that creates a  lot of false dependencies,  places where it seems like  things interact that they really  don't. It's also nearly impossible to  Debug, if you haven't noticed. So the overall advice is try to  model the problem as directly as  possible. Kasia is going to walk through  this kind of case where you're  switching between different  layouts and show that a little  more explicitly. But that's the general advice. Just use it in a natural way. It's better for both performance  and for understandability. OK, so that most of what we have  to say. But since we're trying to build  an overall mental model of the  performance characteristics of  Layout, I want to at least make  sure we touch on all of the  major features. So there are some other things  you can do. And let's discuss.

反过来说，有时我们看到类似这样的层次结构，我们看到很多约束，很多优先级，实际上不清楚发生了什么，这是--通常这是一个警示信号，表明这种情况是实际上只有两个完全独立的布局，有人已经想到了，我们正试图将它们组合到一组约束中，并在一个约束中完成所有工作。这也不是一个好主意。这样就会.——产生很多错误的依赖关系.——这些地方看起来是事物相互影响的地方，但它们实际上并不相互影响。如果没有注意，调试几乎是不可能的。因此，总体建议是尽可能直接地对问题进行建模。Kasia将经历这样的情况：在不同的布局之间切换，并更明确地显示这一点。但这是一般的建议。只要用自然的方式使用。这对于性能和可理解性都更好。好的，那就是我们要说的大部分。但是，由于我们试图建立布局性能特征的总体心理模型，所以我至少要确保我们触及所有主要特性。所以还有其他的事情你可以做。让我们讨论一下。

 So you can say that some  particular view should be at  least 100 points wide. You can use inequalities. What does that cost?  Very, very, very little. Compared to just saying it's  equal to hundred points wide. Since we went internals a little  bit, it's going to coast exactly  one more variable. That's it. You can also call set constant. The example use case for this is  something like I have a gesture  recognizer and I'm kind of  trying to drag a view around and  what I'm going to do is every  time I receive a call from the  gesture recognizer I'm going to  take its translation and I'm  going to pump it into a  constraint by calling set  constant on that constraint with  that translation value. OK, what that's going to do is  we talked about how the engine  is a dependency tracker. This exploits that to the  maximal degree. So that's sort of a very, very,  very fast one step update of  just exactly what has to change  due to this one constraint  changing. So that's a performance  optimization. That's why we even have this  method set constant.

所以你可以说一些特定的观点应该至少有100点宽。你可以使用不等式。那要花多少钱？非常，非常，非常少。与之相称，等于百分之宽。因为我们进入内部有一点点，它将精确地改变一个变量。就是这样。也可以调用SET常量。这个示例用例类似于我有一个手势识别器，我试图拖动一个视图，每次接到来自手势识别器的呼叫，我都要进行它的翻译，并将其输入到调用的约束中。NG用该平移值在该约束上设置常数。好的，我们要讨论的是引擎是依赖追踪器。这是最大程度的利用。因此，这是一个非常，非常，非常快速的一步更新，它精确地更新了由于这个约束改变而必须更改的内容。这就是性能优化。这就是为什么我们甚至有这个方法设置常数。

 Last to talk about it priority. So here you can say, you know,  you can say this view should  ideally be 100 points wide, but  if something else prevents that  just please be as close as  possible. This does incur some more work,  some amount of work. So let's talk about that a  little bit more. Another way to think about that  is to say that the width of that  field is going to be equal to  100 plus some error and please  minimize the error. That's what you're asking for. So there is an error  minimization phase I didn't  discuss before. So when the view asks the engine  as part of layout subviews and  says, hey what's the value for  these variables?  The engine needs to make sure  that all of those error terms  have been minimized first. And this is actually, this is --  I'm not going to go into how  this works but I am going to  talk a little bit about  performance characteristics and  I'm also going to say that's  super neat. So you might want to look this  up. This is the simple X algorithm. This is what we're really doing. It's super old. It was developed during World  War II. What you might note is before  computers. In fact, the people who used to  be called computers, before  there were machines that were  called computers, this is kind  of what they're doing.

最后谈谈IT优先权。所以在这里你可以说，你知道，你可以说这个观点理想情况下应该宽100点，但如果有其他事情阻止，请尽量靠近。这会带来更多的工作，一些工作量。让我们再谈一点。另一种思考方法是，这个场的宽度等于100，加上一些误差，请将误差最小化。这就是你要的。所以有一个误差最小化阶段，我以前没有讨论过。所以当视图要求引擎作为布局子视图的一部分并说，嘿，这些变量的值是多少？发动机需要确保所有这些误差项都被最小化。这实际上是，我不打算深入讨论它的工作原理，但我要讲一点性能特征，我也要说它非常整洁。所以你可能想看看这个。这是简单的X算法。这就是我们真正要做的。它太老了。它是在第二次世界大战期间发展起来的。你可能注意到的是电脑之前。事实上，以前被称为计算机的人，在被称为计算机的机器出现之前，这就是他们所做的事。

 They're doing it by hand, which  does give you some feel for the  performance characteristics. It must be pretty fast if you do  it by hand. And it is. It's pretty much the same stuff  we've been doing. It's more substitutions. That's how you should think of  it. Anyway, but it does -- you know,  when you use priority it does  cost at this level so that's  just something to be aware of. OK, and other than that it's  just same as before. So that's what I wanted to talk  about. So that is our attempt to build  this intuitive understanding of  the performance characteristics  around Auto Layout. So quick review of what we  talked about. Try not to churn your  constraints.

他们是用手工做的，这让你感觉到了性能特征。如果你用手做的话，速度一定很快。就是这样。这几乎是我们一直在做的事情。这是更多的替代品。这就是你应该怎么想的。不管怎么说，但它确实是这样的，你知道，当你使用优先级的时候，它在这个级别上是有代价的，所以这只是需要注意的事情。好的，除此之外，它和以前一样。这就是我想说的。因此，我们试图建立这种直观的理解围绕汽车布局的性能特点。这么快复习一下我们谈论的内容。尽量不要搅乱你的约束。

 That's when you're doing all  this work that just doesn't  matter. So don't do it. When you do work with  constraints it's basic algebra  and that algebra is happening  when you add constraints, when  you remove constraints, when you  call set constant, that's the  primary times. And then also, you know, when we  have this error minimization  phase. The way to think about what Auto  Layout does is that it's a cash  for your layout, we saw the  engine sort of contains all  those solved values and it's a  dependency tracker so that when  things change we can update  those values in a super, super  targeted way. Which leads to our last point,  which is that you only pay for  the features that you're using. That's what we talked about. You know, that's your intuition. And for the rest of the talk I'm  going to turn it over to Kasia  because if you, again, if you  only rely on intuition, things  are not going to go well. So she's now going to go into  some analysis, avoid we talked  about and putting that intuition  into practice. So please enjoy.  Ok let me get to my slide  here. Thank you, Ken. Hi everybody. My name is Kasia Wawer. I am a member of the iOS  Keyboards Team and we use Auto  Layout and we love it. So I get to talk to all of you  about building efficient  layouts. All right, let's go back to  Constraint Churn real quick  here. Constraint churn as we heard  happens when you change your  constraints but the actual views  don't need to move so you're  sending extra work to the engine  and enough of that can affect  your performance.

这就是你做所有这些工作并不重要的时候。所以不要这样做。当你处理约束时，它是基本代数，当你添加约束时，当你移除约束时，当你调用set常数时，就是主要时间。然后，也知道，当我们有这个错误最小化阶段。考虑Auto Layout所做的事情的方法是，它是用于您的布局的现金，我们看到引擎包含所有这些已解决的值，它是一个依赖项跟踪器，以便当情况发生变化时，我们可以以一种超级、超级有针对性的方式更新这些值。这导致了我们的最后一点，那就是你只为你使用的特性付费。这就是我们所谈论的。你知道，那是你的直觉。在接下来的谈话中，我将把它交给Ka.，因为如果你，再一次，如果你仅仅依靠直觉，事情就不会进展顺利。所以她现在要进行一些分析，避免我们谈论和把直觉付诸实践。所以请欣赏。好，让我到我的幻灯片这里。谢谢你，肯。大家好。我叫Kasia Wawer。我是iOS键盘团队的成员，我们使用自动布局，我们喜欢它。所以我要和大家谈谈如何建立高效的布局。好了，让我们回到这里，很快地回到约束状态。正如我们听到的，当你改变你的约束条件时，就会发生约束波动，但是实际的视图不需要移动，所以你要给引擎加班，而且加班太多会影响你的性能。

 So you tend to want to avoid it. So let's talk about how you  might run into this problem and  how you might get out of it. So we're going to work with a  spec here. This is for a social media type  app. There's an avatar view that  shows you who is sharing. There's a title, a date, and a  log entry view and for that  you're going to need some  spacing, you're going to need  some sizing and you're probably  going to need some alignment  too. But this is actually not a pure  social media app. It is a semi social media app,  where you can choose whether you  want to share things. So there's also optionally a  view that says that you've  shared and who you've shared  with. And no social media app would be  complete without the ability to  share cat pictures. So that's another layout that  you might have to put in. And maybe you don't even want to  share that cat picture because  it's just too good, you want to  keep it to yourself. So we have four very similar  layouts. They're not the same and there's  going to need to be some  adjustment when these table view  cells come on to the screen. If I didn't mention it these are  in table view cells. And let's say that you are  working on performance in this  app and you ran it for the first  time and this is the scrolling  performance you got. And there are a lot of hiccups  there, especially on the scroll  back to top. So you're like, OK, how do I  improve this app?  What's going on?  So I get to introduce something  new today, a sneak peek into  something we're working on. This is not actually available  in the beta but stay tuned  because we're going to be  introducing an instrument for  layout. And, OK.

所以你倾向于避免它。那么，让我们来谈谈你可能如何处理这个问题，以及如何摆脱它。所以我们将在这里工作。这是一个社交媒体类型的应用程序。有一个化身视图，显示你是谁分享。有一个标题、日期和日志条目视图，为此，您需要一些间距、一些大小和可能还需要一些对齐。但这并不是一个纯粹的社交媒体应用程序。它是一个半社交媒体应用程序，你可以选择是否要分享东西。因此，也有一种观点认为你已经分享了，你和谁分享过。如果没有分享猫图片的能力，没有任何社交媒体应用程序是完整的。这是另一种布局，你可能不得不投入进去。也许你甚至不想分享那张猫的照片，因为它太好了，你想把它留给你自己。所以我们有四个非常相似的布局。它们是不一样的，当这些表格视图单元格进入屏幕时，需要进行一些调整。如果我没有提到它，它们在表视图单元格中。假设您正在这个应用程序中处理性能，并且是第一次运行它，这就是您所获得的滚动性能。那里有很多打嗝，尤其是卷轴回到顶部。所以你想，好吧，我该如何改进这个应用程序？发生什么事？所以今天我要介绍一些新的东西，偷偷摸摸地看我们正在做的事情。这实际上不是在beta版中，但保持不变，因为我们将介绍一种仪器的布局。好吧。

 I'm glad you are excited. That's good motivation. Anyway, let's take a look at  what's here. The top track is your standard  how much CPU is being used. And this is sort of your canary  in the coalmine view. If there are a lot of peaks here  you have an indication that you  might have something you need to  look at in your layout. And if it's pretty flat,  probably your performance  problems are originating  somewhere else. Below that we will be  specifically tracking constraint  churn. The height of the bars in this  instance correspond to the  number of views that are  experiencing constraint churn. So when you see a big piece  there you know a lot of views  are affected. We're also going to show you how  to remove and change constraint  instances and finally sizing for  UILabel and other text views. This one says UILabel because  that's what's in this app.

我很高兴你很兴奋。这是很好的动力。无论如何，让我们来看看这里的情况。最高轨道是你的标准CPU使用多少。这是你在煤矿里的金丝雀。如果这里有很多山峰，你就有一个迹象表明你可能需要在布局中看到一些东西。如果它很平，可能你的性能问题起源于其他地方。下面我们将具体跟踪约束搅动。此实例中的条的高度对应于经历约束搅动的视图的数量。所以当你看到一个大块的时候，你知道很多的观点受到影响。我们还将向您展示如何删除和更改约束实例，并最终调整UILabel和其他文本视图的大小。这是UIABELL，因为这就是这个应用程序中的内容。

 It's also going to track other  types of text views as well. So this was taken with that app  scrolling, so what do we look at  here?  There are several peaks in the  CPU view but let's zoom in on  this one because right below it  I see a big jump in constraint  churn and that's a little  concerning. So if you highlight this view  and go down to the detailed view  in instruments, what you'll see  is a list of the views that are  affected by churn by view  description. And we are grouping them by  Superview so that in an instance  of say Table View Cells, it's  easier to see that it's  happening over and over in a  specific context and not  different ones. So in this instance we see that  the avatar view and three labels  are experiencing churn. And since I am the one who ran  this through the instrument, I  know that these labels  correspond to the Title Label,  Date Label, and our Log Entry  Label. That's almost all of our views  in this cell. That's a little concerning. Let's see what happened. All right, back to our spec  here.

它也将跟踪其他类型的文本视图。这是因为这个应用程序滚动，所以我们在这里看到什么？CPU视图中有几个峰值，但是让我们放大这个峰值，因为就在它下面，我看到约束搅动中的一个大的跳跃，这有点令人担心。因此，如果你突出显示这个视图，然后进入仪器中的详细视图，你将会看到一个视图列表，其中视图描述会影响视图的变化。我们将它们按照Superview进行分组，这样在例如表视图单元的实例中，更容易看到它在特定的上下文中重复发生，而不是在不同的上下文中重复发生。因此，在这个例子中，我们看到化身视图和三个标签正在经历搅动。由于我是这个仪器的操作人员，我知道这些标签与标题标签、日期标签和日志条目标签相对应。这几乎是我们在这个细胞中的所有观点。这有点担心。让我们看看发生了什么事。好的，回到我们这里来。

 So look into the code and find  that UpdateConstraints is being  overridden. And in that method when anything  changes or when  UpdateConstraints runs at all,  we're removing all of the  constraints and then adding back  the ones that we think we still  need. Well, everything landed back in  the same place where it started. So that removal just is  contributing to performance  issues. So in the instance of the social  label here, social avatar thing,  being added and removed, we  don't actually need to pull it  all the way out. When you look at the constraints  around this view, you'll see  that they don't actually  interact with anything else,  just that particular view. So here you can use, you know,  this neat little feature called  setHidden, maybe you've heard of  it. And because it's not affecting  any of the views around it, it's  just going to disappear, it's  constraints stay in place and  this is a very, very, very cheap  way to hide and show views,  rather than removing them from  the hierarchy. So that's fine. But this is a really simple  example. What about the image view?  All right, so for the image  view, again we might we might  want to try removing all  constraints and then adding back  the ones we already had plus the  image view ones. And again, everything is landing  in the same place so we're  experiencing churn. Well, in a situation like this  how I want you to think about it  is to look at groups of  constraints. So let's start with this group  that I'm highlighting here in  green.

因此，查看代码并发现UpDATE约束被重写。在这种方法中，当任何事情发生变化或者当UpdateConstraints运行时，我们将删除所有约束，然后重新添加我们认为仍然需要的那些约束。一切都回到了起点。所以移除只是有助于性能问题。因此，在这里的社会标签，社会化身的东西，被添加和删除，我们实际上不需要把它全部拉出来。当你观察这个视图周围的约束时，你会发现它们实际上并不与其他任何东西交互，只是那个特定的视图。所以，你可以在这里使用这个叫做Sethidt的整洁的小功能，也许你已经听说过了。而且因为它不影响周围的任何视图，它只会消失，它的约束保持在适当的位置，这是隐藏和显示视图的非常、非常、非常便宜的方法，而不是将它们从层次结构中移除。这样就好了。但这是一个很简单的例子。图像视图呢？好，所以对于图像视图，我们可能会再次尝试去掉所有的约束，然后把已有的约束加上图像视图的约束。再一次，所有的东西都在同一个地方着陆，所以我们正在经历搅乳器。嗯，在这样的情况下，我想让你思考一下，看看一些限制因素。让我们从这个组开始，我在这里强调绿色。

 These constraints stay the same  in every one of our layouts. Once we're doing the hide and  show on the sharing view that  doesn't need to change, the  avatar view never moves, and the  labels never move other than the  log entry label being able to  get longer. So those green constraints  should be added when you create  the views and then left in  place. Don't touch them. They want to stay where they  are. But now we have the four  constraints that are controlling  the image view. So what do we do with those?  Well, let's stick them in an  array and let's also take the  constraints that are going to be  there when there's no image. And I very creatively named  these imageConstraints and  noImageConstraints so you can  keep them apart. And let's, when we're getting to  the point where we're going to  be putting in this image view or  taking it away, let's see what  layout we're currently in. Deactivate the  noImageConstraints if we need to  and activate the ones for the  image. If we don't have an image coming  in, you know, all of our other  constraints are already  activated, we just have the one  that we're adding. Now I put these both in arrays  despite the fact that this is a  single constraint because it  simplifies things in my code. I don't need to check and see  whether I'm dealing with an  array or a single constraint,  I'm always dealing with an array  of constraints.

这些约束在我们的每一个布局中都保持不变。一旦我们在不需要更改的共享视图上进行隐藏和显示，化身视图就永远不会移动，并且除了日志条目标签之外，其他标签也永远不会移动。因此，在创建视图后，应添加那些绿色约束，然后就位。不要碰他们。他们想呆在原地。但是现在我们有四个约束来控制图像视图。那么我们该怎么办呢？好吧，让我们把它们放在一个数组中，也让我们在没有图像的情况下接受约束。我很有创意地把这些想象中的名字命名为不可想象的，这样你就可以把它们分开。让我们，当我们到达要放进这个图像视图或把它拿走的点时，让我们看看我们目前的布局。如果我们需要激活图像中的图像，就去激活NoimixFistRunts。如果我们没有映像，你知道，我们所有其他约束条件都已经被激活了，我们只需要添加一个。现在我把这两个都放在数组中，尽管这是一个单一的约束，因为它简化了我的代码中的东西。我不需要检查和查看是处理数组还是单个约束，我总是处理约束数组。

 Your mileage may vary though. So the nice thing about this is  that if you are tracking your  constraints properly like this  and you know that you want to  add this image view live in  front of the user, you can  deactivate these  noImageConstraints, activate the  ImageConstraints and call Layout  in needed inside a View  Animation block and it's going  to animate nicely into your  view. If you tried to do this with  deactivating all of your  constraints and putting them  back in, it would look very  interesting. Let's say it that way. All right, so now that we've  debugged this and we're working  with groups of constraints  instead of throwing everything  at it, let's look at what it  will look like. This is what it looked like  originally just to remind you. Let's scroll to the top. It's very bad. And this is what it looks like  after we've debugged it. And that is much smoother. Thank you. But wait there's more!  I actually took this video on  iOS 11. This is not taking advantage of  any of our performance  improvements in iOS 12. This is just the client code  doing things more efficiently. In iOS12 it also looks great. And of course fabulous  [laughing]. Yes, it's great. So how do we avoid constraint  churn?  Well, avoid removing all of your  constraints. That's usually going to put you  into a situation where you have  to put a bunch of them back and  that's going to land you in a  position where you're relaying  out frames that don't need to --  or relaying out views that don't  need to be laid out again. If you have a set of constraints  that going to be common to all  of the potential layouts in your  app, add them one and then leave  them alone. This is a good use for Interface  Builder and the initial layout  of your app. Changes to the constraints that  need changing but don't change  the ones that don't need  changing.

你的里程可能会有所不同。这样做的好处是，如果像这样正确地跟踪约束条件，并且您知道要将此图像视图添加到用户面前，则可以禁用这些noImageConstraints，激活ImageConstraints，并在View Anim中调用Layout。块，它会生动地融入你的视野。如果你试着去激活所有的约束并把它们放回去，它看起来会很有趣。让我们这样说吧。好了，现在我们已经调试了这个，并且正在处理一组约束，而不是抛出所有的东西，让我们看看它会是什么样子。这就是它最初的样子，只是为了提醒你。让我们滚动到顶部。非常糟糕。这是我们调试后的样子。这就更平滑了。谢谢您。但是等待，还有更多！我在iOS 11上拍摄了这个视频。这并没有利用我们在iOS 12中的任何性能改进。这只是客户端代码更有效地做事。在IOS12中，它看起来也很棒。当然是难以置信的[笑]。是的，太棒了。那么，我们如何避免约束搅动呢？避免删除所有的约束。这通常会让你陷入这样的境地：你必须把一大堆文件放回原处，这样你就能处于这样的境地：你正在转发不需要的框架，或者转发不需要再次布局的视图。如果你的应用程序中所有的潜在布局都有一套共同的约束，那么就添加一个，然后让它们单独存在。这对于界面生成器和应用程序的初始布局来说是一个很好的应用。改变那些需要改变但不改变不需要改变的约束。

 Kind of tautological but it  seems good. And then you have a neat trick  now for hiding views instead of  removing them when that makes  sense. All right, so that was  constraint churn in the  instrument. We also have that view at the  bottom that said UILabel sizing. UILabel sizing is tracking the  amount of time it takes for the  label to calculate its size. So let's talk about intrinsic  content size. I'm going to take a walk over  here. OK, not all views actually need  intrinsic content size. Some views do. Views with non-view content like  to return a size for their  intrinsic content size based on  that non-view content. Two examples of this are  UIImageView, which uses the size  of its image to calculate its  intrinsic content size and  UILabel, which measures its text  and uses that to return its  intrinsic content size. There's nothing really magical  about intrinsic content size,  it's used to create constraints  by UIView.

有点重言式，但似乎不错。然后，你有一个巧妙的伎俩，现在隐藏的意见，而不是删除它们时，这是有道理的。好吧，这就是乐器的束缚。我们也有在底部的观点说UILABEL尺寸。ULababelSalm跟踪标签计算其大小所需的时间。让我们来谈谈内在内容的大小。我要在这里散步。好的，不是所有的视图都需要固有的内容大小。有一些观点。具有非视图内容的视图，以便根据非视图内容返回其内部内容大小的大小。这两个例子是UIIVIEVIEW，它使用其图像的大小来计算其固有的内容大小和UIABELL，它测量其文本并使用它来返回其固有的内容大小。没有什么真正神奇的内在内容大小，它用来创建约束的UIVIEW。

 It makes sizing constraints for  you and that's it. You can define all of your  sizing in constraints yourself  and skip this whole thing. There are a few circumstances  where it needs to be overridden,  that's what it's there, as we  saw there are these couple of  things plus some other examples  in UIView subclasses. But a lot of the times it gets  overridden because the  assumption that it's either  faster or more exact and it is  neither of those things. However, there is a circumstance  where overriding it might help  your performance. Text measurement can be  expensive. In our app here the UILabel  sizing did not take very long. It was very short durations. So messing around with that is  not going to improve the  performance of that that much. But if you have a text intensive  app and you're seeing a lot of  time happening in the UILabel  text measurement or you have  text view text measurement or  whatever else you're using, you  might be able to help it along  if you have some additional  information. If you know the size that the  text needs to be without doing  all that text measurement, you  can return that size and  intrinsic content size, or if  when you're going to be putting  this view on the screen the  constraints are going to be  fully defining the size  regardless of the size of the  text inside of it. For instance, the constraints  are always going to make it  larger than the amount of text  you have.

它为您提供大小限制，就是这样。您可以自己定义约束中的所有大小，跳过这整个事情。有几种情况需要重写它，这就是它存在的原因，正如我们看到的，在UIView子类中，除了一些其他示例之外，还有以下几点。但是很多时候它被推翻了，因为假设它要么更快，要么更精确，而这两者都不是。不过，有一种情况，推翻它可能会有助于你的表现。文本测量可能很昂贵。在我们的应用程序中，ULababelSalm没有花很长时间。时间很短。因此，用这种方法来解决这个问题并不能改善这一点。但是，如果你有一个文本密集型应用程序，并且你在UILabel文本测量中看到很多时间正在发生，或者你有文本视图文本测量或者你正在使用的其他任何东西，如果你有一些额外的信息，你可能能够帮助它。如果您知道文本需要的大小，而不需要执行所有的文本测量，则可以返回该大小和内在内容大小，或者当您将此视图放到屏幕上时，约束将完全定义该大小，而不管里面的文字。例如，约束总是会使它比你拥有的文本量大。

 Then you can go ahead and return  no intrinsic metric for the  width and height in intrinsic  content size. And what this will do is tell  the parent, hey I already have  my size, don't bother to do the  text measurement. So obviously this only works if  you're not trying to detect  measurement yourself, but it can  help some apps improve their  performance. So I wanted you to know that  this little trick exists. And we can't talk about  intrinsic content size without  talking about system layout size  fitting size because people  often conflate the two even  though they're kind of  opposites, so that's kind of  unfortunate. Intrinsic content size is a way  that you communicate size  information to be put into the  engine. System Layout Size Fitting Size  is a way that you get sizing  information back out of the  engine. They're actually kind of  opposites. So this is used in sort of mixed  layouts where there's some  reason that you need frame  information from a view that  manages its subviews using Auto  Layout. Not very frequent usage but is  there and can be used. I want to tell you how this  method works because it might be  a little more expensive than you  think.

然后，可以继续返回内在特征大小的宽度和高度的内在度量。这将告诉家长，嘿，我已经有了我的尺寸，不用费心去做文字测量了。So obviously this only works if  you're not trying to detect  measurement yourself, but it can  help some apps improve their  performance. 所以我想让你知道这个小把戏存在。And we can't talk about  intrinsic content size without  talking about system layout size  fitting size because people  often conflate the two even  though they're kind of  opposites, so that's kind of  unfortunate. 内部内容大小是一种将大小信息传递到引擎的方式。系统布局大小拟合大小是一种方法，你可以从引擎中调整大小信息。它们实际上是对立的。So this is used in sort of mixed  layouts where there's some  reason that you need frame  information from a view that  manages its subviews using Auto  Layout. 不是非常频繁的使用，但有，可以使用。我想告诉你这个方法是如何工作的，因为它可能比你想象的贵一些。

 When you call System Layout Size  Fitting Size an engine is  created. Constraints are added to this  engine, the layout is solved,  and then the size of the top  views frame is returned, and  then the engine gets discarded. So each time you call this  method an engine is being  created and discarded. While this is fine for small  uses, if you're doing it a lot  you can see how it might start  to build up over time. So be cautious when calling  System Layout Size Fitting Size. One of the uses that we  sometimes see people do is  forwarding that call from their  self-sizing collection or table  view cell to a content view. And when you do that you're  actually overriding some  optimizations we've made to make  that scrolling, scrolling in  that view faster and you're  adding extra engines. So if you're currently doing  that and your scrolling is no  good, maybe look into that. All right, now we come to my  very favorite topic in the  world. Unsatisfiable Constraints. OK, so what are unsatisfiable  constraints?  If you haven't run into this  before, this is what happens  when you do something like, hey  this view should be 50 points  wide, also it should be 200  points wide. Well, that's not really going to  work. These are not actually quantum  phones. You know, I can't speak to the  future but so the engine has to  kind of calculate the fact that  there's no layout available and  break a constraint in order to  generate some sort of layout for  you. When it breaks that constraint  it sends a very detailed log to  your debugger, possibly you've  seen it, that says, hey  unsatisfiable constraints. Here's the constraint that I  broke and here's all the other  ones that affected, that caused  me to have to break it.

当您调用系统布局尺寸拟合大小时，创建引擎。向该引擎添加约束，解决布局，然后返回顶视图框架的大小，然后丢弃引擎。因此，每次调用此方法时，正在创建并丢弃引擎。虽然这对于小的使用是好的，如果你做了很多，你可以看到它如何开始建立随着时间的推移。所以在调用系统布局尺寸时要谨慎。我们有时看到人们做的一个用途是将调用从自动调整大小的集合或表视图单元转发到内容视图。当你这样做的时候，实际上你正在重写一些我们已经做的优化，使得滚动，在那个视图中滚动更快，并且你正在添加额外的引擎。所以，如果你现在正在做，你的滚动是不好的，也许看看这个。好吧，现在我们来谈谈我最喜欢的话题。不可满足约束那么，什么是不可满足的约束条件？如果你以前没有遇到过这种情况，当你做类似事情的时候就会出现这种情况，嘿，这个视图应该有50点宽，也应该有200点宽。嗯，那不太管用。这些实际上不是量子电话。你知道，我不能谈论未来，但是为了为你生成某种布局，引擎必须计算没有可用布局的事实并打破约束。当它打破这个约束时，它会向调试器发送一个非常详细的日志，可能您已经看到了，也就是说，嘿，不能满足的约束。这里是我打破的约束，这里是所有其他受影响的，这使我不得不打破它。

 So this can sometimes affect  performance directly and it can  also mask other issues. So it's a good idea to get them  debugged. And Mysteries of Auto Layout,  Part 2, had some good debugging  information so you might be  interested in checking that out  if you have been having trouble  with your unsatisfiable  constraints. OK, guys you've graduated. Congratulations. You are all Auto Layout experts  and, you know, I hope that you  really enjoyed learning about  the internals of how it works. Now you know better how to think  before you update constraints  and understand the process they  go through, you've got some  tuning information with size and  priority and inequality, and you  have faster layouts in iOS 12 so  that's awesome. We're going to be in the Labs  tomorrow if anybody has  questions. And we've got the link here for  information in related sessions. Enjoy the rest of your week.

因此，这有时会直接影响性能，也会掩盖其他问题。所以把它们调试出来是个好主意。And Mysteries of Auto Layout,  Part 2, had some good debugging  information so you might be  interested in checking that out  if you have been having trouble  with your unsatisfiable  constraints. 好的，你们已经毕业了。祝贺你。你们都是汽车设计专家，我希望你们真的喜欢了解内部的工作原理。Now you know better how to think  before you update constraints  and understand the process they  go through, you've got some  tuning information with size and  priority and inequality, and you  have faster layouts in iOS 12 so  that's awesome. 如果有人问的话，我们明天就要进入实验室了。我们在这里得到了相关信息的链接。享受你剩下的一周。

