  Good morning, ladies and  gentlemen. How many of you are here for the  first time at WWDC?  That's fantastic. It's great to see so many new  faces every year. My name is Stuart Cheshire. And we're going to be talking  about networking. I'm going to start by covering  some topics that affect the  performance of your app. There's hardly an app that  exists today that doesn't make  use of networking. And getting the best performance  out of the network is really  important.

> 早上好，女士们，先生们。你们当中有多少人第一次来到WWDC？那太棒了。每年看到这么多新面孔真是太好了。我叫斯图尔特.柴郡。我们要谈的是网络。我将从一些影响应用程序性能的主题开始。现在几乎没有一个应用程序不使用网络。从网络中获得最佳性能是非常重要的。

 We're going to cover some  technologies here that help you  get the best performance. We're also going to cover some  tips and tricks and guidance  about how to make the best use  of Apple's APIs, a little bit of  news about new technologies on  the horizon, and then my  colleague Jiten will go into  detail on URLSession. Let's start off with a state of  the Internet update. Earlier this year, we hit a  total of 4 billion people using  the Internet. That's more than half of the  world's population. And we're used to Internet usage  doubling and doubling. Clearly when we passed halfway,  the number of people on the  Internet can't keep doubling, so  that growth is slowing down but  that doesn't mean Internet  growth is slowing down. There's a lot of growth in  machine-to-machine  communications, Internet of  Things, Smart Homes. There's still a lot of growth in  places like India and China. And there is a lot of people who  have never owned a desktop  computer who may never own a  desktop computer. Their primary computing and  communication device is their  Smartphone.

> 我们将在这里覆盖一些技术，以帮助您获得最好的性能。我们还将介绍一些关于如何充分利用苹果API的提示、技巧和指导，以及一些即将出现的新技术的新闻，然后我的同事Jiten将详细介绍URLSession。让我们从互联网更新的状态开始。今年早些时候，共有40亿人使用互联网。这是世界人口的一半以上。我们习惯了互联网使用的加倍和加倍。很显然，当我们中途经过时，互联网上的人数不能保持翻倍，所以增长正在放缓，但这并不意味着互联网的增长正在放缓。机器对机器的通信、物联网、智能家庭有很大的增长。在像印度和中国这样的地方仍然有很多增长。而且有很多人从来没有拥有台式电脑，他们可能永远不会拥有台式电脑。他们的主要计算和通信设备是他们的智能手机。

 And a lot of those Smartphones  are still using 2G networks. I'm sure most of us in this room  are fortunate enough to live in  places and work in places where  we build our apps where we have  fast LTE networks. And that can be a handicap  because if you build your app so  it works well in LTE, it may  perform very, very badly on 2G. One of your competitors,  somewhere else in the world, who  builds an app that works great  on 2G is going to be fantastic  on LTE. So we have a tool to help  everybody mimic some of the  properties of these slower  networks and that's Network Link  Conditioner. You should build your app  running Network Link Conditioner  right from the start. Don't think you can add in  performance at the end because  it's too late. Always, always, always run and  test your app using Network Link  Conditioner and that way if you  make a programming mistake that  has horrible performance  implications, you see it right  away and you can fix it right  away. Use tools like Wireshark and  tcptrace to understand the  network performance of your app. It's a lot like using  Instruments to look at memory  and CPU usage. If you haven't seen tcptrace, it  is a wonderful tool that  produces graphs like this that  let you see at a glance what's  going on, on the network. If you want to learn more about  that, check out the video from  three years ago. IPv6 usage continues to grow. Why is that important?  It's important because IPv6 is  shown to have better performance  than IPv4. And if you care about  performance, you want to make  sure not just your app but the  service your app is talking to  support Native IPv6. Some places in the world are  doing better in this respect  than others. In the US, we're now up to 87%  of mobile carriers offering  IPv6. Other places like India are  doing pretty well too. And let's focus a bit more on  India.

> 很多智能手机仍在使用2G网络。我敢肯定，我们这间屋子里的大多数人都很幸运，能够住在有快速LTE网络的地方，并在那里开发应用程序。而这可能是一个障碍，因为如果你构建你的应用程序在LTE中运行良好，那么它在2G上的表现可能非常非常非常糟糕。你的竞争对手之一，在世界其他地方，谁构建一个在2G上运行良好的应用程序，在LTE上将会非常出色。所以我们有一个工具来帮助大家模仿这些慢速网络的一些特性，那就是网络链接调节器。你应该从一开始就建立你的应用程序运行网络链接调节器。不要认为你可以在最后增加业绩，因为已经太迟了。总是，总是，总是使用NetworkLinkConditi.来运行和测试你的应用程序，这样如果你犯了一个编程错误，它具有可怕的性能影响，你马上就能看到它，并且你可以马上修复它。使用WiReSARK和TCPWrand等工具来理解应用程序的网络性能。这很像使用仪器来查看内存和CPU使用情况。如果您没有见过tcptrace，那么它是一个极好的工具，可以生成这样的图，让您一眼就能看到网络上正在发生的事情。如果你想了解更多的信息，请查看三年前的视频。IPv6的使用量持续增长。为什么这么重要？这是很重要的，因为IPv6被证明具有比IPv4更好的性能。如果你关心性能，你不仅要保证你的应用而且要保证你的应用正在使用的服务支持原生IPv6。世界上有些地方在这方面比其他地方做得更好。在美国，我们现在有87%的移动运营商提供IPv6。像印度这样的其他地方也做得很好。让我们把重点放在印度上。

 Here is some data that the  networking team at Apple  gathered earlier this year about  net TCP connection setup time  and ongoing round-trip delay on  cellular networks in India. The blue line is IPv6. And if we, for example, look at  the 75th percentile, we can say  75% of TCP connections over v6  are set up in less than 150  milliseconds. The comparable number for IPv4  is worse than 325. It's more than twice as slow. So if you want fast, responsive  applications for your users, get  on IPv6 if you're not already. Another technology that improves  performance by reducing packet  loss and retransmission is  Explicit Congestion  Notification. We've had this enabled by  default in macOS and iOS for  some years now so you don't need  to do anything on your  application to take advantage of  this. Do make sure your service  supports ECN. In a survey we did of the Alexa  top million websites, we found  last month we're now up to 77%  of the Alexa top million  services supporting ECN, which  is a big improvement compared to  a few years ago. Another technology that helps  improve performance and  resilience of your connections  is Multipath TCP.

> 这是今年早些时候苹果公司的网络小组收集的一些数据，这些数据是关于印度蜂窝网络的网络TCP连接建立时间和往返延时的。蓝线是IPv6。例如，如果我们看一下第75个百分点，我们可以说v6上的75%的TCP连接是在不到150毫秒内建立的。IPv4的可比数大于325。它的速度是慢的两倍多。所以，如果你想为用户快速响应应用程序，如果你还没有的话，请继续IPv6。另一种通过减少分组丢失和重传来提高性能的技术是显式拥塞通知。我们已经在macOS和iOS中默认启用此功能很多年了，所以您不需要对您的应用程序做任何事情来利用这一点。确保你的服务支持ECN。在上个月我们对Alexa排名前百万的网站所做的一项调查中，我们发现，在Alexa排名前百万的支持ECN的服务中，我们占到了77%，与几年前相比，这是一个很大的进步。另一种有助于提高连接性能和弹性的技术是多路径TCP。

  You can check out more details  of that from our video from  three years ago. And check with your server  operators to make sure that your  servers support TCP Fast Open. Now moving on to some new news. There is a technology that many  of you will have heard of called  Quick. Quick is a new transport  protocol, the first serious  candidate in 30 years for a  successor to replace TCP. It started off as an experiment  by some engineers at Google. That experiment proved  successful. It has now been adopted as an  IETF work in group item for  standardization. Apple engineers are  participating in that. In fact, we have engineers right  now at the Quick meeting taking  place in Sweden. This is not yet ready for prime  time. The standard is not finished,  but Apple is working on it.

> 你可以从三年前的视频中查看更多细节。并与服务器运算符进行检查，以确保服务器支持TCP快速打开。现在开始关注一些新消息。有一种技术，你们很多人都会听说过。Quice是一种新的传输协议，是30年来第一个严重的替代TCP接替者。它开始于谷歌的一些工程师的实验。实验证明是成功的。它已被采纳为IETF工作组项目的标准化。苹果工程师正在参与其中。事实上，我们马上就有工程师在瑞典举行快速会议。这还没有准备好黄金时段。标准还没有完成，但苹果正在努力。

 As soon as it is ready, you can  expect to see Apple API  supporting that. Continuing in the theme of  performance, we observed some  behavior that's very common. Lots and lots of websites and  Internet services use pretty  short lifetimes on their DNS  records. And they do this because if a  data center goes down, they want  to be able to update the DNS and  very rapidly direct traffic to a  different data center. The problem with this approach  is you're paying a performance  cost for something that almost  never happens. Data centers very rarely go  down. And what this means is every  time a DNS address record is  expired, your client has to  spend another round-trip delay  waiting for the response from  the DNS server, which is the  same as what it knew already  last time. So thinking about this, we  realized and optimization we  could do. If you pass the flag to opt into  this new behavior, then when you  do a DNS query, if we have a  stale, expired answer in the  cache, we will give that to you  immediately while in parallel,  at the same time, doing the  normal DNS query we would have  done anyway. If the answer comes back the  same, as we predict it will  almost always, everything is  fine, you just saved a  round-trip time and got your  connection started faster. If the answer comes back as a  different address, we will then  give another asynchronous  notification to your client that  there's a new address available  which it should also try. And to make use of this, you  have to use it in conjunction  with Happy Eyeballs algorithm. That means your racing multiple  connections in parallel. You're trying IPv4, IPv6,  multiple addresses, multiple  interfaces. If that sounds like a lot of  work and it's hard to get right,  you're absolutely correct. It is a lot of work. Stay after the break and we will  tell you about some new APIs  that let you take advantage of  this without doing all the hard  work yourself. Now moving on to some guidance. We have seen a common pattern  that many developers use  SCNetworkReachability as a  preflight check.

> 一旦它准备好，你可以看到苹果API支持它。在表演的主题中，我们观察到一些非常常见的行为。大量的网站和互联网服务在DNS记录上使用很短的生命周期。他们这样做是因为，如果数据中心出现故障，他们希望能够更新DNS，并且能够非常迅速地将流量引导到不同的数据中心。这种方法的问题是，你为几乎从未发生过的事情付出了性能代价。数据中心很少会下降。这意味着每当DNS地址记录过期时，您的客户机必须花费另一个往返延迟等待来自DNS服务器的响应，这与上次它已经知道的相同。因此，考虑到这一点，我们可以实现和优化。如果您传递标志以选择进入这种新行为，那么当您进行DNS查询时，如果我们在高速缓存中有一个过期的、过期的、过期的答案，我们将立即将该答案提供给您，同时并行地执行我们本来应该执行的常规DNS查询。如果答案还是一样的，正如我们预测的，几乎总是这样，一切都很好，你只是节省了往返时间，使连接更快地开始。如果答案返回为不同的地址，那么我们将向您的客户机发出另一个异步通知，告知您还有一个新地址可用，客户机也应该尝试一下。为了利用这一点，你必须结合快乐眼球算法来使用它。这意味着你的赛车多个连接并行。您正在尝试IPv4、IPv6、多个地址、多个接口。如果这听起来像是很多工作，很难得到正确的，你是绝对正确的。这是一项很大的工作。休息后留下来，我们会告诉你一些新的API，这些API让你不用自己做所有的努力就能利用这些API。现在转向一些指导。我们看到了一个常见的模式，许多开发人员使用SCNETWorkAccess作为预检检查。

 They want to predict the future. They want to know whether the  next network operation they do  will succeed or fail. And, unfortunately, predicting  the future is always a hard  thing to do. You may have connectivity now  but two seconds from now the  user has walked out of the  building and you've lost the  Wi-Fi signal. So there is no way to guarantee  whether a future operation will  succeed. And we see this pattern where  they check. The preflight says yes. They try it. They fail. They go back. They check again. This also is a lot of work, a  lot of [inaudible], a lot of  difficult things to get right  including networks with proxies. We can handle that for you.

> 他们想预测未来。他们想知道下一个网络操作是否成功。不幸的是，预测未来总是很难做到的。你现在可以连接了，但是两秒钟后用户走出了大楼，你丢失了Wi-Fi信号。因此，没有办法保证未来的行动能否成功。我们看到了这种模式。飞行前说是的。他们试试看。他们失败了。他们回去了。他们再次检查。这也是大量的工作，很多[听不见]，很多困难的事情，包括代理网络。我们可以帮你处理。

 The better way to do this is  just make a connection using the  waitsForConnectivity option. You can learn more about that  watching last year's video. What this means is if you want a  connection, you tell the system  I want a connection. Now if you can, later if not. If the device is in airplane  mode, then when it's out of  airplane mode your connection  will succeed. That is much easier than  building the retry loop  yourself. There is one case we've seen  with developers which does make  sense which is if you're going  to have the user answer a lot of  information in a form, you may  not want to waste the user's  time if you have good reason to  believe that may later fail. If that is the use case you care  about, stay after the break  because we have a new way to do  that that's much better. Security remains important, as  always. After ten years of using TLS  1.2, the Internet is now ready  to move to its successor, TLS  1.3. It has a number of improved  security features.

> 更好的方法是使用WaITsFrink连接选项进行连接。你可以从去年的视频中了解更多。这意味着如果你想要一个连接，你告诉系统我想要一个连接。如果可以的话，如果不是的话。如果该设备处于飞机模式，那么当它脱离飞机模式时，你的连接将成功。这比构建自己的重试循环要容易得多。对于开发人员来说，有一件事情是合理的，那就是，如果您想让用户以表单回答大量信息，那么如果您有充分的理由相信以后可能会失败，那么您可能不想浪费用户的时间。如果这是你所关心的用例，休息后，因为我们有一个新的方式，这是更好的。安全仍然是重要的，一如既往。在使用TLS 1.2的十年之后，互联网现在已经准备好转移到它的继任者TLS 1.3。它具有许多改进的安全特性。

 It has reduced connection setup  time, similar to TCP Fast Open. That standard is now final. The final draft was approved for  publication by the Internet  Engineering Steering Group  earlier this year. We are waiting for the actual  published document to come out  of the RFC Editor. And when that does, we'll be  turning on TLS 1.3 by default. Right now in your seed, it's not  turned on by default. You can use the instructions  here on iOS or macOS to enable  TLS 13 in your applications. And we encourage you to do this  right away because later this  year when TLS 1.3 is turned on  by default, you don't risk  problems with your service not  being compatible. So test them right now to make  sure everything will go smoothly  when the switchover happens  later this year. Another element of security  that's new is certificate  transparency. You've probably heard cases  where certificate authorities,  either through malice or  incompetence, issue rogue  certificates to entities that  they should not.

> 它减少了连接建立时间，类似于TCP快速打开。那个标准现在是最后的了。今年早些时候，互联网工程指导小组批准了最终草案。我们正在等待实际发布的文档从RFC编辑器中出来。当这样做时，我们将默认打开TLS 1.3。现在在你的种子中，它不是默认的开启。您可以在iOS或MaOS上使用这些指令，以便在应用程序中启用TLS 13。我们鼓励您立即这样做，因为今年晚些时候当TLS 1.3默认打开时，您不会面临服务不兼容的问题。所以现在测试他们，确保在今年晚些时候切换时一切都会顺利进行。另一个新的安全元素是证书透明度。您可能听说过，证书颁发机构通过恶意或不称职，向实体颁发不应该颁发的流氓证书。

 The solution to this is  something called certificate  transparency logs. Every legitimate certificate  authority now issues a public  statement of every certificate  it issues. And those are recorded in public  logs for anybody to inspect. And this means that if a rogue  certificate authority issues a  bogus certificate, if it  publishes it, they'll  immediately get caught. And if they don't publish it,  they'll be caught by the client. This is the setup you're  probably familiar with. The new entity here is the log. When a certificate authority  issues a certificate to a  server, it also records that  with the log and the log gives  the server a signed affidavit  that its certificate has been  publicly recorded. And then when the client  connects, the server can give  all that information to the  client and the client can verify  that not only is this a signed  certificate, it is a publicly  logged signed certificate. Now suppose we have a rogue  certificate authority that  doesn't publicly expose the  rogue certificates it's issuing. The client will reject that  because it doesn't have the  affidavit to attest to it being  recorded in a public log. Starting later this year, we  will be enforcing this. All newly issued TLS  certificates must include the  verification that they are  publicly logged. And if they're not, then the  client will reject it. Your apps don't need to make any  changes, but if you have  tailored certificates for your  servers, make sure that your  certificate authority is  recording them in the public  certificate transparency logs. Now we have a bit of news for  hardware developers. The Bonjour Conformance Test is  a tool that lets you verify that  your hardware devices implement  Bonjour correctly. You need to run this test if you  want to use the Bonjour  trademark name and logo on your  packaging.

> 解决这个问题的方法是证书透明日志。每个合法的证书颁发机构现在发布它所颁发的每个证书的公开声明。这些记录在公共日志中，供任何人检查。这意味着，如果一个流氓证书颁发机构发布了虚假的证书，如果它发布了，它们将立即被抓住。如果他们不公布，他们就会被客户抓住。这是你可能熟悉的设置。这里的新实体是日志。当证书颁发机构向服务器颁发证书时，它还将证书与日志一起记录，日志向服务器提供已签名的证书，证明其证书已被公开记录。然后，当客户端连接时，服务器可以向客户端提供所有信息，并且客户端可以验证这不仅是一个已签名的证书，还是一个已公开记录的已签名的证书。现在假设我们有一个不公开公开其发布的流氓证书的流氓证书颁发机构。客户端将拒绝它，因为它没有证据证明它被记录在一个公共日志中。从今年晚些时候开始，我们将实施这一计划。所有新发布的TLS证书都必须包括它们被公开记录的验证。如果它们不是，那么客户会拒绝它。您的应用程序不需要做任何更改，但是如果您已经为您的服务器定制了证书，请确保您的证书颁发机构将它们记录在公共证书透明日志中。现在我们有了一些关于硬件开发人员的消息。Bunjor一致性测试是一种工具，可以让您验证硬件设备正确地执行Bunjor。如果你想在你的包装上使用Bunjor商标名称和徽标，你需要运行这个测试。

 You need to run this test if you  want to bundle the Bonjour for  Windows installer with a Windows  application. And if you want to use the  AirPrint, AirPlay, CarPlay,  HomeKit logos on your packaging,  passing the Bonjour Conformance  Test is a part of the logo  licensing process because  reliable Bonjour is an essential  part of those products. But more importantly, the value  of running the Bonjour  Conformance Test is it helps you  improve the quality of your  products and that makes them  more reliable which makes your  customers happy which makes your  customers not return the product  to the store because they can't  make it work. And that's what your customers  want. That's what you want. And that's what we want. We want happy customers having a  wonderful time with products  that work reliably. Now I want to cover API choices. Thirty years ago we had BSD  Sockets. And it was a great API 30 years  ago. But 30 years ago we didn't have  mobile computers in our pockets. We didn't have wireless  networking. We didn't have IPv6.

> 如果要将Windows安装程序的Bunjor与Windows应用程序捆绑在一起，则需要运行此测试。如果你想在包装上使用AirPrint、AirPlay、CarPlay、HomeKit徽标，通过Bonjour一致性测试是徽标许可过程的一部分，因为可靠的Bonjour是这些产品的重要组成部分。但更重要的是，运行Bonjour一致性测试的价值在于，它帮助您提高产品的质量，并使它们更加可靠，从而使您的客户满意，从而使您的客户不会因为无法使产品工作而将产品退回商店。这就是你的客户想要的。这就是你想要的。这就是我们想要的。我们希望快乐的客户有一个美好的时间与可靠的产品。现在我想介绍一下API的选择。三十年前，我们有BSD插座。这是30年前的一个很棒的API。但30年前，我们口袋里没有移动电脑。我们没有无线网络。我们没有IPv6。

 We didn't have many computers  with more than one network  interface. If you had an Ethernet port on  your computer, that was a fancy  computer. Now 4 billion people around the  world have a multi-homed IPv6  wireless battery-powered  computing device that does power  management and goes to sleep to  save energy. The world has become a lot more  complicated. Many of you may be using  third-party libraries which are  built on that Sockets  foundation. Many more of you may be using  URLSession. And you may have assumed that  URLSession is also just a wrap  around Sockets. Well, not quite.

> 我们没有很多计算机，有一个以上的网络接口。如果你的计算机上有一个以太网端口，那就是一台漂亮的计算机。现在，全世界有40亿人拥有一个多宿主的IPv6无线电池供电的计算设备，该设备进行电源管理，并睡觉以节省能源。世界变得更加复杂了。你们中的许多人可能正在使用第三方库，这些第三方库都是建立在这个插座基础上的。你们中的很多人可能正在使用URLSIST。您可能已经假设URLSIST也是一个环绕套接字。嗯，不完全是这样。

 URLSession is actually built  using Apple's user space  networking code network  framework. And starting now, in iOS 12, we  are exposing that same API that  URLSession uses so that your  apps can directly use that for  making TCP connections and other  appropriate use cases. If you're doing things with URLs  and HTTP GETs, URLSession is  still your API of choice. But for the things URLSession  doesn't cover, we now expose  network framework so your apps  can use that directly. And if you're the developer of  one of these third-party  libraries, which are very  popular that are built on BSD  Sockets, we encourage you to  look at the network framework  APIs. Move your library over to these  improved high-performance APIs,  and give us feedback about how  that goes for you. So to summarize, we really  strongly recommend here and now  in 2018 that you avoid using BSD  Sockets. Avoid using libraries that are  nothing but wrappers around BSD  Sockets. And if you are one of the  authors of those libraries using  these older APIs, look at  switching over. Come and meet us in the labs  this afternoon and tomorrow and  give us your feedback about what  it takes to move your libraries  to new APIs. And with that, I would like to  invite my colleagues Jiten to  come up on stage and give you  more details about URLSession.  Thank you, Stuart. Good morning everyone. My name is Jiten Mehta. And I'm an engineer on the CF  network team.

> URLSEST实际上是使用苹果的用户空间网络代码网络框架构建的。从现在开始，在iOS 12中，我们将公开URLSession使用的相同的API，以便您的应用程序可以直接使用它来建立TCP连接和其他适当的用例。如果你用URL和HTTP获取来做事情，URLSIST仍然是你选择的API。但是对于URLSECTION没有覆盖的东西，我们现在公开了网络框架，以便您的应用程序可以直接使用它。如果您是这些基于BSD Sockets的非常流行的第三方库之一的开发人员，我们鼓励您查看网络框架API。把你的图书馆移到这些改进的高性能API，并给我们反馈一下你的情况。总而言之，我们现在强烈建议在2018中避免使用BSD套接字。避免使用只不过是BSD套接字周围的包装的库。如果您是使用这些旧API的那些库的作者之一，请查看切换。今天下午和明天来实验室与我们见面，给我们一些反馈，告诉我们如何将你们的库迁移到新的API。因此，我想邀请我的同事Jiten上台，给大家更多关于UrScript的细节。谢谢你，斯图亚特。大家早上好。我叫Jiten Mehta。我是CF网络团队的工程师。

 Today I'll be talking to you  about some networking best  practices for your apps. Networking is an essential part  of every application. Each year, you guys do a great  job of adding awesome features  to your apps. And today I'll be talking to you  about some simple networking  details, details that can help  make your apps successful. Our agenda for today is going to  cover four categories: reducing  latency, maximizing throughput,  increasing responsiveness, and  making better use of system  resources. Before that, let's quickly  review URLSession, the API  you've been using. URLSession is the recommended  high-level networking API  available on all Apple  platforms. URLSession has first-class  support for HTTP/2 and HTTP/1.1.

> 今天，我将向大家介绍一些应用程序的网络最佳实践。网络是每一个应用程序的重要组成部分。每年，你们都会在应用程序中添加很棒的功能。今天我将和大家讨论一些简单的网络细节，这些细节可以帮助你的应用程序成功。我们今天的议程将包括四类：减少延迟、最大化吞吐量、提高响应能力和更好地利用系统资源。在这之前，让我们快速回顾一下你正在使用的API的URLSIST。URLSIST是所有苹果平台上推荐的高级网络API。URLSEST对HTTP\/2和HTTP\/ 1.1具有一流的支持。

 If your app does not use HTTP,  we have support for  URLSessionStreamTask, an API  that allows you to make secure  TCP connections to a server over  which you can build your  arbitrary protocol. That's URLSession. Let's move on to our first  agenda item: reducing latency. Let's suppose you and your  friends go to a restaurant where  the waiter walks up to you and  you say, "Can I get a glass of  water please?"  The waiter say, "Sure," walks  away, fetches you a glass of  water. Your friend then says, "Can I  get a glass of water too?"  The waiter says, "Sure," walks  away, and fetches your friend a  glass of water. Wouldn't it be faster if the  waiter took everyone's order at  the same time and reduce the  number of round trips?  The idea to reduce latency is  simple. To reduce the number of back and  forths when you fetch a  resource. Let's see how your apps can do  this. First, let's look at some issues  with HTTP/1.1. Your app wants to fetch a  resource, you can create a  URLSession task and call resume. URLSession will create a new  connection for you, which  involves DNS, TCP and TLS. Once the connection to the  server is established, we will  send out your request.

> 如果您的应用程序不使用HTTP，我们支持URLSessionStreamTask，这是一个API，允许您与服务器建立安全的TCP连接，您可以通过该连接建立任意的协议。那是URLISTAN。让我们进入我们的第一个议程项目：减少等待时间。让我们假设你和你的朋友去一家餐馆，服务员向你走来，你说，“请给我一杯水好吗？”服务员说：“当然，”走开，给你拿一杯水来。然后你的朋友说：“我也能得到一杯水吗？”服务员说：“当然，”走开，给你的朋友一杯水。如果服务员同时拿走每个人的订单，减少往返次数，这不会更快吗？减少延迟的想法很简单。在获取资源时减少后退和前进的数量。让我们看看你的应用程序是如何做到这一点的。首先，让我们看看HTTP／1.1的一些问题。你的应用程序想获取资源，你可以创建一个URLSIST任务并调用恢复。URLSIST将为您创建一个新的连接，包括DNS、TCP和TLS。一旦建立到服务器的连接，我们将发送您的请求。

 We will then wait to get a  response from the server. This is the network idle time  when your app is not doing any  kind of networking, waiting to  get a response from the server. Once we get a response, we will  call your completion block or  message your delegate indicating  that the load has finished. Let's suppose in the middle of  this load your app wants to  fetch another resource from the  same server. You can create another  URLSession task called resume  and URLSession will create a new  connection to fetch this  resource since it does not have  an idle connection in its  connection pool. If your app wants to fetch yet  another resource from the same  server, you can create another  URLSession task and call resume  and we will create another  connection to fetch the  resource. In this example, I've shown you  that we've created three  different connections to fetch  these resources from the same  server. If you notice, we've spent a lot  of time opening new connections. Let's see how this would look  like if you used a single  connection instead. This is a single connection  case. We saved a lot of time by not  opening new connections, but  there is another problem here. The request number two which is  the green request has to wait  until response number one is  fully received. The same problem applies to  request number three which is  the orange request which has to  wait until response number two  is fully received. This problem is known as HTTP  head-of-line blocking. Consider moving to HTTP/2. HTTP/2 uses a single connection,  and it also solves the HTTP  head-of-line blocking problem. HTTP/2 multiplexes multiple  streams over a single connection  allowing you to receive parallel  responses in an [inaudible]  fashion.

> 然后，我们将等待从服务器得到响应。这是网络闲置时间，当你的应用程序不做任何类型的网络，等待从服务器得到响应。一旦得到响应，我们将调用您的完成块或向您的委托消息表示负载已完成。让我们假设在这个负载的中间，你的应用程序想要从同一个服务器获取另一个资源。您可以创建另一个URLSession任务，称为.e，URLSession将创建一个新的连接来获取这个资源，因为它的连接池中没有空闲连接。如果您的应用程序想从同一台服务器获取另一个资源，您可以创建另一个URLSession任务并调用.e，我们将创建另一个连接来获取资源。在这个例子中，我已经向您展示了我们已经创建了三个不同的连接来从同一个服务器获取这些资源。如果你注意到，我们花了很多时间打开新的连接。让我们看看如果你使用了一个连接，它会是什么样子。这是一个单独的连接情况。我们通过不建立新的连接节省了很多时间，但是这里还有另外一个问题。第二个请求是绿色请求，直到第一个响应请求被完全接收为止。同样的问题也适用于第三个请求，即橙色请求，它必须等待直到完全接收到响应号2。这个问题被称为HTTP线阻塞。考虑移动到HTTP\/2。HTTP／2采用单一的连接方式，也解决了HTTP封头阻塞问题。HTTP\/2通过单个连接多路复用多个流，允许您以[不可闻]的方式接收并行响应。

 Let's analyze this example a  little more to see how HTTP/2  performs better than HTTP/1.1. Pay attention to the times when  your app wants to fetch a  resource and the time when the  request is sent out. In the HTTP/1.1 case, there is a  significant delay between the  time when your app desires a  resource and the time the  request is sent out. HTTP/2 can significantly reduce  this delay and allows us to send  the request almost immediately  when the app desires the  resource. Also pay attention to these gray  boxes. If you recall, this is the  network idle time when your app  is not doing any networking,  waiting to get a response from  the server. HTTP/2 can significantly reduce  this network idle time allowing  you to better utilize the  bandwidth and load the resources  much faster. We just discussed many benefits  of using HTTP/2 over HTTP/1.1,  but let's quickly summarize  them. HTTP/2 solves the head-of-line  blocking problem at the HTTP  layer.

> 让我们更详细地分析这个例子，看看HTTP／2如何比HTTP／1.1更好地执行。注意你的应用程序想要获取资源的时间和请求发出的时间。在HTTP\/1.1的情况下，在应用程序需要资源的时间和发出请求的时间之间存在显著的延迟。HTTP\/2可以显著减少这种延迟，并且允许我们在应用程序需要资源时几乎立即发送请求。还要注意这些灰色的盒子。如果您还记得，这是网络空闲时间，此时应用程序没有进行任何联网，正在等待服务器的响应。HTTP\/2可以显著减少网络空闲时间，从而可以更好地利用带宽，更快地加载资源。我们刚刚讨论了在HTTP\/1.1上使用HTTP\/2的许多好处，但是让我们快速总结它们。HTTP／2解决了HTTP层中的行阻塞问题。

 And it also allows you to better  utilize the bandwidth. If your apps use URLSession, you  don't need to make any  client-side changes. Simply enable HTTP/2 on your  servers and you will see these  benefits. By adopting HTTP/2, you can also  get some server-side savings  because devices running your  apps will now make fewer  connections to the servers. This year, we have something new  in URLSession that is going to  add to the advantages of HTTP/2. Introducing HTTP/2 Connection  Coalescing for URLSession. HTTP/2 Connection Coalescing is  going to increase connection to  use even more. Since your apps are not going to  be opening new connections, they  will become more responsive to  your users. Starting with the [inaudible],  HTTP/2 Connection Coalescing is  going to be automatically done  on for all your apps using  URLSession. Now let's see how Connection  Coalescing decides to reuse  connections. Let's suppose you have an app  and that app wants to fetch a  resource from menu.example.com.

> 它还允许你更好地利用带宽。如果您的应用程序使用URLSIST，则不需要进行任何客户端更改。只需在服务器上启用HTTP／2，您就可以看到这些好处。通过采用HTTP\/2，您还可以获得一些服务器端节省，因为运行应用程序的设备现在与服务器的连接将更少。今年，我们在URLScript中有了一些新的东西，这将增加HTTP／2的优势。为URLSIST引入HTTP／2连接合并。HTTP／2连接合并将增加连接以使用更多。因为你的应用程序不会打开新的连接，所以它们会对你的用户更加敏感。从[不可闻]开始，HTTP\/2连接合并将自动对使用URLSession的所有应用程序进行。现在让我们看看连接合并如何决定重用连接。假设你有一个应用程序，这个应用程序想从MeNeExpLo.com获取资源。

 We open a connection with the  server, and the server presents  us with the certificate. If your app wants to fetch  another resource from  delivery.example.com, we open  another connection and the  server presents us with another  certificate. This is the old behavior where  URLSession would create two  connections to fetch these  resources from the given host  names. But if you look closely, the  first certificate presented to  us covers all the subdomains  under example.com which means  delivery.example.com is covered  by this first certificate. Also notice that  delivery.example.com, it results  to the same IP address as the  first connection. At this point, it's safe for us  to assume we're talking to the  same endpoint and reuse the  connection instead of opening a  new one when we want to fetch  the second resource. This saves us time by not  opening a new connection and  makes the load much faster.

> 我们打开与服务器的连接，服务器向我们提供证书。如果您的应用程序想从..example.com获取其他资源，我们打开另一个连接，服务器将向我们提供另一个证书。这是旧的行为，其中URLSIST将创建两个连接来从给定的主机名中获取这些资源。但如果仔细观察，提交给我们的第一个证书涵盖example.com下的所有子域，这意味着..example.com由第一个证书覆盖。还要注意，TeleVel.Excel。com，结果与第一个连接的IP地址相同。此时，假设我们正在与同一个端点通信，并重用连接，而不是在想要获取第二个资源时打开一个新的连接，这对我们是安全的。这节省了我们的时间不打开一个新的连接，使负载更快。

 HTTP/2 [inaudible] HTTP/2  Connection Coalescing new in iOS  12 and macOS Mojave. Now let's see how using fewer  URLSession objects can help  reduce latency. All the benefits of connections  we use that we just discussed in  the previous slides are  applicable only if you use the  same URLSession object to create  your tasks. It's also important to know that  every URLSession object has a  connection pool and when you  create multiple of these  URLSession objects, you don't  get any benefit of connection to  use. It's also important to note that  the URLSession objects are  fairly expensive to create and  have a non-trivial memory  footprint. As we have in the past, we  continue to advise you to use  fewer URLSession objects.

> HTTP \/ 2 [听不见] HTTP \/ 2连接合并在iOS 12和MaOS MOJAVE中的新。现在让我们看看如何使用更少的URLSISTION对象可以帮助减少延迟。只有在使用相同的URLSession对象来创建任务时，我们在前面的幻灯片中刚刚讨论的连接的所有优点才适用。了解每个URLSession对象都有一个连接池也很重要，当您创建多个URLSession对象时，您将无法获得任何使用连接的好处。同样重要的是要注意，URLSession对象创建起来相当昂贵，并且具有非平凡的内存占用。正如我们在过去一样，我们继续建议您使用更少的URLSECTION对象。

 Let's move on to our next topic  for the day: maximizing  throughput. Coming back to our restaurant  example. The waiter checks up on you and  you say, "Can I get an order of  grilled chicken tossed in creamy  tomato onion gravy made with a  lot of butter?"  Now that's a mouthful. Wouldn't it be easier if you  just said, "Can I get butter  chicken?"  The idea to maximize throughput  is the same where you reduce the  number of bytes that you  transmit when you want to fetch  a resource. Let's see how your apps can do  this. Let's look at a couple of ways  to reduce the request size. Pay attention to HTTP cookies. They are not free and have a  non-trivial cost in storing and  looking them up. Cookies are attached to all the  requests that match the domain  and path attribute.

> 让我们进入下一个主题：最大化吞吐量。回到我们餐厅的例子。服务员检查你的情况，你说：“我可以点一份烤鸡肉加奶油西红柿洋葱肉汁吗？”这是一口。如果你说：“我能吃黄油鸡肉吗？”最大化吞吐量的思想与减少获取资源时发送的字节数相同。让我们看看你的应用程序是如何做到这一点的。让我们看看减少请求大小的两种方法。注意HTTP Cookie。它们不是免费的，在储存和查找它们时有着不小的成本。Cookie被附加到匹配域和路径属性的所有请求中。

 And it can quickly increase your  request size. Please use the domain and path  attribute wisely to make sure  cookies required by the servers  are attached to your requests. Use of smaller cookies when  possible, and delete these  cookies when you no longer need  them. Try to save some state on the  server so you can reduce the  number of client-side cookies. Also consider moving to HTTP/2  to get benefits of header  compression. Let's talk a little more about  compression. HTTP compression, also known as  content and coding, is simply  compressing the data that is  shuttled between the client and  the server. This allows us to better utilize  the bandwidth. The algorithms that URLSession  supports and recommends are Gzip  and Brotli. Gzip is widely supported and is  relatively fast. Brotli support was introduced  last year in iOS 11 and macOS  High Sierra. Brotli is optimized for  structured text and HTML. And it has the best compression  ratio on short data. Please enable compression on  your servers if you haven't done  so already. Let's move on to our next topic  for the day: increasing  responsiveness. Coming back to our restaurant  example.

> 它可以快速增加您的请求大小。请明智地使用域和路径属性，以确保服务器所需的Cookie附加到您的请求中。如果可能的话，使用较小的cookies，并且在不再需要这些cookie时删除这些cookie。尝试在服务器上保存一些状态，这样可以减少客户端cookies的数量。还要考虑移动到HTTP／2，以获得页眉压缩的好处。让我们再谈一点关于压缩的问题。HTTP压缩，也称为内容和编码，就是简单地压缩在客户机和服务器之间穿梭的数据。这使我们能够更好地利用带宽。URLSIST支持和推荐的算法是GZIP和BROTLI。GZIP被广泛支持并且相对较快。BROTLI支持去年在iOS 11和Mac OS高Sierra推出。BROTLI对结构化文本和HTML进行了优化。它对短数据具有最佳压缩比。如果您还没有这样做，请在您的服务器上启用压缩。让我们进入下一个话题：提高反应能力。回到我们餐厅的例子。

 Here you are here in San Jose  for WWDC, and you decide to meet  up with some old friends. You and your friends are sitting  at the restaurant table. Your drinks are here, but you  would like some more time to  catch up with your friends  before the food comes out. You can simply tell the waiter,  "Can you please bring out our  food after some time?  We are in no rush."  The same concept can be applied  to responsiveness where you mark  your tasks with priority  depending on the other tasks  that you're doing. Let's see how your apps can  benefit from this. You might be familiar with these  five QoS classes associated with  dispatch queues and NSOperation  objects. Data [inaudible] the CPU  scheduling policy. URLSession is QoS-aware which  means it will capture the QoS  off the queue on which you call  task.resume.

> 这里是WWDC的圣若泽，你决定和一些老朋友见面。你和你的朋友正坐在餐厅的桌子上。你的饮料在这里，但你需要更多的时间赶上你的朋友在食物出来之前。你可以简单地告诉服务员：“你能在一段时间后把我们的食物拿出来吗？”“我们不着急。”同样的概念也可以用于响应性，根据您正在执行的其他任务，将任务标记为优先级。让我们看看你的应用程序如何从中受益。您可能熟悉与调度队列和NS操作对象相关的这五个QoS类。数据[不可听见] CPU调度策略。URLSIST是QoS感知的，这意味着它将捕获您调用task.Read的队列中的QoS。

 And all the messages that it  sends to your delegates will  respect this QoS. Let's take an example. If your app wants to fetch some  data which is not time critical,  consider resuming that task on a  queue which has background QoS  to make sure this task does not  contend for CPU with other  higher priority work that your  app might be doing. Network service type is the  property on the URLSession  configuration object that allows  you to classify your network  traffic that helps the system  prioritize the data leaving the  device. This year, we have a new network  service type, the  responsiveData. ResponsiveData is slightly  higher than the default type but  should be used judiciously. An example where you might want  to use responsiveData is if you  have a shopping app and you are  on the checkout page. You might want to mark your  payment request with the  responsiveData to make sure you  get a good response from the  server. Traffic marked with the network  service type property will  maintain this tag across all the  hops when on a Cisco Fast Lane  network. For more information on this  API, please view the WWDC  session from the year 2016. Last year, we introduced the  URLSession Adaptable  Connectivity API  waitsForConnectivity. waitsForConnectivity will simply  wait instead of failing the load  when your task does not have  connectivity. In the past, you've been using  STNeworkReachability to do a  preflight check before you send  out your request.

> 它发送给你的代表的所有信息都会尊重这个QoS。让我们举个例子。如果您的应用程序想要获取一些时间不紧要的数据，考虑在具有后台QoS的队列上恢复该任务，以确保该任务不与应用程序可能正在执行的其他更高优先级的工作争夺CPU。网络服务类型是URLSession配置对象上的属性，它允许您对网络流量进行分类，以帮助系统区分离开设备的数据的优先级。今年，我们有了一个新的网络服务类型，即EdvaveDATA。RealveDATA略高于默认类型，但应该谨慎使用。如果您有购物应用程序，并且您在签出页面，您可能需要使用RealveDATA。您可能想用ErraveDATA标记您的付款请求，以确保您从服务器获得良好的响应。在Cisco Fast Lane网络上，用网络服务类型属性标记的流量将跨所有跳保持此标记。有关此API的更多信息，请查看2016年度WWDC会话。去年，我们引入了URLSIST可适应性连接API WaITsFrink。WaistsFrutoSnices将简单地等待，而不是在任务没有连接时失败的负载。过去，在发送请求之前，你一直在使用STNEWORKORKIONTY进行飞行前检查。

 But as Stuart pointed out a few  slides ago, there is a race  condition where the system might  tell you that you have  connectivity to a server but by  the time you create and send  your request, you've lost your  chance and you're no longer  connected to the server. We recommend using  waitsForConnectivity which will  simply send out your request as  soon as a connection to the  server is available. Optionally, you can implement  the taskIsWaitigForConnectivity  delegate method which gets  called when your task does not  have connectivity. This can be helpful to present  the user with a different flow  or an offline UI for better user  experience. For more information on this  API, please view the WWDC  session from last year where  this API was introduced. Now let's move on to our last  topic for the day: making better  use of system resources. Coming back to our restaurant  example. You like the food at this place  so much that you decide to come  here for dinner the next day. The restaurant has a delivery  service where you can place your  order today and they will  deliver the food to your house  the next day. This not only saves you the time  and effort to go and pick up  your food but it also helps the  restaurant prioritize their work  based on your deadline. Let's see how your apps can make  better use of system resources  to be more efficient.

> 但是正如Stuart在几张幻灯片之前指出的，存在一种竞争条件，在这种竞争条件下，系统可能会告诉您已经连接到服务器，但是当您创建并发送请求时，您已经失去了机会，并且不再连接到服务器。我们建议使用waitsForConnecti.，只要有到服务器的连接就发送请求。可选地，您可以实现taskIsWaitigForConnectivity委托方法，当任务没有连接性时调用该方法。这有助于向用户呈现不同的流程或离线UI以获得更好的用户体验。有关此API的更多信息，请查看去年从该API引入WWDC会话的情况。现在让我们继续我们今天的最后一个话题：更好地利用系统资源。回到我们餐厅的例子。你很喜欢这个地方的食物，所以你决定第二天来这里吃晚饭。这家餐厅有送餐服务，你今天可以订餐，第二天他们就会把食物送到你家。这不仅节省了你去拿食物的时间和精力，而且帮助餐厅根据你的截止日期来安排他们工作的优先顺序。让我们看看你的应用程序如何更好地利用系统资源来提高效率。

 Background sessions have upload  and download tasks. These tasks use system  intelligence to decide when to  start and when to stop a  download based on various  factors like battery, CPU,  Wi-Fi, etcetera. If your app wants to fetch a  large file, consider using  background sessions. These tasks run out of process  which means your download will  continue even when your app is  in a suspended state. For more information on  background sessions, please view  the WWDC session from the year  2014. Caching is a great way of  reducing latency but it's  important to note that caching  might result in disk IO. In the real world, we've seen  some apps write several  gigabytes of data to disk each  day which can cause severe flash  storage degradation. Please don't cache unique  content. Let's take an example. Let's suppose you have an app, a  dating app, and you are  responsible for the networking  code of the app. This app loads user profiles  with high-resolution images. It might be wasteful to cache  these high-resolution images  because the user might swipe  left, move on to the next  profile, which means that the  images that you just cached are  probably not going to be  requested again. Please consider making  client-side changes by adopting  the willChacheResponse delegate  method to decide what resources  should be cached. If you own the servers, please  consider using cache control  headers to decide what resources  should be cacheable. Let's quickly go over some of  the key points that we discussed  today.

> 后台会话有上载和下载任务。这些任务使用系统智能根据各种因素，如电池、CPU、Wi-Fi等，决定何时开始和何时停止下载。如果你的应用程序想获取一个大文件，考虑使用后台会话。这些任务已经完成，这意味着即使应用程序处于挂起状态，您的下载也会继续。有关背景会话的更多信息，请查看2014年度WWDC会议。缓存是一种减少延迟的好方法，但是注意缓存可能会导致磁盘IO。在现实世界中，我们看到一些应用程序每天向磁盘写入几千兆字节的数据，这会导致严重的闪存退化。请不要缓存唯一的内容。让我们举个例子。假设你有一个应用程序，一个约会应用程序，你负责应用程序的网络代码。这个应用程序加载高分辨率图像的用户配置文件。缓存这些高分辨率图像可能是浪费的，因为用户可能会向左滑动，然后转到下一个配置文件，这意味着刚刚缓存的图像可能不会被再次请求。请考虑通过采用willChacheResponse委托方法来进行客户端更改，以决定应该缓存哪些资源。如果您拥有服务器，请考虑使用缓存控制头来决定哪些资源应该是可缓存的。让我们很快复习一下我们今天讨论的一些要点。

 Number one, order all your food  at the same time when you go to  a restaurant. I'm just kidding. Move to HTTP/2 today to get wins  like header compression,  connection coalescing and no  head-of-line blocking. Use fewer URLSession objects to  reduce latency by reusing  connections. This also reduces the memory  footprint so it's better use of  system resources. Reduce the request size to  maximize throughput. Pay attention to QoS to increase  the responsiveness of your apps. And finally use background  sessions when you can to make  better use of system resources. For more information on this  session, please visit this  website. Now we'll have a short break. And after the break, we'll  introduce you to network  framework, a modern alternative  to Sockets. I would love to see you all at  the networking labs which are  going to be held today and  tomorrow.

> 第一，在你去餐馆的时候把你所有的食物都订好。我只是开玩笑而已。现在移到HTTP\/2，以获得如头压缩、连接合并和无头线阻塞之类的胜利。通过重用连接，使用较少的URLSISTION对象减少延迟。这也减少了内存占用，从而更好地使用系统资源。减少请求大小以最大化吞吐量。注意QOS以提高应用程序的响应性。最后使用后台会话来更好地利用系统资源。欲了解更多关于本次会议的信息，请访问本网站。现在我们休息一会儿。在休息之后，我们将向您介绍网络框架，它是套接字的一种现代替代方案。我很乐意在今天和明天举行的网络实验室见到大家。

 Thank you all for being here. And I hope everyone has a great  rest of the conference.

> 谢谢大家的光临。我希望每个人都有一个伟大的休息会议。

