  Well, good afternoon and  welcome to a tour of  UICollectionView. My name is Steve Breen-- I'll  set this over here-- and I'm a  frameworks engineer on the UIKit  team. And I'm joined on stage today  with my colleague, Mohammed  Jisrawi, also on the UIKit team. So today we're going to do  something a little bit  different. We're going to build an app from  some specs we receive from our  designer, Breanka [phonetic],  and this is going to leverage  many of the capabilities of  UICollectionView. Now, while we work through all  the tasks required to build our  app, we're going to touch on a  wide range of topics regarding  UICollectionView including  layouts, updates, and  animations. So we've got a ton of ground to  cover, so let's jump right in.

好的，下午好，欢迎参观UICLoCutVIEW。我的名字是Steve Breen——我将把它设置在这里——我是UIKit团队的框架工程师。今天我和我的同事Mohammed Jisrawi一起加入了UIKit团队。所以今天我们要做一些不同的事情。我们将从我们的设计者Breanka[语音]收到的一些规范构建一个应用程序，这将利用UICollectionView的许多功能。现在，在我们完成构建应用程序所需的所有任务时，我们将涉及与UICollectionView有关的广泛主题，包括布局、更新和动画。所以我们有大量的地面覆盖，所以让我们跳进去。

 All right, so here's the first  spec we got from our designer. It looks like a friends feed,  imagine that. A great little columnar layout. It looks pretty straightforward,  okay. Okay, this looks great. So here we've got this really  fancy looking mosaic layout,  which is the contents of our  friends feed. Okay, so Mohammed, since you're  going to be writing all the code  for us and walking us through  how to use these features, what  are your thoughts on these  designs?   Well, you know, I'm seeing  these for the first time, but  they seem like great candidates  for collection view. I think we can have a lot of fun  with this one, especially.  Yeah, this one looks great. All right. So before we dive into code, and  Mohammed starts walking us  through this, we need to cover  three core concepts we need to  understand about CollectionView  before we dive right into that  code. So let's do these now, and we're  going to talk about the layout,  data source, and the delegate. Okay. So, first of all, let's  chat a little bit about the  layout.

好的，这是我们从设计师那里得到的第一份说明书。它看起来像一个朋友饲料，想象一下。一个非常小的柱状布局。看起来很简单，好吧。好的，看起来不错。所以我们这里有一个非常漂亮的马赛克布局，这是我们的朋友饲料的内容。好的，穆罕默德，既然你要为我们写所有的代码，指导我们如何使用这些特性，你对这些设计有什么想法？嗯，你知道，我第一次看到这些，但是它们看起来像是收藏收藏品的最佳人选。我想我们可以有很多乐趣，尤其是这个。是的，这个看起来很棒。好的。因此，在我们深入研究代码之前，穆罕默德开始带领我们了解这些代码，我们需要先了解一下CollectionView的三个核心概念。现在让我们来讨论一下，我们将讨论布局、数据源和委托。可以。所以，首先，让我们聊一下布局。

 So if you open up the definition  for UICollectionView for the  very first time, and you're  familiar with UITableView, you  notice right away that there's a  lot of familiarity in the API. You got a delegate and a data  source. All these things look pretty  familiar, but the layout  concept, that's pretty unique  and distinct to  UICollectionView. You can really think of it as  UICollectionView's super power. It allows CollectionView to  abstract away the visual  arrangement from your content  separate from the content  itself. Layout is all about the where  content is displayed. Now, each individual item is  specified by the  UICollectionView layout  attributes, for attributes like  such as bound, center, and  frame, things like that. You can think of it as a set of  properties you can use to define  these items that are displayed. You can even customize these by  printing your own subclasses of  UICollectionView layout  attributes and include these in  your designs. Okay. So as the user is  scrolling through the content on  screen, the layout is considered  to be immutable. Now if you need to change this,  like for example you're going to  change the appearance of the  layout, you would use the  invalidation mechanism, which  Mohammed will walk us through in  a little bit. Okay. Now, one great thing about  layout being a separate  abstraction is we can transition  from one layout to another  layout and get a great animated  effect when you move between  layouts, and layout A doesn't  need to know anything about  layout B. They just declare what the  layout is going to be, and the  transitions occur. Okay. So CollectionViewLayout is  an abstract class, and as such,  it's not meant to be used  directly, but rather subclasses  of CollectionViewLayout are  meant to be used. Fortunately, we provide one. UICollectionViewFlowLayout, and  you're probably familiar with  this class if you used  CollectionView before. Now there's a lot of  customization points on  CollectionViewLayout including  some properties that we'll talk  about in a little bit, but you  can also customize it using a  delegate, and we'll talk about  the CollectionViewDelegate in a  moment, but  CollectionViewFlowLayout will  specify additional things that  extend that  CollectionViewDelegate. Okay, so what's Flow all about?  Well it's a line-based layout  system, and because of this, it  can cover a wide range of  different designs that you might  receive. All right, so what does line  base mean?  Well let's go through this. So the best way to explain what  a line based system is like is  to give an example, so let's do  that.

因此，如果您第一次打开UICollectionView的定义，并且熟悉UITableView，那么您马上就会注意到API中有很多熟悉之处。您有一个委托和一个数据源。所有这些东西看起来都很熟悉，但布局概念，这是非常独特和独特的UICORDIN视图。你真的可以把它看作是UICLouthVIEW的超级力量。它允许CopyVIEW从内容中抽象出与内容本身分离的视觉安排。布局是关于显示内容的地方。现在，每个单独的项都由UICollectionView布局属性指定，用于诸如绑定、中心和框架之类的属性。可以将其视为可以用来定义显示的这些项的一组属性。您甚至可以通过打印自己的UICollectionView布局属性的子类来定制这些属性，并将这些属性包括在设计中。可以。因此，当用户在屏幕上滚动内容时，布局被认为是不可变的。现在，如果你需要改变这个，比如你要改变布局的外观，你会使用失效机制，穆罕默德会带我们过一会儿。可以。现在，布局作为一个独立的抽象，有一点很重要，那就是我们可以从一个布局转换到另一个布局，当你在布局之间移动时，可以获得很好的动画效果，布局A不需要知道布局B。转变发生。可以。因此，CollectionViewLayout是一个抽象类，因此，它不打算直接使用，而是应该使用CollectionViewLayout的子类。幸运的是，我们提供了一个。UICLoopDeVIEW FuffFayStand，如果您以前使用CopyVIEW，您可能熟悉这个类。现在CollectionViewLayout上有许多定制点，包括一些我们将稍后讨论的属性，但是您也可以使用委托对其进行定制，稍后我们将讨论CollectionViewDelegate，但是CollectionViewFlowLayout将指定附加的属性扩展集合视图委托的NEY对象。好的，那么流程到底是怎么回事？嗯，它是一个基于线的布局系统，正因为如此，它可以覆盖你可能收到的各种不同的设计。好吧，行基础是什么意思？让我们来看看这个。因此，解释基于线的系统的最佳方法是给出一个例子，让我们这样做。

 Okay. So here we see, we've got  a vertical scrolling collection  view, and we're going to mimic  what flow layout does when it  lays out this content. All right. So here's our first item, and we  start at the top leading edge,  and we start laying out our  items along a line. Now look at this line. This line is orthogonal to the  scroll axis. We're scrolling vertically, so  the line is horizontal. Okay, now notice here, we filled  up the available space for items  on that line, so now we're going  to drop to the next line and  continue laying out our content. And finally, we drop to that  last line, and bingo, we got all  our content. Now if I dropped some guides on  here to show highlight where  those lines are horizontal,  let's talk about some  definitions that we have for  ways to customize flow. First up is the notion of line  spacing. And as you see the arrows here,  the line spacing is going to be  the space between these  horizontal lines. Similarly, inter-item spacing is  the space between the items  along the layout line. And we have two properties on  flow layout that let you specify  the minimums for both of these. Okay. So let's cement our  intuition a little bit and  rotate the whole thing, pi over  2, and let's start over at the  top leading edge. Now, this one is scrolling  horizontally, right, so we're  going to have a vertical layout  line, and when we get to the  bottom of this area, we filled  out that line, back up to the  top. Okay. This pattern is pretty  familiar now, right. There we go. There's all our content. Now we have our vertical layout  lines. So now in this orientation, our  line spacing is this. And our inter-item spacing is  this. It's key to remember when you're  working with flow layout. Okay, so that's layout.

可以。这里我们看到，我们有一个垂直滚动集合视图，我们将模拟流布局在布局这些内容时所做的工作。好的。这是我们的第一个项目，我们从顶部前缘开始，我们开始沿着直线布置我们的项目。现在看看这条线。这条直线与滚动轴正交。我们垂直滚动，所以线是水平的。好的，现在注意这里，我们填充了该行的可用空间，因此现在我们将转到下一行，并继续布局我们的内容。最后，我们下降到最后一行，宾果，我们得到了我们所有的内容。现在，如果为了突出显示这些线在水平方向上的位置，我在这里放置了一些指南，那么让我们来讨论一些自定义流程的定义。首先是线间距的概念。正如你在这里看到的箭头一样，线间距将是这些水平线之间的空间。类似地，项目间间距是沿着布局线的项目之间的空间。我们在流布局上有两个属性，它们可以为这两个属性指定最小值。可以。让我们巩固一下直觉，把整个过程旋转，π>2，从最前沿开始。现在，这个是水平滚动的，对，所以我们要画一条垂直的布局线，当我们到达这个区域的底部时，我们填好这条线，回到顶部。可以。这种模式现在已经很熟悉了，对吧？我们走了。这就是我们的全部内容。现在我们有垂直的布局线。所以现在在这个方向，我们的行距就是这个。我们的项目间间隔就是这个。这是记住当你使用流布局时的关键。好的，那就是布局。

 Let's talk a little bit about  the data source, and if you work  with TableView, this should look  very familiar. It's a very similar pattern. They share very similar APIs. Okay, so if the layout is all  about the where content goes,  the data source is the what. The content itself. Three core methods to think  about here. The first one is optional,  number of sections in  CollectionView, and this one if  you don't provide it, we'll just  assume you mean one. Similarly, we have number of  items in section, and this is  going to tell you the number of  items in each individual  section, because they can all  have different numbers of items. And then the last one, sell for  item index path is where you  provide the actually content  you're going to display to your  users. Okay. So that's the data source. Okay, the final of our three  topics we're going to talk about  before we dive into code with  Mohammed is the Delegate. Okay. So use of the Delegate is  optional. Now, CollectionView is a  subclass of UIScrollView. So we use the same Delegate  that's provided by the  ScrollView superclass, but we  extend it. So if you need to modify  scrolling behavior, you can do  it also against this same  Delegate and also work with some  of the UICollectionViewDelegate  methods that provide things like  fine-grained control over  highlighting and selection as  the user interacts with your  content.

让我们来谈谈数据源，如果您使用TabLVIEW，这应该看起来非常熟悉。这是一个非常相似的模式。它们有非常相似的API。好的，如果布局是关于内容的地方，数据源就是什么。内容本身。这里思考的三种核心方法。第一个是可选的，CollectionView中的节数，这个如果不提供，我们将假定您指的是一个。类似地，我们在章节中有许多条目，这将告诉您每个章节中的条目数量，因为它们都可以有不同数量的条目。然后最后一个，selectforitemindexpath就是您向用户提供要显示的实际内容的地方。可以。这就是数据来源。好的，在我们与穆罕默德深入研究代码之前，我们要讨论的三个主题的最后一个是代表。可以。因此，使用委托是可选的。现在，CopyVIEW是UISCRelVIEW的子类。因此，我们使用由ScVIEW视图超类提供的相同委托，但是我们扩展了它。因此，如果需要修改滚动行为，也可以针对相同的委托进行修改，还可以使用UICollectionViewDelegate的一些方法，这些方法可以在用户与内容交互时提供对突出显示和选择的细粒度控制。

 And we also got an API that  let's you know, hey, something  came on screen. WillDisplayItem and  DidEndDisplayingItem. Okay. So those are the three  core concepts we really need to  talk about before we dive into  code to get started with  UICollectionView. So let's switch over to the dev  box with Mohammed and have him  show us how it works. Mohammed.  All right, so the first of  our two screens that column  layout is a great use case for  using CollectionViewFlowLayout. We can probably accomplish  everything we need there, and it  would be a great way to get us  started using UICollectionView. So now while we could accomplish  the entire goal of our design  with a flow layout, I'm actually  going to subclass  CollectionViewFlowLayout because  we're going to do a little bit  of extra customization. So I'm going to start out by  creating an instance of my  ColumnFlowLayout class, which  I've already prepared. I'm going to use that instance  to create my CollectionView. I'm going to take that  CollectionView, and I'm going to  set some view properties, like  auto resizing mask, background  color, and since it's the  ScrollView, I can set some of  it's ScrollView properties as  well. This is all just to get it to  look and feel the way I want it  to look in our app. After adding the CollectionView  to my view hierarchy, I'm going  to register my PersonCell class  using its unique identifier with  CollectionView so we can get our  cell design to app. And then I'm going to set the  view controller as the  CollectionView's data source so  we can give it some information  about how many cells it's going  to display and what sort of data  it's going to display in it's  cells. And then I'm going to set it as  it's delegate as well, so we can  handle cell selection.

我们还得到了一个API，让你知道，嘿，一些东西出现在屏幕上。WiDeStudio项目和DeDouDeDebug项目。可以。因此，在开始使用UICollectionView之前，这些是我们真正需要讨论的三个核心概念。所以让我们切换到穆罕默德的DeV框，让他告诉我们它是如何工作的。穆罕默德。好的，所以我们的两个屏幕中的第一个列布局是使用CopeDeVIEW流布局的一个很好的用例。我们可以完成我们所需要的一切，这将是我们开始使用UICLoopEnVIEW的一个很好的方法。因此，现在我们可以通过流布局来完成设计的全部目标，实际上我将对CollectionViewFlowLayout进行子类，因为我们将做一些额外的定制。因此，我将首先创建一个我已经准备好的CyrnFuleDealFrand类的实例。我将使用那个实例来创建我的CopyVIEW视图。我将采用CollectionView，我将设置一些视图属性，如自动调整大小的掩码、背景颜色，并且由于它是ScrollView，因此我还可以设置它的一些ScrollView属性。这一切只是为了让它看起来和感觉我想让它看起来在我们的应用程序。在将CollectionView添加到视图层次结构之后，我将使用PersonCell类的唯一标识符在CollectionView中注册PersonCell类，以便我们能够将单元设计应用到应用程序中。然后，我将把视图控制器设置为CollectionView的数据源，这样我们可以给它一些信息，关于它将显示多少个单元格，以及它将在其单元格中显示什么类型的数据。然后我也将它设置为它的委托，所以我们可以处理单元选择。

 So now that we've gotten set up,  we need to actually conform to  these two protocols. So let's start out by conforming  to the data source, and we have  two required methods we need to  implement here. The first of these is number of  items in section where we can  just return the number of people  or the number of items in our  people array to get our data  model objects displayed. The second method we'll need to  implement is  CellForItemAtIndexPath where  we'll dequeue a cell from the  CollectionView using our unique  identifier, pass a person and  object that we get out of our  people array, to the cell to  actually display our data, and  then return the cell. And to wrap things up here,  we'll just need to implement one  optional method from the  Delegate protocol, so we can  handle selection. So I'm just going to add  DidSelectItemAtIndexPath where  we'll just instantiate our  FeedView controller, which is  going to be our second screen if  we don't already have an  instance, and then we're going  to pass it a person object so we  know whose images to display,  and then we'll push it onto our  navigation controller. Okay. So let's build this and  switch to the simulator to see. All right. [ Applause and Cheering ]  Okay. So we have our  CollectionView on screen here,  and we have some cells. You can see them, though they're  kind of squished. They're not the right size, so  we're going to have to do some  of that customization we thought  we might need to do. So let's go back to Xcode, and  let's pop open our column of  class here, our ColumnFlowLayout  class that we've put together,  and let's take a look at what we  need to do here. So I already have a stub  override of the layouts prepare  method. Now,  UICollectionViewLayoutsPrepare  method is called whenever the  layout is invalidated, and in  the case of  UICollectionFlowLayout, our  layout is invalidated whenever  the CollectionView's bounds of  size changes. So if our app rotates on a phone  or if our app is resized on an  iPad. So this is a great place to do  any customization that takes the  size of the CollectionView into  account. In our case, we want our cells  to be some function of the  CollectionView's width. And we can let the  CollectionView know how big we  want our items to be by saying  it's item sized properties.

现在我们已经建立起来了，我们需要符合这两个协议。因此，让我们从符合数据源开始，我们有两个需要的方法，我们需要在这里实现。第一个是部分中的条目数量，我们可以只返回人员数组中的人员数量或条目数量，以显示数据模型对象。我们需要实现的第二种方法是CellForItemAtIndexPath，在该方法中，我们将使用惟一标识符从CollectionView中删除单元格，将从人数组中得到的人和对象传递给单元格，以便实际显示数据，然后返回单元格。最后，我们只需要实现Delegate协议中的一个可选方法，这样我们就可以处理选择。所以我要添加.SelectItemAtIndexPath，在这里我们将实例化FeedView控制器，如果还没有实例，它将是我们的第二个屏幕，然后我们将传递给它一个person对象，这样我们就知道要显示谁的图像，然后我们将推动它给我们的导航控制器。可以。因此，让我们建立这个，并切换到模拟器看看。好的。[掌声和欢呼]好的。所以我们在屏幕上有我们的CollectionView，我们有一些细胞。你可以看到它们，虽然它们有点被压扁了。它们不是合适的尺寸，所以我们不得不做一些我们认为可能需要做的定制。让我们回到Xcode，让我们在这里弹出打开我们的类列，我们已经组合在一起的ColumnFlowLayout类，并且让我们看看我们需要在这里做什么。所以我已经有了一个存根覆盖布局准备方法。现在，每当布局无效时就调用UICollectionViewLayoutsPrepare方法，在UICollectionFlowLayout的情况下，每当CollectionView的大小范围改变时，我们的布局就无效。所以，如果我们的应用程序在手机上旋转，或者我们的应用程序在iPad上调整大小。因此，这是一个伟大的地方做任何定制的大小考虑到CopyVIEW。在我们的例子中，我们希望我们的单元格是集合视图宽度的函数。我们可以让集合视图知道我们希望我们的物品有多大，说它是物品大小的属性。

 So I'm going to go ahead and do  that here. So I'm just going to set my  CollectionView's item size to a  CG size with a width that is the  width of the CollectionView's  bounds, inset by its layout  margins, and then we're going to  give it a height of 70 points  just to match our design. And since we're already here,  I'm going to do a couple of  other little things here just to  get things to look nice. I'm going to apply a section  inset with some padding at the  top that matches our inter-item  spacing, and I'm going to set  the layout section inset  reference property to from safe  area so everything is neatly  tucked within the CollectionView  safe area insets. Okay. So let's go back to the  simulator one more time and see  what our properly constructed  layout looks like. All right. That looks great. That looks just like our spec. I  think our designer is going to  be really happy. And if we rotate to landscape,  we see that our cell is a great  size, and so we know that our  invalidation code is getting  called again in prepare. Now while this is okay, you  might be thinking, it's not the  best that we can do here. It doesn't look as great as it  can. We might want to do something  more interesting here like  display multiple columns since  we have the space available to  us. Now flow layout makes it really  easy to do this. If you remember during Steve's  explanation of how flow layout  performs it's layout earlier,  flow layout will automatically  try to fit in as many items as  it can within a line before it  wraps to the next one. So using that, we can kind of  figure out that layout-- that we  can get multiple columns if we  change our item size. So if we head back to Xcode, to  our layout here, and if we just  change how we're calculating our  item size here. So I'm just going to remove this  fit here, and I'm going to  replace it with something that  does a little bit of extra math. So I'm just starting out with  the same available width that I  had before. This is the bounds inset by the  margins, and some arbitrary  definition of what a minimum  column width is, it's 300  points. And then taking both of those  values and using them to  calculate a maximum number of  column that I think I can fit  within the available space, and  I'm taking that and dividing the  available width by it to  calculate an optimal cell width,  which might be more than our 300  points. I'm then passing that to the CT  size that I'm using as my item  size. Okay. So let's go back to our  simulator again and see what our  updated layout looks like. Okay. So everything is the same  here. We didn't break it. It's a good start, and if we go  to portrait, there are our  multiple columns side by side,  just what we want. What do you think, Steve?   That looks great. We got a great adaptable  columnar base layout. Not a lot of work.  No.

所以我要在这里做这件事。因此，我只要把CollectionView的项大小设置为CG大小，其宽度是CollectionView边界的宽度，通过布局边距插入，然后我们将给它一个70点的高度，以匹配我们的设计。既然我们已经在这里了，我会做一些其他的小事情，让事情看起来不错。我将应用顶部带有一些填充的区段插入，以匹配我们的项间间隔，并且我将将布局区段插入引用属性设置为从安全区域插入，因此所有内容都整齐地隐藏在CollectionView安全区域插入中。可以。让我们再回到模拟器中，看看我们的布局如何。好的。看起来不错。这看起来就像我们的规格。我想我们的设计师会很开心。如果我们旋转到横向，就会看到我们的单元格很大，所以我们知道我们的失效代码正在准备中再次被调用。现在，这是好的，你可能会想，这不是最好的，我们可以在这里做。它看起来没有那么大。我们可能想做一些更有趣的事情，比如显示多栏，因为我们有可用的空间。现在，流布局使得它很容易做到这一点。如果你还记得，在史蒂夫之前对流布局如何进行布局的解释中，流布局会自动尝试在一行内尽可能多地插入项目，然后再包装到下一行。因此，我们可以找到布局——如果我们改变了项目的大小，我们可以得到多个栏目。所以，如果我们回到XCODEL，我们的布局，如果我们只是改变我们如何计算我们的项目大小在这里。所以我要在这里删除这个，我要用一些额外的数学来代替它。所以我刚开始时的宽度和以前一样。这是由边距插入的边界，以及对最小列宽度的任意定义，它是300点。然后取这两个值，并用它们来计算一个最大列数，我认为我可以在可用空间中放入该列数，然后用该值除以可用宽度，计算一个最佳单元宽度，它可能超过我们的300点。然后我把它传递给我使用的CT大小作为我的项目大小。可以。让我们再回到我们的模拟器，看看我们更新的布局是什么样子。可以。所以这里的一切都是一样的。我们没有打破它。这是一个很好的开始，如果我们去画像，我们有多个并排的栏目，正是我们想要的。你觉得怎么样，史提夫？看起来不错。我们得到了一个很好的适应性柱型布局。工作不多。不。

  What's next in our design?   Well, now that we've eased  ourselves in with our friends  list, it's time to start  thinking about that fancy mosaic  layout for [inaudible].  Oh, yeah. That's going to be great.  Yeah.  Let's switch back over  slides, and let's chat a little  bit about that. Okay. So let's take a look at  this layout or design here and  see what we can do. So our first inclination, I  don't know about yours, but mine  would be can I use Flow.

我们设计的下一步是什么？嗯，现在我们已经习惯了朋友名单，是时候开始考虑[听不见]那种花哨的马赛克布局了。哦，是的。那会很棒的。是啊。让我们回到幻灯片上，让我们聊一聊。可以。让我们来看看这里的布局和设计，看看我们能做些什么。所以，我们的第一个倾向，我不知道你的，但我可以用流。

 I've got it. It's ready to go. Let's try to use it. So let's zero in on this design  a little bit and see if Flow is  going to make sense for us. And this particular region where  these three photos are, I'm  going to zoom in on that real  quick. All right. So now in this instance we have  a very large photo on the left  and then a vertical stack on the  right. So in the flow universe, since  it's line based, we're going to  lay out that large left item,  move over to the next item where  it's got room, try to lay out  another item, and then jump to  the next line. But we're not done. We've got that vertical stack to  contend with. So this really is not going to  work for Flow because it turns  out it's not really a line-based  layout, this fancy layout of  ours. But going through this exercise  is useful, so, you know, let's  start with flow first.

我明白了。准备好了。让我们试着用它。所以，让我们在这个设计中加入一点点，看看流量是否对我们来说是有意义的。在这三张照片的特定区域，我将快速地放大。好的。现在，在这个例子中，左边有一张很大的照片，右边是一个垂直的堆栈。So in the flow universe, since  it's line based, we're going to  lay out that large left item,  move over to the next item where  it's got room, try to lay out  another item, and then jump to  the next line. 但我们没有完成。我们得到了垂直堆栈来抗衡。So this really is not going to  work for Flow because it turns  out it's not really a line-based  layout, this fancy layout of  ours. 但是，通过这个练习是有用的，所以，你知道，让我们先从流程开始。

 Okay. So in this instance, we're  going to create our own custom  layout. Oh, no, we're scared, right. Nope, it's not complicated. We've got four basic methods to  deal with here, and I'm going to  bring up one additional method  that gets an honorable mention. Okay. So four methods. Here we go. Our first method I want to talk  about is the CollectionView  Content Size. Now, recall before we mentioned  CollectionView is a subclass of  UIScrollView, and one of the  features of UIScrollView is that  you have a visible region with a  large content area, and you get  that great iOS experience of  moving your content around  inside that, and so  CollectionView needs to know how  to tell the ScrollView, hey,  here's how big my content is. Okay. So how do we get this  size?  Well, if you imagine a rectangle  that encompassed all the content  that the layout is going to  define for your CollectionView,  we want the size of that. Okay, so that's CollectionView  Content Size. Next up we have two methods that  are in the business of providing  layout attributes. The first one is  LayoutAttributesForElements (in  Rect). Now this is called periodically  by CollectionView when it needs  to know what is needed to  display on screen as the user  scrolls through your content or  displays for the first time. So this query is by a geometric  region. Okay. It's companion API,  LayoutAttributesForItem  AtIndexPath, as you can imagine,  it's just looking for a single  item. Give me the attributes for that. Okay, so we're going to see more  when Mohammed walks us through  this, but for these two APIs,  it's important to note that  performance matters.

可以。因此，在这个例子中，我们将创建我们自己的自定义布局。哦，不，我们很害怕，对吧？不，这并不复杂。我们有四种基本的方法要处理，我将提出一个值得一提的附加方法。可以。四种方法。我们走吧。我们想讨论的第一个方法是CopeDeVIEW内容大小。现在，回想我们之前提到的CollectionView是UIScrollView的子类，并且UIScrollView的一个特性是，您有一个具有大内容区域的可见区域，并且您获得了在iOS中移动内容的良好体验，因此CollectionView需要知道如何告诉滚动视图，嘿，这是我的内容有多大。可以。那么我们怎样才能得到这个尺寸呢？嗯，如果你设想一个矩形，它包含布局将为CollectionView定义的所有内容，我们想要它的大小。好了，这就是CopyVIEW内容的大小。下一步，我们有两种方法来提供布局属性。第一个是LayOutAtestFor元素（ReCt）。现在，当用户第一次滚动您的内容或显示时，需要知道需要在屏幕上显示什么时，CollectionView会定期调用它。所以这个查询是一个几何区域。可以。它的同伴API，LayoutAttributesForItem AtIndexPath，你可以想象，它只是寻找一个单一的项目。给我这个属性。好的，那么当Mohammed带领我们完成这个步骤时，我们将看到更多，但是对于这两个API，重要的是要注意性能很重要。

 Okay, so the fourth of our four  core custom layout subclass  items is going to be the Prepare  method. Now Mohammed has already chatted  about this a little bit. This is called every time the  layout is invalidated. So this is a great time to  compute anything, such as your  layout attributes you might want  to cache and also your content  size, which is going to be asked  for pretty soon afterwards. Okay. So our honorable mention  APIs, so let's talk about this  one. This is a Should Invalidate  Layout For Bounds Change. So this is called every time the  bounds in the CollectionView  changes. Okay, so again, it's a  CollectionView is a UIScrollView  subclass. So what do we mean by a bounds  change?  Well, when a ScrollView bounds  change, the origin can change  during a scrolling, and also the  size can change when the  application size changes or the  CollectionView size changes. So this is going to be called  during scrolling. Hence the oh yeah emoji. This is called very often. So making the right decision  here is important. Okay, so the default  implementation in  UICollectionViewLayout returns  false. So if you need this to do  something different, here's your  chance. And as a way of an example,  UICollectionViewLayout will  return false if the origin  changes. Okay, so if the user is just  scrolling through your content,  we won't invalidate. Let it by default.

好的，所以我们的四个核心自定义布局子类项目中的第四个将是准备方法。现在穆罕默德已经聊了一会儿。每次布局无效时，这都被调用。所以现在正是计算任何东西的好时机，比如您可能想要缓存的布局属性以及内容大小，稍后很快就会要求这些属性。可以。因此，我们的荣誉提到API，所以让我们来谈谈这个。这是一个边界更改的无效布局。因此，每当CopyVIEW视图中的边界发生变化时，都会调用该函数。好的，再一次，它是一个集合视图是一个UISCLVIEW子类。那么，所谓的边界变化是什么意思呢？那么，当ScrollView边界改变时，原点可以在滚动期间改变，并且当应用程序大小改变或CollectionView大小改变时，大小也可以改变。所以这将在滚动过程中被调用。因此，哦，是的表情。这经常被调用。所以在这里做出正确的决定很重要。好的，所以UICLoDebug视图布局中的默认实现返回false。所以如果你需要做一些不同的事情，这是你的机会。作为示例的一种方式，如果原点更改，UICRealDebug视图布局将返回false。好的，如果用户只是滚动你的内容，我们就不会失效。默认情况下。

 But if the iPad rotates, the  phone rotates, and your app  changes to a different size,  it'll return true. Now a slight exception to this  is things like floating headers  and footers, right. We have to recompute those while  you're scrolling your content. That'll do a custom invalidation  to take care of those things. Okay. So enough theory. Let's switch back to our  development machine and have  Mohammed walk us through what  this is going to look like in  code building this fancy custom,  UICollectionViewLayout.  All right, let's dive right  in. So I've already put together  another layout subclass that  we're going to use for this  layout, and you might notice  that it's a subclass of  UICollectionViewLayout directly,  not a subclass of  CollectionViewLayout, and this  is for the reasons that Steve  explained to us earlier are  UICollectionViewLayout doesn't  really meet the needs of our  custom mosaic design. So the first thing I'm doing  here is I'm setting up a couple  of instance variables that I'm  going to use to hold onto some  key pieces of information that I  can refer to later.

但是如果iPad旋转，手机旋转，你的应用程序改变到不同的大小，它就会返回。现在有一点例外，比如浮动页眉和页脚，对吧。当你滚动你的内容时，我们必须重新计算。这样做会有一个习惯性的失效来处理这些事情。可以。足够的理论。让我们回到我们的开发机器上，让Mohammed带领我们了解一下构建这个奇妙定制——UICollectionViewLayout——的代码会是什么样子。好吧，我们潜水吧。因此，我已经组合了另一个布局子类，我们将使用这个布局，您可能注意到它是UICollectionViewLayout的一个子类，而不是CollectionViewLayout的子类，这是因为Steve早些时候向我们解释的原因是UICollecti。OnVIEW布局并不真正满足我们定制马赛克设计的需要。所以我在这里做的第一件事就是设置几个实例变量，我将用它们来保存一些关键的信息，这些信息我稍后可以参考。

 The first of these is a content  bound CG rect, which I'm going  to use to keep a representative  bounds of all the items within  my CollectionView. And the second is a cached  attributes array, which I'm  going to use to hold onto my  layout attributes so I can refer  to them quickly when performance  matters. So we're going to start out by  implementing our prepare method  again for this layout. Prepare is the ideal place to do  the bulk of our layout work  because it's getting called once  per invalidation. We can set up our layout here  and then avoid having to do any  heavy layout work or any heavy  layout math in the methods that  are called much more frequently. So we're doing a couple of  things here. First, we're resetting our  cached attributes and our  content bounds just to clear out  any stale information from  previous invalidations. Next, we're doing a few things  for every item in our  CollectionView. The first of these is actually  preparing the attributes, and  now I'm not going to go too  deeply into what that entails  for our specific layout because  this is going to be different  for you. This is where you are going to  calculate the sizes and  positions and transforms, etc.,  for your cells to match your  design needs. But there are a couple of key  things that we're going to do  here after we are done with the  attributes. The first is, we're going to  cache them.

第一个是内容绑定的CG rect，我将用它来保持CollectionView中所有项的代表性边界。第二个是缓存的属性数组，我将用它来保存布局属性，以便在性能重要时快速引用它们。因此，我们将开始对这个布局再次执行我们的准备方法。准备是完成我们大部分布局工作的理想场所，因为它每失效一次就被调用一次。我们可以在这里设置布局，然后避免在频繁调用的方法中执行任何繁重的布局工作或任何繁重的布局计算。所以我们在这里做两件事。首先，我们重新设置缓存的属性和内容界限，只是为了清除以前失效的任何陈旧信息。接下来，我们为我们CollectionView的每一个项目做一些事情。第一步实际上是准备属性，现在我不打算深入讨论这些属性对于我们的特定布局的影响，因为这对您来说是不同的。这就是你要计算的大小，位置和变换等，为您的单元格匹配您的设计要求。但是在完成属性之后，我们会有一些关键的事情要做。首先，我们将缓存它们。

 We're going to put them in our  cached attributes array so we  can grab them quickly later on. And the second is, we're going  to union their frame with our  content bounds rect so that our  content bounds are kept up to  date. So now that our prepare is up  and running, we need to  implement the remaining methods  in our layout that we need to  get everything working. So the first of these is  CollectionView Content Size  where if we had done our job  right in Prepare, we can just  return our Content Bounds as  size. Next is should invalidate layout  for bounds change. Now since our layout doesn't  have any elements that require  us to invalidate while we're  scrolling, so no floating  headers, no floating footers or  anything like that. We only really want to  invalidate when our  CollectionView's bounds of size  changes. So we'll just return true if our  new bounds of size is not equal  to our CollectionView's bounds  of size, our current bounds of  size. After that, we'll implement  LayoutAttributesForItem  AtIndexPath where, again, since  we've prepared all the  attributes in our Prepare  method, we can just grab the  specific attributes that  correspond to the  RequestAtIndexPath from our  array. And finally, we're going to  implement  LayoutAttributesForElements  InRect. Now this method is called  periodically by the  CollectionView with different  query rects, which may be bigger  than our CollectionView. Our CollectionView is just  asking for a set of attributes  that match a certain region. It's our job to return an array  that contains all the attributes  that correspond to all the items  that are going to appear within  that rect in our CollectionView.

我们将把它们放进缓存属性数组中，这样我们就可以很快地抓取它们。第二，我们要将它们的框架与我们的内容边界rect联合起来，以便我们的内容边界保持最新。因此，现在我们的准备工作已经准备就绪，我们需要在布局中实现其余的方法，以便使所有工作正常进行。因此，第一种是CollectionView Content Size，其中如果我们在Prepare中正确地完成了工作，就可以将内容边界返回为size。其次是要使版面布局发生变化。现在，由于我们的布局没有任何元素要求我们在滚动时无效，所以没有浮动标头、浮动页脚或类似的内容。我们只想在CollectionView的大小变化范围内无效。因此，如果新的大小边界不等于CollectionView的大小边界，即当前的大小边界，我们将返回true。之后，我们将实现LayoutAttributesForItem AtIndexPath，其中，由于我们在Prepare方法中已经准备了所有属性，因此我们只需要从数组中获取与RequestAtIndexPath相对应的特定属性。最后，我们将实现LayOutAtestToFrices元素。现在，CollectionView定期调用此方法，具有不同的查询rect，它可能比CollectionView大。我们的CopyVIEW只是要求一组与某一区域相匹配的属性。我们的任务是返回一个数组，该数组包含与将出现在CollectionView中的该rect中的所有项相对应的所有属性。

 So we can answer that question  here simply by filtering our  cached attributes array on the  frame of the attributes. So if our attributes have a  frame that intersects our query  rect, we can return them. Okay. So let's switch back to  the sim and see what our layout  looks like. So I'm going to select one of  these feeds, and there you go. We have our layout. Our images are nicely loaded in  this fancy mosaic configuration,  and if we rotate to landscape,  you can see that our cells have  resized so we've updated  everything correctly, we've  invalidated, which is great. So this looks like our spec, but  that scrolling performance isn't  great, is it?   No.  No, it's pretty bad, huh. So you might already have an  idea of what's going on here. Let's switch back to the code  and see what might be happening. So if we take a look at our  layout attributes or elements in  rect here, remember that this  method gets called frequently  during scrolling. So this function here, which is  filtering our entire array, you  might imagine can get really  expensive as the number of items  in our CollectionView increases. So the more photos we have in  our app, the slower our  scrolling performance is going  to be. So if you find yourself in a  situation like this, it helps to  step back and think about the  nature of your layout and think  about whether you can find any  optimization opportunities. So our layout kind of demands  that every cell apps next to or  below it's preceding cell. So this means that our  attributes are already sorted  within our cached attributes  array by their frame's minimum y  value.

因此，我们可以简单地通过在属性的框架中过滤缓存的属性数组来回答这个问题。因此，如果我们的属性有一个与查询RIST相交的框架，我们可以返回它们。可以。让我们切换到SIM，看看我们的布局是什么样子。所以我要选择其中一种饲料，然后你就去了。我们有自己的布局。我们的图像很好地装载在这个花哨的马赛克配置中，如果我们旋转到风景，你可以看到我们的细胞已经调整了大小，所以我们已经正确地更新了一切，我们已经失效了，这很好。这看起来像我们的规格，但滚动性能不是很好，不是吗？不，不，很糟糕，嗯。所以你可能已经知道这里发生了什么。让我们回到代码中，看看会发生什么。因此，如果我们在这里查看我们的布局属性或元素，请记住这个方法在滚动期间经常被调用。所以这个过滤整个数组的函数，你可以想象得到，随着CollectionView中项目数量的增加，会变得非常昂贵。所以在我们的应用程序中的照片越多，我们的滚动性能就越慢。因此，如果你发现自己处于这样的境地，退后一步，考虑一下你的布局的本质，考虑一下你是否能找到任何优化机会，这会对你有所帮助。所以我们的布局要求每个单元应用程序在它前面的单元旁边或下面。因此，这意味着我们的属性已经通过它们的帧的最小Y值在缓存的属性数组中排序。

 So we have a sorted array, so we  can speed up our search by doing  something like a binary search  as opposed to our linear filter  that we're doing now. So let's remove our slow  implementation here, and let's  replace it with something that  should be much faster. So I'm going to step through  this bit by bit, don't worry. So the first thing we're doing  here is we're calling into  binary search function that  we've already prepared, which  takes in a range of indices  within our array and our query  rect. If it finds a set of attributes  with a frame that sits within  our rect, it'll return the  attributes as index within our  array. Then starting from that index,  we can build up the set of the  rest of attributes for our query  rect simply by looping up and  down in our array and picking up  attributes until we exit our  query rect, until we find  attributes that are outside our  rect. And this should be much faster. You have thousands of items in  your array. You're not going to loop through  the array thousands of items,  thousands of times. Okay, so let's go back to the  sim again and let's see what our  faster scrolling algorithm looks  like. Let's pop this open and give it  a flick. It's way faster.

所以我们有一个排序数组，所以我们可以通过做二进制搜索来加快搜索速度，而不是我们现在做的线性滤波器。因此，让我们在这里删除我们的慢实现，让我们用更快的东西替换它。所以我要一步一步地走过这段路，别担心。所以我们要做的第一件事就是调用我们已经准备好的二进制搜索函数，它接受数组内的一系列索引和查询指令。如果它找到一组属性和一个位于我们的rect中的帧，它将返回这些属性作为数组中的索引。然后从这个索引开始，我们可以简单地通过在数组中上下循环并拾取属性，直到我们退出查询rect，直到找到在rect之外的属性，来构建查询rect的其余属性集。这应该快得多。您的数组中有数千个项目。你不可能通过成千上万个项目循环数次。好的，让我们再回到SIM，让我们看看我们的快速滚动算法是什么样子的。让我们把这个打开，轻轻地弹一下。它的速度更快。

 What do you think, Steve?   Much better. Okay, great. So we've got these two great  layouts. What's next?   So we have our two screens. That just leaves our update  animations for our friends list  here.  Oh, great. All right. Well let's switch back over to  slides, and let's walk through  that totally cool update  animation I think our designer  called it. All right, so we've got a video  here. Let's run through this and see  what this totally cool update  animation looks like. Okay. So we have some elements  here. We see that last item is getting  refreshed. I guess somebody posted a  picture, and then we got another  item there, it looks like, yeah,  that third item smears is not  going to be here. Okay. So we've got three basic  operations happening, right. We've got a reload, a move, and  a delete. Why don't we switch back over to  the dev machine, and Mohammed,  why don't you show us how this  works?   Sure thing. Okay, so we're doing multiple  animated updates at the same  time. So you might be aware of a great  tool that UICollectionView and  UITableView provide us, and it's  the Perform Batch Updates API,  which basically allows us to  pass the collection view a set  of updates that can be performed  at the same time with animation.

你觉得怎么样，史提夫？好多了。好的，太好了。所以我们有两个很棒的布局。下一步是什么？所以我们有两个屏幕。这只剩下我们的更新动画给我们的朋友列表了。哦，太好了。好的。好吧，我们回到幻灯片上来，让我们来看看那部非常酷的更新动画，我想我们的设计师称之为幻灯片。好的，我们这里有视频。让我们来看看这个完全酷的更新动画是什么样子的。可以。所以我们这里有一些元素。我们看到最后一个项目正在刷新。我猜有人贴了一张照片，然后我们在那里得到了另一件，看起来，是的，第三件污迹不会在这里。可以。所以我们有三个基本的操作发生了，对吧？我们有一个重新加载，一个移动，和一个删除。我们为什么不转回DEV机器，穆罕默德，为什么不给我们演示一下它是如何工作的？当然可以。好的，我们同时做多个动画更新。因此，您可能知道UICollectionView和UITableView为我们提供的一个很棒的工具，它是Perform Batch Updates API，它基本上允许我们将一组更新传递给集合视图，这些更新可以与动画同时执行。

 So I'm going to add a call to  CollectionView  PerformBatchUpdates, and note  that I'm doing both my data  source updates and my  CollectionView updates in the  closure here. This is really the best way that  I have of coordinating my  updates and keeping things  neatly in sync and avoiding  inconsistencies. So, first I'm just updating my  last item in my data source. I'm removing the second to last  item, picking up the last item,  moving it to the top, and then  I'm asking the CollectionView to  perform the animations that I  want. Okay. Let's go back to the sim  again and see what our update  looks like. So I have wired our update code  through this update button at  the top right corner, and uh oh.  What's going on?   Oh, that's embarrassing. What's going on here.  You know, I've been writing  iOS for a long time. I've seen this movie before.  Yeah, it sucks when it  happens on stage though. You know, we're running out of  time here, so why don't we just  call reload data, and we can  come back and do the animations  for V2.  Really?  You know, we could do that, but  then we'd lose that totally cool  update animation, and our users  expect these lively interfaces,  right?   Yeah, yeah, you're right. You know what?  They deserve better.  Ah, I like the way you think. All right, let's switch back  over to slides real quick, and  let's see if we can save our  totally cool update animation. You've seen this before. All right. So first of all, let's dig into  this debug exception and see  what it's trying to tell us. All right. So it's saying here we're  attempting to perform a delete  and a move from the same index  path, 0-3. So if I remember right, that was  the fourth item.

因此，我将向CollectionView PerformBatchUpdates添加一个调用，并注意我在这里的闭包中进行数据源更新和CollectionView更新。这确实是我协调我的更新，保持事物整齐同步，避免不一致的最好方法。首先，我只是更新我的数据源中的最后一个项目。我移除第二个到最后一个项，拾取最后一个项，将其移到顶部，然后请求CollectionView执行我想要的动画。可以。让我们再次回到SIM，看看我们的更新是什么样子。所以我在右上角通过这个更新按钮连接了我们的更新代码。发生什么事？哦，太尴尬了。这里发生了什么事。你知道，我已经写iOS很久了。我以前看过这部电影。是的，当舞台上出现的时候很糟糕。你知道，我们这里时间不多了，所以为什么不直接调用重新加载数据，然后我们可以回来为V2做动画呢？真的？你知道，我们可以这么做，但是那样我们就会失去完全酷的更新动画，而且我们的用户希望这些生动的界面，对吧？对，没错，你说得对。你知道吗？他们理应得到更好的待遇。啊，我喜欢你的想法。好吧，让我们快速切换到幻灯片，让我们看看是否可以保存我们的酷更新动画。你以前见过这个。好的。首先，让我们深入研究这个调试异常，看看它想告诉我们什么。好的。所以这里说，我们试图从相同的索引路径，0-3执行删除和移动。所以，如果我记得正确的话，那是第四个项目。

 We did a reload and a move on  that. We didn't delete it, we deleted  the third item, 0-2, right.  I don't remember deleting  them.  So, yeah, what's up with  that?  All right, but before we do  this, let's go back and take a  peek at the PerformBatchUpdates  API and talk about some  high-level principles. All right. So as Mohammed mentioned earlier  when he introduced this API, the  purpose of this API is that we  can commit multiple updates at  the same time and have anything  animate together and get that  great experience. And as he also mentioned, it's  super important to perform your  data source updates alongside  your CollectionView updates  inside that CollectionView  update closure. Now, what I'm saying for  CollectionView also applies for  TableView. So if you got TableViews in your  apps, all this information is  going the same direction.

我们做了一个重新加载和移动。我们没有删除它，我们删除了第三个项目，0-2，右边。我不记得删除它们了。所以，是的，这是怎么回事？好的，但是在我们进行此操作之前，让我们先回顾一下PerformBatchUpdates API，并讨论一些高级原则。好的。因此，正如穆罕默德在介绍这个API时早些时候提到的，这个API的目的是，我们可以同时进行多次更新，并且一起进行任何动画制作，从而获得很好的体验。正如他也提到的，在CollectionView update闭包中执行数据源更新和CollectionView更新是至关重要的。现在，我为CopeDeVIEW所说的也适用于TabLVIEW。因此，如果你在应用程序中得到了桌面视图，所有这些信息都朝着相同的方向发展。

 Okay. So let's make some  observations here. The CollectionView updates, when  you do inserts, moves, and  deletes, the ordering of those  do not matter in your update's  closure. Put them anywhere you want. Now however your data source  updates, when you're changing  the structure offer your data  source, which is backing that  data source, or does matter. Okay, so this is best served by  showing an example, so I'm going  to take a example of two arrays  that have three elements in  them, and we're going to  strengthen our intuition on this  and show a delete and an insert,  but we're going to do the first  run through with the delete  first and the second delete  second. We're going to reverse the  order, just to kind of  strengthen our intuition. I do this all the time, draw  pictures, right. All right. So we deleted the first item,  and now we're going to insert at  index one. Okay, on the second example, we  reverse the order and do the  insert first and then the  delete. So our intuition holds, indeed  we get a different result.

可以。让我们在这里做一些观察。当您进行插入、移动和删除时，CollectionView会更新，这些操作的顺序在更新的闭包中并不重要。把它们放在你想放的地方。现在，不管你的数据源如何更新，当你改变结构的时候，提供你的数据源，它支持那个数据源，或者确实很重要。好，这最好通过展示一个例子来达到，所以我要举两个包含三个元素的数组的例子，我们将加强对此的直觉，并显示一个删除和一个插入，但是我们将首先执行删除和插入秒删除秒。我们将改变秩序，只是为了增强我们的直觉。我总是这样做，画画，对。好的。所以我们删除了第一个项目，现在我们将插入第一个项目。好的，在第二个例子中，我们颠倒顺序，先做插入，然后删除。所以我们的直觉，事实上，我们得到了不同的结果。

 This is probably not a good  thing, right. So let's contrast this with the  CollectionView updates. Now here I have two sets of  CollectionView updates on a  submit via batch updates, and  I've left out the data source  updates, just to keep the slide  tidy. But I've got an insert and a  delete on the first one, and the  second one has a delete and a  insert, and the order is  different. This will give you the exact  same result. We're all engineers. We want to know why, why is  that?  Well, let's talk about that. How does this happen?  Why is the ordering not  important for the update sent to  the CollectionView, and of  course it is for your data  source. Okay. So let's walk through  these operation by operation. So the first one to delete, this  is process in descending index  path order. Now let's talk about the index  paths. So first of all, if you can  think about what's happening on  a PerformBatchUpdate, before the  batch update starts, your data  source is in a before state.

这可能不是好事，对吧？因此，让我们将它与CopyVIEW更新进行对比。现在，对于通过批量更新提交，我有两组CollectionView更新，为了保持幻灯片整洁，我省略了数据源更新。但是我在第一个上有插入和删除，第二个有删除和插入，顺序不同。这会给你完全相同的结果。我们都是工程师。我们想知道为什么，为什么？好吧，让我们谈谈这个问题。这是怎么发生的？为什么排序对于发送到CopeDeVIEW的更新并不重要，当然它是针对您的数据源的。可以。让我们通过手术来完成这些手术。所以第一个要删除的，这就是进程中的索引路径的递减顺序。现在让我们来谈谈索引路径。因此，首先，如果您能够考虑PerformBatchUpdate上发生了什么，那么在批量更新开始之前，您的数据源处于before状态。

 Now once everything is done in  the batch updates, you'll be an  after state. Okay. So for delete, the index  paths always referred to the  before stage. So that's delete. So insert is processed in  ascending index path order  paths. So the index paths refer to in  the insert are always referring  to the final state or the after  updates stage. Okay, a move is this mixture of  the two, right. You have a from and a to index  path, and the from is in the  before state, right, and the to  is in the after state. Reload. Now reload is a little  bit of a super command if you  will, right. It actually decomposes down into  a delete and an insert. And the index path specified in  a reload is speaking about the  before state. Okay. So this insight now that  we understand what reload is  really doing can kind of tell us  a little bit of what's going on  with our error in our app  because of the delete on the  reload on the last one is  conflicting internally with the  notion of moving that item,  okay. So we can address this in a  minute when we get back to code. Okay, so I'm not going to go  through these, but you can  reason about these later. Just put it up here as reference  that these are the things  that'll cause CollectionView to  go bonkers. Don't do it. And how can we take all this  knowledge and simplify it,  distill it in such a way that we  can always apply our data source  updates from a given set of  CollectionView or TableView  updates and make sure everything  is in sync. All right. So these four basic rules. So first of all you want to  decompose those moves and to  delete and inserts. Easy. And then combine all your  deletes and inserts into two  separate lists, process the  deletes first in descending  order on the index paths, and  then finally apply those inserts  in the ascending index path  order.

现在，一旦在批处理更新中完成了所有操作，您将是一个后状态。可以。因此，对于删除，索引路径总是指向前级。那就是删除。因此，插入在升序索引路径顺序路径中进行处理。因此，插入中的索引路径总是指向最终状态或后更新阶段。好的，移动是这两者的混合，对吧？你有一个AO和A到索引路径，而ON在前状态，右，和在后状态。重新装入。现在重新加载是一个超级命令的一点点，如果你愿意，对。它实际上分解成一个删除和一个插入。重载中指定的索引路径是关于前状态的。可以。因此，现在我们了解了重新加载真的在做什么，这可以告诉我们在我们的应用程序中的错误发生了什么，因为在最后一个重新加载上的删除在内部与移动那个项目的概念冲突，好吧。所以当我们回到代码时，我们可以在一分钟内解决这个问题。好的，所以我不打算通过这些，但是你可以稍后再解释。只是把它放在这里作为参考，这些都会导致收集视图变得疯狂。不要这样做。我们怎样才能获取所有这些知识并简化它，以这样一种方式来使用它，我们总是可以从给定的集合视图或TabelVIEW更新集合中应用我们的数据源更新，并确保所有的东西都同步。好的。所以这四条基本规则。所以首先要分解这些动作并删除和插入。容易的。然后将所有的删除和插入组合成两个独立的列表，首先在索引路径上按降序处理删除，然后最后按升序应用那些插入。

 Do this, and you're good to go. What about reload data?  And I know Mohammed said we  could just hit that and we're  done, and everybody laughed so  I'm pretty sure I yelled and  that's the case, but the thing  about reloaded data is you don't  get those great animations, and  this is really a sledge hammer  approach. So, and we really prefer the  apps to be lively and animated  and feel great for our  customers. So, and this is used in special  cases. Okay, Mohammed, let's switch  back over real quick and see if  we can get this fixed in code  and save that totally cool  update animation.  All right, time to redeem  myself.  Yes.  So let's use the guidelines  that Steve just shared with us  to fix our update animation. So let's remove our existing  implementation here. And if you recall, our update  consisted of a reload, a delete  and a move, and our reload and  the move were at the same index  path. They started at the same one. So that's really where our  conflict is. So we'll need to start out by  separating those two. So let's take our reload out  into its own call to perform  batch updates, and here I'm just  updating my data source, again,  same as before, and calling  reload items on the  CollectionView. I'm just performing it in a UI  view performed without animation  closure because if you look  closely at our spec, it's  actually nonanimated, that  initial reload. Okay. So next up, we have to  take care of our remaining  updates, that delete and the  move.

这样做，你就好了。重新加载数据怎么样？我知道穆罕默德说我们可以击中它，我们完成了，每个人都笑了，所以我很确定我大喊大叫，就是这样，但是关于重新加载数据的事情是，你没有得到那些很棒的动画，这真是一个大锤方法。所以，我们更喜欢应用程序生动、生动，对我们的客户感觉很好。因此，这是在特殊情况下使用的。好的，穆罕默德，让我们快速切换回去，看看我们能否把这个代码修复，然后保存这个非常酷的更新动画。好吧，是时候赎回我自己了。对。所以让我们使用史提夫和我们分享的修正我们的更新动画的指导方针。因此，让我们在这里删除现有的实现。如果您还记得，我们的更新包括重新加载、删除和移动，并且我们的重新加载和移动是在相同的索引路径上。他们从同一个开始。这就是我们的冲突所在。所以我们需要从分离这两个开始。因此，让我们将重新加载放到它自己的调用中以执行批量更新，在这里，我再次像以前一样更新我的数据源，并在CollectionView上调用重新加载项。我只是在UI视图中执行它，没有关闭动画，因为如果您仔细查看我们的规范，它实际上是非动画的，即初始重新加载。可以。所以接下来，我们必须处理剩下的更新，删除和移动。

 And let's reason about them for  a second. We have a delete at index two,  and then we're moving the item  at index three to index zero. So if we break down our move  using the guidelines that we  just learned about, that becomes  a delete at index 2, a delete at  index 3, and an insertion of the  item from index 3 at index 0. So now we have two sets of  operations. We have deletions and  insertions. We can process them accordingly. First, we'll perform our  deletions in descending order. So we'll do our deletion at  index 3 first, and will hold  onto the person from there so we  can insert them later on. And then we'll delete the item  at index 2. Then we'll need to process our  insertions in ascending order. We just have one, so we can just  go ahead and insert it. And finally, we'll ask the  CollectionView to perform the  animations that we want. Now, note, I'm still calling  move here. I didn't break it down into it's  component actions because we  still want the collection view  to play the right animations,  and if we've done the right  thing with our data source, the  CollectionView will do the right  think in terms of animations. All right.

让我们来解释一下。我们在索引二有一个删除，然后我们将索引三中的项移动到索引为零。因此，如果我们使用我们刚刚了解的指导方针来分解我们的移动，这变成在索引2处删除，在索引3处删除，以及在索引0处从索引3插入项。现在我们有两组操作。我们有删除和插入。我们可以相应地处理它们。首先，我们将按降序执行删除。因此，我们将首先在索引3中删除，并保存到那里的人，以便以后再插入它们。然后我们将在索引2中删除该项。然后我们需要按升序处理插入。我们只有一个，所以我们可以继续插入它。最后，我们将要求CopyVIEW执行所需的动画。现在，注意，我仍然叫移动到这里。我没有把它分解成组件动作，因为我们仍然希望集合视图播放正确的动画，并且如果我们用数据源做了正确的事情，那么CollectionView将根据动画进行正确的思考。好的。

 Let's go back to the simulator  and see what our update looks  like when it works. All right. Here goes nothing.  Wow.  Great!  I'm going to reload and take a  slow-mo victory lap just to--  there we go. That looks exactly like our  spec, doesn't it.  That's great, awesome. All right. Well let's wrap it up. We covered a ton of content. Can you switch it back to  slides?  And I'd like to issue a bit of a  call to action. So if you've been nervous or  anxiety building that custom  layout, take the stuff we just  applied today and go back and  dive in and create those custom  layouts and build really great  CollectionView solutions. And if you got a lot of reload  data sprinkled all throughout  your apps and you're losing out  on these gray animations. They'll inspect those things and  see maybe why you didn't  understand or something wasn't  quite jived about why it was  happening and fix those spots. Okay, so more information, you  can see the link on the slide  here. And we also have a  CollectionView lab tomorrow  morning at 9. If you have any questions or  comments about your  CollectionViews, please swing on  by and chat. Mohammed and I will both be  there. And thanks very much for coming  out, and I hope you enjoy the  rest of your conference.

让我们回到模拟器，看看我们的更新工作时的样子。好的。这里什么也没有。真的。伟大的！我要重新装上一个缓慢的胜利圈，就在那里。这看起来和我们的规格完全一样，不是吗？太棒了，太棒了。好的。好吧，让我们把它包起来。我们涵盖了大量的内容。你能把它换成幻灯片吗？我想提出一个行动号召。因此，如果您一直紧张或焦虑地构建定制布局，那么就拿我们今天刚应用的东西回去，深入地创建那些定制布局，并构建真正优秀的CollectionView解决方案。如果你有大量的重新加载数据在你的应用程序中到处都是，那么你就失去了这些灰色动画。他们会检查那些东西，也许看看你为什么不明白，或者有什么东西对为什么会发生这种事不太感兴趣，然后把这些地方修好。好了，更多的信息，你可以看到幻灯片上的链接。明天早上9点还有一个CopeVIEW实验室。如果你对你的收藏品有任何疑问或评论，请点击并聊天。我和穆罕默德都在那儿。非常感谢你们的到来，我希望你们能享受你们的余下的会议。





