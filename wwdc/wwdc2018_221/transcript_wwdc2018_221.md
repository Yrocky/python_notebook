## TextKit Best Practices

  Hi everyone. Welcome to session 221, TextKit  Best Practices. I'm Donna Tom. And I'm the TextKit engineer. And my colleague Emily Van Haren  from authoring tools will be  joining me today. And we're both really excited to  share with you some best  practices for working with  TextKit. So let's get started. First, we're going to review  some key concepts for working  with TextKit. Then, we'll dive into some  examples to illustrate how to  apply the key concepts in your  app. And finally, we'll wrap up with  some best practices in the areas  of correctness, performance, and  security. So let's start with the key  concepts. Now to make sure we're on the  same page, we're going to start  at the very beginning. What is TextKit?  And your first instinct might be  to open a shiny new playground  in Xcode and type import  TextKit, except if you've ever  actually tried this, you found  that it doesn't work. And that's because TextKit is a  little different than other  frameworks you might have used. You don't have to import  anything special to use it. The text controls in UIKit and  AppKit are built on top of  TextKit. And so if you've ever used a  label, the text field, or a text  view, you've actually used  TextKit. And TextKit pulls together  powerful underlying technologies  such as Core Text, Core Graphics  and Foundation to make it simple  and seamless for your apps to  show text. And every time you use one of  these built-in controls, you're  using the power of TextKit to  show or edit text in a fully,  internationalized, localizable  manner without having to  directly use these underlying  technologies or understand the  intricacies of complex scripts. And there are a lot of things  you get for free too like all of  these display features that you  see here.

> 大家好。欢迎访问第221届TeXKIT最佳实践。我是Donna Tom。我是TeTKIT工程师。我的同事Emily Van Haren从创作工具将加入我今天。我们都很高兴和大家分享一些使用TeXKIT的最佳实践。让我们开始吧。首先，我们将回顾一些使用TeXKIT的关键概念。然后，我们将举出一些示例来说明如何在应用程序中应用关键概念。最后，我们将在正确性、性能和安全性方面总结一些最佳实践。让我们从关键概念开始。现在为了确保我们在同一页上，我们将从一开始就开始。TextKit是什么？你的第一直觉可能是用Xcode打开一个闪闪发光的新操场，然后输入import TextKit，除非你曾经真正尝试过，你发现它不起作用。这是因为ToTKIT与您可能使用的其他框架有点不同。你不必进口任何特殊的东西来使用它。UIKit和AppKIT中的文本控件是在TextKit的顶部构建的。因此，如果您曾经使用过标签、文本字段或文本视图，您实际上已经使用了TeTKIT。Text KIT将强大的底层技术（如核心文本、核心图形和基础）结合在一起，为您的应用程序提供简单、无缝的文本显示。每次使用这些内置控件之一时，您都会使用TextKit的强大功能以完全、国际化、本地化的方式显示或编辑文本，而无需直接使用这些底层技术或理解复杂脚本的复杂性。还有很多免费的东西，就像你在这里看到的所有显示功能一样。

 And for editing, you'll also get  access to all the tech services  that are supported by the OS  like accessibility, spell  checking and more. And you can take advantage of  all of these great features  without having to write a single  line of code and that's pretty  awesome. And so with all of this  functionality at your  fingertips, how do you decide  which control to use?  So let's talk about that,  choosing the right control for  your situation. And the options are going to be  a little bit different depending  on whether you're using UIKit or  AppKit. So let's review them separately. All right. Let's start with UIKit. And first you're going to  consider whether you need text  input. And if you don't need text  input, then consider whether you  need selection or scrolling. And if you don't need these,  then you should use UILabel. UILabels are intended for small  amounts of text like a few words  or a few lines. And so if you have more text  than that or if you need these  selection or scrolling  capabilities then you should use  a UITextView with editing  disabled. Now going back to the top.

> 对于编辑，您还可以访问操作系统支持的所有技术服务，如可访问性、拼写检查等。而且你可以利用这些伟大的特性，而不必编写一行代码，这太棒了。因此，所有这些功能在你的指尖，你如何决定使用哪一个控件？让我们来讨论一下，为你的处境选择正确的控制。根据您是否使用UIKIT或AppKIT，选项将有所不同。让我们分开来复习。好的。让我们从UIKit开始。首先你要考虑你是否需要文本输入。如果您不需要文本输入，那么考虑是否需要选择或滚动。如果你不需要这些，那么你应该使用uIababel.UIABEL用于少量文本，如几句话或几行。因此，如果您的文本比这个多，或者如果您需要这些选择或滚动功能，那么应该使用禁用编辑的UITextView。现在回到顶峰。

 If you do need text input, then  consider whether you need secure  text entry. And this would be like a  password field where the text is  obscured and copying is  disabled. And so if you need that, then  use UITextField because this is  the only control that supports  secure text entry. Otherwise, think about how much  text you expect to be entered. And if you want something that's  like a form field input that  only needs a line, then use  UITextField. And UITextField only supports  one line of text entry. Otherwise, if you need more than  that, you can use UITextView. And so now here's that same  decision process for AppKit. And it's similar to the UIKit  process but there's a few small  differences. So, again, you're going to start  by considering whether you need  text input. And AppKit doesn't have a label  control. So if you need to display text,  use an NSTextField and you can  disable both editing and  selection to get that label  behavior. Now going back to the top here. If you do need text input, again  ask if you need secure text  entry. And if so, you can use  NSSecureTextField. Otherwise, we're going to ask  our favorite question, how much  text do you expect?  So NSTextView is optimized for  performance with large amounts  of text.

> 如果您确实需要文本输入，那么考虑是否需要安全文本输入。这将是一个密码字段，其中文本被遮挡并且复制被禁用。因此，如果需要，那么使用UITExtFieldfield，因为这是唯一支持安全文本输入的控件。否则，考虑你希望输入多少文本。如果你想要一个只需要一行的表单字段输入，那么使用UITExtField.UITExtField只支持一行文本输入。否则，如果需要更多，可以使用UITExtVIEW。这就是AppKIT的相同决策过程。它类似于UIKIT过程，但也有一些小的差异。所以，再次，您将开始考虑是否需要文本输入。AppKit没有标签控件。因此，如果需要显示文本，请使用NSTExtField，并且可以禁用编辑和选择以获得该标签行为。现在回到这里的顶部。如果您确实需要文本输入，请再次询问是否需要安全文本输入。如果是的话，可以使用NSSECURE文本字段。否则，我们会问我们最喜欢的问题，你想要多少文本？因此，NSTExVIEW对于大量文本的性能进行了优化。

 And so if you're expecting a lot  of text, you should use  NSTextView otherwise you can use  NSTextField. Now, unlike its UIKit  counterpart, NSTextField does  support multiple lines of text,  but it's still optimized for  shorter strings and so you  should still use NSTextView if  you have a lot of text. Now those of you who have been  around the block a few times  with TextKit might notice that  the flow charts are missing an  option and that's string  drawing. And you use string drawing by  directly calling draw in point  or draw in rect methods under  NSString or your  NSAttributedString. And many of you may be using  this for the performance benefit  to avoid the overhead of view  objects at the kit level. And so if you're going to go  this route, please keep the  following tips in mind. You want to use it for small  amounts of static text. And you want to limit how  frequently you call the draw  methods. Now if you're calling the string  drawing methods a lot, you might  actually get better performance  out of a label or a text field  because these controls provide  better caching, especially if  you're using auto layout. And if you're drawing an  attributed string with a lot of  custom attributes, this could  also be slowing down your string  drawing because the text system  needs to validate all of the  attributes before rendering and  so for best performance, you  should strip out extra  attributes before drawing and  only pass in the ones that are  needed to determine the visual  appearance like font or like  color. And finally, remember that by  using string drawing, you'll  miss out on all of this free  functionality that's offered by  the text controls, so you should  use the text controls whenever  possible. So now you know what you can do  with TextKit just by using the  built-in controls. But if you want to go beyond  what these controls provide,  you'll need to find the right  customization point within the  text stack. And like much of Cocoa, TextKit  is based on the model view  controller design pattern. And the text system can be  divided into three phases that  correspond it directly to NBC  and that's storage, display, and  layout. And so now let's take a closer  look at the TextKit objects that  make up each of these phases. And we'll start with the storage  which corresponds to the model. Now NSTextStorage holds your  string data and your attributes. It's a subclass of mutable  attributed string and so you can  work with it in the same way  that you already know how to  work with attributed strings. And my colleague Emily will show  you some really powerful ways to  customize the text storage a  little bit later so stay tuned  for that. Now NSTextContainer models the  geometry of the area where your  text will be laid out. And by default, it's a rectangle  but you can customize the flow  or the shape of the text layout  as shown here. And for more detailed  information on working with the  storage objects, check out these  great past WWDC sessions and  documentation. And they'll be available from  the more information link at the  end of the session. And next up is the display phase  and that corresponds to the  view. And we've already talked about  the display phase quite a bit  when we talked about choosing  the right control.

> 因此，如果你期待大量的文本，你应该使用NSTEXVIEW，否则你可以使用NSTExtField。现在，NSTextField与UIKit的对应版本不同，它支持多行文本，但是对于较短的字符串，它仍然进行了优化，因此如果您有很多文本，那么仍然应该使用NSTextView。现在，那些使用TextKit浏览过几次的读者可能会注意到流程图缺少了一个选项，这就是字符串绘制。通过直接调用NSString或NSAttributedString下的draw in point或draw in rect方法，可以使用字符串绘图。你们中的许多人可以使用它来获得性能上的好处，以避免在工具包级别上查看对象的开销。所以如果你要走这条路线，请记住下面的提示。你想用它来做少量的静态文本。并且希望限制调用绘图方法的频率。现在，如果您经常调用字符串绘制方法，那么实际上可能从标签或文本字段中获得更好的性能，因为这些控件提供更好的缓存，尤其是如果您使用自动布局。如果您正在绘制带有大量自定义属性的属性字符串，这也可能减慢您的字符串绘制速度，因为文本系统需要在呈现之前验证所有属性，因此为了获得最佳性能，您应该在绘制之前去除额外的属性并且只需输入需要确定外观的字体或类似颜色的字体。最后，请记住，通过使用字符串绘图，您将错过文本控件提供的所有免费功能，因此应该尽可能使用文本控件。所以现在你知道你可以通过使用内置控件来处理ToTKIT。但是，如果您想超越这些控件提供的内容，则需要在文本堆栈中找到正确的定制点。和很多可可一样，TeXKIT是基于模型视图控制器设计模式的。文本系统可以分为三个阶段，分别与NBC直接对应，即存储、显示和布局。现在让我们仔细看看组成这些阶段的TeTKIT对象。我们将从与模型相对应的存储开始。现在，NSTextStorage保存字符串数据和属性。它是可变属性字符串的子类，因此您可以以与您已经知道如何处理属性字符串相同的方式使用它。我的同事Emily稍后将向您展示一些非常有效的方法来定制文本存储，因此请继续关注这一点。现在，NSTextContainer模拟你的文本将被布置的区域的几何学。默认情况下，它是矩形，但您可以自定义流或文本布局的形状，如图所示。有关使用存储对象的更详细信息，请参阅这些过去的WWDC会话和文档。在会话结束时，他们可以从更多的信息链接中获得。接下来是显示阶段，它对应于视图。当我们谈到选择正确的控制时，我们已经谈论了相当多的显示阶段。

 And so for additional  information, you can again check  out these documentation  resources. And they'll also be accessible  from that more information link  at the end of the session. And finally, we have the layout  phase which corresponds to the  controller. And NSLayoutManager is the only  component in this phase. And let me tell you it is a  beast. And I mean that in a good way  because it's so awesome at what  it does. So it's the brains of the whole  operation. It coordinates changes between  all of the phases, and it  controls the layout process  itself. So here's a quick overview of  how that layout process works. So text layout happens after the  system fixes attributes in the  text storage to remove  inconsistencies like making sure  that all the characters in the  string are covered by fonts that  support displaying those  characters. And so in this example, the  Times New Roman font is  specified for the entire string,  but this font doesn't support  displaying Japanese kanji or  emoji. And so after attribute fixing,  your text storage will look  something like this with an  appropriate Japanese font  assigned to the Japanese  characters and the emoji font  assigned to the emoji character. All right. So once the attributes are  fixed, the layout process can  begin. And we can think of layout in  two steps: glyph generation  followed by glyph layout. And once they're laid out,  they're ready for display. But wait a minute. What's a glyph?  Let's back up and review that. A glyph is a visual  representation of one or more  characters. And as you can see here, the  mapping between characters and  glyphs is not always one-to-one. So here this string ffi has  three characters, but it could  be represented by a single glyph  for the ligature. And you can go in the other  direction too. Here we have n [inaudible] which  is a single character that can  be represented by multiple  glyphs: one for the n and one  for the tilde. And so going back to our diagram  here, we have NSLayoutManager  performing glyph generation and  glyph layout. And glyph generation is where  the layout manager takes the  characters and figures out what  glyphs need to be drawn. And glyph layout is where the  layout manager positions those  glyphs for display in your view. And there's a lot more to learn  about the layout manager from  these past WWDC sessions and  documentation.

> 因此，对于附加信息，您可以再次查看这些文档资源。在会话结束时，他们也可以从更多的信息链接中访问。最后，我们有对应于控制器的布局阶段。NSLayoutManager是这个阶段唯一的组成部分。让我告诉你这是一只野兽。我的意思是很好，因为它做的太棒了。这就是整个手术的大脑。它协调所有阶段之间的变化，并控制布局过程本身。这是一个关于布局过程的快速概述。因此，文本布局是在系统修复文本存储中的属性以消除不一致之后发生的，比如确保字符串中的所有字符都被支持显示那些字符的字体覆盖。因此，在本例中，为整个字符串指定了Times New Roman字体，但是这种字体不支持显示日语汉字或表情。因此，在属性修复之后，您的文本存储将看起来像这样，具有分配给日语字符的适当日语字体和分配给表情字符的表情字体。好的。因此，一旦属性固定，布局过程就可以开始。我们可以在两个步骤中考虑布局：字形生成，然后是字形布局。一旦它们被布置好，它们就可以展示了。但是等一下。字形是什么？让我们回顾一下。字形是一个或多个字符的视觉表示。正如你在这里看到的，字符和字形之间的映射并不总是一一对应的。因此，这个字符串FFI有三个字符，但是它可以用结扎线的单个字形来表示。你也可以朝另一个方向走。这里我们有n[听不见]，它是一个单一的字符，可以用多个符号表示：一个用于n，一个用于tilde。回到我们的图表，我们有NSLABOUT管理器执行字形生成和字形布局。字形生成是布局管理器将字符和图形勾画出需要画字形的地方。字形布局是布局管理器在您的视图中显示这些字形的位置。从这些过去的WWDC会议和文档中可以了解更多关于布局管理器的知识。

  And if you want different  layouts in each of you, you can  do that too, just use multiple  layout managers. And, again, since the text  shares the same backing store,  updating that text will update  all of the views. Now we didn't go into too much  detail about these  configurations because there's a  great past session that's  already done that so check out  WWDC 2010 session Advanced Cocoa  Text Tips and Tricks. And this will be accessible from  that more information link at  the end of the session. All right. So we've looked at the built-in  text controls. We've looked at the components  in TextKit. And we've look at how to  configure those components to  achieve different effects. And there's a lot that you can  do with that knowledge already,  but if you need even more,  you'll need to extend and  customize parts of TextKit  yourself. And so now we'll talk a little  bit about choosing the right  approach for doing that. And choosing the right approach  is like building up your text  toolbox. It's like going to the store  because you need a hammer. And then when you get there, you  encounter this giant wall of  hammers to choose from. And you want to pick your hammer  that can do the job and ideally  the least expensive one that  will do what you need. And so these are the hammers  that are available to us. Delegation is like your standard  hammer with the claw on the end,  and it's used to perform  multiple tasks. So the delegates have a lot of  different customization hooks  and most of the time they'll get  the job done for you. Notifications is like a  ball-peen hammer. And this has a ball on the end  instead of a claw so it's more  specialized and it's better  suited for certain tasks, but  it's not as versatile as the  standard hammer of delegation. And finally, subclassing is your  sledgehammer. The sledgehammer is very  powerful, and you can use it for  just about anything that you  would need a hammer for but it's  probably overkill for a lot of  things. And with that, I'd like to  invite Emily up to show us how  to use these different kinds of  hammers. Emily.

> 如果你希望每个人都有不同的布局，你也可以这样做，只需使用多个布局管理器即可。而且，由于文本共享相同的后备存储，更新该文本将更新所有视图。现在我们没有详细讨论这些配置，因为有一个很棒的过去会话已经完成，所以请查看WWDC 2010会话高级可可文本提示和技巧。这将在会话结束时从更多的信息链接中访问。好的。我们已经研究了内置的文本控件。我们已经研究了TextKit的组件。我们已经研究了如何配置这些组件以实现不同的效果。关于这些知识你可以做很多事情，但是如果你需要更多，你需要自己扩展和定制TextKit的部分。现在我们来讨论一下选择正确的方法。选择正确的方法就像建立你的文本工具箱。这就像去商店，因为你需要一把锤子。然后当你到达那里时，你会遇到巨大的锤子墙供你选择。你想选择你的锤子来做这项工作，最好是最便宜的一个，你可以做你需要的。这就是我们所能得到的锤子。委派就像你的标准锤，末端有爪，用来执行多个任务。所以代表有很多不同的定制挂钩，大多数时候他们会为你完成任务。通知就像一个球头锤。而且它末端有一个球，而不是爪子，所以它更专业，更适合某些任务，但它不像授权的标准锤子那么通用。最后，子类是你的大锤。大锤非常强大，你可以用它做任何你需要用锤子做的事，但是对于很多事情来说它可能太过杀伤力了。因此，我想邀请艾米丽向我们展示如何使用这些不同种类的锤子。艾米丽。

  Thank you, Donna. So, as developers, we have a  collection of controls to choose  from, various configurations,  and a wide range of  customization options to achieve  what we need. So our tool chest is stocked  full, but how do we know what  tools to choose?  So we're going to take a look at  some examples of apps that  harness the power of TextKit. And we don't have to look very  far because almost every app  that we use displays or edits  text. We're going to start by looking  at two apps that we're all  familiar with and then go  through the steps of building  our own. So the first app we're going to  look at is Apple News on iOS,  which is a beautiful app that  displays text in a personalized  and curated articles. So here's an example of an  article that is featured in the  spotlight tab. Now the top of the app shows  some details about this article. Now how could we use TextKit to  re-create this look and feel?  So let's consider the flow chart  that Donna showed us earlier to  pick the control that's best  suited for this example. So we have a handful of text  controls to choose from, but  since we want to display small  amounts of text, each on a  single line, we'll use a label. Now we can see that there is a  ton of customization options in  the inspector panel. So we're going to go ahead and  change the text to spotlight. We're going to change the font  to use the body style. And we're going to enable  dynamic type, which allows those  with accessibility settings  enabled to see text in a font  size and style that is  appropriate for their needs.

> 谢谢你，堂娜。因此，作为开发人员，我们有一系列控件可供选择，各种配置，以及广泛的定制选项，以实现我们所需的。所以我们的工具箱已经装满了，但是我们怎么知道选择什么工具呢？所以我们来看看一些应用TabKIT的应用程序的例子。我们不必看得太远，因为我们使用的几乎每个应用程序都显示或编辑文本。我们将从我们熟悉的两个应用程序开始，然后通过构建我们自己的步骤。所以我们要看的第一个应用程序是iOS上的Apple News，这是一个漂亮的应用程序，可以在个性化和策划的文章中显示文本。这里有一个在聚光灯选项卡上的文章的例子。现在应用程序的顶部显示了这篇文章的一些细节。现在我们如何使用TeTKIT来重新创建这个外观和感觉？让我们考虑一下堂娜先前给我们展示的流程图，选择最适合这个例子的控件。因此，我们有一些文本控件可供选择，但是由于我们希望显示少量的文本，每个文本都在一行上，所以我们将使用标签。现在我们可以看到，检查面板中有大量的定制选项。所以我们将继续把文本变成聚光灯。我们将更改字体以使用体样式。我们将启用动态类型，它允许那些具有可访问性设置的人看到字体大小和样式适合他们需要的文本。

 Now it's great that we can  customize this label in  Interface Builder, but we can  also see all these properties in  Swift. So we can set the text and the  formatting properties  dynamically at runtime. Now back in Interface Builder,  we'll go ahead and add two more  labels. Now everything fits pretty well,  but we have one more thing we  need to do here. So looking back at Apple News,  we can see that the text on the  right is actually displayed with  two different colors. Part of it's black and part of  it's white. Now we could achieve this with  two separate labels, but if we  wanted to use just one label, we  wouldn't be able to do this in  Interface Builder. So how could we do this?  Well, we can take advantage of  the power and flexibility of  attributed strings. Now an attributed string is a  run of characters that can have  attributes applied to ranges of  characters. Now some attributes you get for  free like the default font and  text color, but we can override  these attributes with our own  values. In this case, we're going to set  part of our string's text color  to white. Now to see attributed string in  action, we'll use the add  attribute method on  NSMutableAttributedString to set  the text color to white just for  the range that we want. And this time we'll set the  attributed text property on our  label. At runtime, this looks pretty  spiffy. Now UILabels were a great choice  for this sort of text. Now if we look at the bottom of  the screen, we'll see a  headline. Now this is also text, but it's  a little bit bigger and it spans  multiple lines.

> 现在，我们可以在界面生成器中定制这个标签，但是我们也可以在SWIFT中看到所有这些属性。因此，我们可以在运行时动态设置文本和格式化属性。现在回到界面生成器，我们将继续添加两个标签。现在一切都很好，但是我们还有一件事要做。回过头来看苹果新闻，我们可以看到右边的文字实际上是用两种不同的颜色来显示的。部分是黑色的，部分是白色的。现在我们可以通过两个独立的标签来实现这一点，但是如果我们只想使用一个标签，我们就不能在Interface Builder中做到这一点。那么我们怎么才能做到呢？我们可以利用属性字符串的力量和灵活性。现在，属性字符串是一组字符，可以将字符应用到字符范围。现在有些属性是免费的，比如默认字体和文本颜色，但是我们可以用自己的值覆盖这些属性。在这种情况下，我们将把字符串的文本颜色的一部分设置为白色。现在，为了查看属性字符串的实际作用，我们将使用NSMutableAttributedString上的add属性方法将文本颜色设置为白色，以适应我们想要的范围。这次我们将在我们的标签上设置属性文本属性。在运行时，这看起来很漂亮。现在UILabels是这类文本的一个很好的选择。现在，如果我们看看屏幕的底部，我们会看到一个标题。现在这也是文本，但是它有点大，它跨越了多条线。

 Another thing that makes this  text different is that it's  selectable. So which control should we use  this time?  Now both text field and text  view support selection but text  field is meant for usually just  one line. So in this case, since our  headline can span multiple  lines, we're going to use a text  view. Now when we put a text view onto  our storyboard, we can see that  we get a lot of lorem ipsum text  by default. So we're going to go ahead and  change the text in the inspector  panel. We're also going to change the  font to look a little bit more  like Apple News. And we want to disable the  editing feature because the  headline isn't really editable. Now UITextView scroll by default  because they are a subclass of  UIScrollView. But if we want our text view to  play well with auto layout, we  want to disable scrolling. So this will allow the bounds of  our text view to resize to fit  the text. Last but not least, this white  background really needs to go,  so we're going to set it to  transparent. Now Interface Builder made it  really easy to customize this  text view but just like our  labels before, we can set all  this in code. So here in Swift, we can set the  text and the formatting  properties dynamically at  runtime. So we looked at Apple News to  pick the right control, but now  we're going to look at a  different app that we're all  familiar with to choose the  right configuration and that's  TextEdit. Now TextEdit is an app on macOS  that handles display and editing  of rich text content. Now what most people don't know  is that TextEdit is actually a  really thin wrapper around  NSTextView. So I want to take a moment to  marvel at just how much we get  for free with TextKit. So this is the inspector bar,  and we get this for free just by  checking a checkbox in Interface  Builder.

> 另一个使文本不同的是它是可选择的。那么这次我们应该使用哪种控制呢？现在文本字段和文本视图都支持选择，但是文本字段通常只用于一行。因此，在这种情况下，由于我们的标题可以跨越多行，所以我们将使用文本视图。现在，当我们把文本视图放到故事板上时，我们可以看到默认情况下，我们得到了大量的LoRIM IpHand文本。所以我们将继续在检查器面板中更改文本。我们也将改变字体看起来有点像苹果新闻。我们想禁用编辑功能，因为标题不是真正可编辑的。现在UITextView默认是滚动的，因为它们是UISCLVIEW的子类。但是如果我们想让我们的文本视图在自动布局中发挥作用，我们希望禁用滚动。因此，这将允许文本视图的边界调整大小以适合文本。最后但并非最不重要的是，这个白色背景真的需要去，所以我们要把它设置为透明的。现在，Interface Builder使得定制这个文本视图变得非常简单，但是就像之前的标签一样，我们可以在代码中设置所有这些。因此，在SWIFT中，我们可以在运行时动态设置文本和格式化属性。所以我们看了Apple News来选择正确的控件，但是现在我们要看一个我们都熟悉的不同的应用程序，来选择正确的配置，这就是TextEdit。现在Text是Mac OS上的一个应用程序，它处理丰富文本内容的显示和编辑。现在大多数人不知道的是，TexTeDIT实际上是NSTextView周围的一个非常薄的包装物。所以我想花一点时间来惊奇一下我们用TabKIT免费得到多少。这是检查器条，我们通过检查界面生成器中的复选框来免费获取。

 And right below it is a ruler  view which we also get for free  just by enabling it. And everything below that is  just a text view. Actually, it's a text view, text  container, layout manager, and  text storage. Now this is the standard  configuration for both  NSTextView and UITextView, but  the similarities mostly stop  there. So, for example, tables are only  supported in NSTextView. And marveling again at the power  that we get for free, TextKit  provides a table editor that  does all the heavy lifting for  us. Now when we use TextEdit, we're  often editing large amounts of  text. Sometimes we paste in a lot of  lorem ipsum to see that we also  get a spell-checker for free. But really what we want to see  is that when we use the format  menu to choose wrap to page, we  end up with it looking a little  bit more like a page. We can see that the text  container has been resized to  match the dimensions of a piece  of paper. Now if we scroll down, we can  see that the text jumps from the  first page to the second. Now the standard configuration  doesn't really support layout  like this. Sure enough, this layout uses  two text views and text  containers. Now they're still managed by the  same layout manager and text  storage, which allows the text  to freely jump from one page to  the next. Now if you'd like to see more  about how TextEdit works, you  can actually find its source in  the guides and sample codes  library. So we've picked the right  controls, we've picked the right  configuration, but sometimes we  actually need to hammer on these  to achieve what we want. But how do we decide which  hammer to use?  So we're going to try and pick  the right hammer for the job  when we go through the steps of  building a journal app together. We'll start by putting today's  date on to the window. Now we don't have UILabels in  AppKit, but we can make a text  field behave like a label. All we need to do is disable  editing. Now for the journal entry part  of the window, we're going to  use a text view.

> 在它的正下方是一个统治者的观点，我们也可以通过免费获得它。下面的一切只是文本视图。实际上，它是文本视图、文本容器、布局管理器和文本存储。现在这是NSTEXVIEW和UITExtVIEW的标准配置，但相似之处大多在那里停止。因此，例如，表只支持在NSTEXVIEW中。TextKit再次惊叹于免费提供的强大功能，它提供了一个表编辑器，为我们完成所有繁重的工作。现在，当我们使用TeXTeDIT时，我们经常编辑大量的文本。有时我们粘贴大量的LoRM IPSUM，这样我们就可以免费得到拼写检查。但实际上我们想看到的是，当我们使用格式菜单来选择逐页包装时，最终看起来更像一个页面。我们可以看到文本容器已经被调整大小以匹配一张纸的尺寸。现在，如果我们向下滚动，我们可以看到文本从第一页跳到第二页。现在，标准配置并不能真正支持这样的布局。当然，这个布局使用两个文本视图和文本容器。现在，它们仍然由相同的布局管理器和文本存储进行管理，这使得文本可以自由地从一个页面跳到下一个页面。现在，如果你想了解更多关于TextEdit如何工作的信息，你可以在指南和示例代码库中找到它的源代码。所以我们选择了正确的控件，选择了正确的配置，但有时我们需要对这些控件进行锤击以实现我们想要的。但是我们如何决定使用哪一把锤子呢？所以，当我们一起完成一个杂志应用程序的步骤时，我们会尝试选择合适的锤子来完成这项工作。我们先把今天的日期放在窗前。现在我们在AppKit没有ULababels，但是我们可以让文本字段像标签一样。我们需要做的就是禁用编辑。现在对于窗口的日志条目部分，我们将使用文本视图。

 So in the inspector, we can make  sure that the text view is  editable and selectable and  supports rich text and undo. We're going to add a couple of  text fields to the bottom of the  window as well so that we can  show how many words have been  written. Now when we run our app, we want  the word count at the bottom to  change, so let's find the right  hammer for this job. Now we can either conform to a  delegate, handle a notification  or subclass. But in this case, we're going to  use a small hammer. And we're going to listen for a  notification from text storage. Now we can get the number of  words from the text storage. And when we hear the  notification, we can update the  string value property of our  text field. And when we start typing, we can  see the word count change. Now if we want to emphasize part  of our text, we can use keyboard  shortcuts or the menu to apply  formatting like bold. But it would be great if we  could support modern text  formatting like Markdown, which  uses control characters to  specify formatting. So if we start inserting  asterisks before and after, we  want it to be bold. But which hammer should we use  for this?  Well, we want to know when a  change happens, and we want to  know where a change happens. But notifications don't really  give us much information about  this change. So we're going to use a bigger  hammer and implement the text  storage delegate, specifically  the didProcessEditing method. Now we can make a new bold font  from our existing one.

> 因此，在检查器中，我们可以确保文本视图是可编辑和可选择的，并支持丰富的文本和撤消。我们还要在窗口的底部添加几个文本字段，以便显示已经写入了多少单词。现在，当我们运行我们的应用程序时，我们希望底部的单词计数改变，所以让我们为这个工作找到正确的锤子。现在我们可以遵从委托，处理通知或子类。但在这种情况下，我们将使用一个小锤子。我们来听听文本存储的通知。现在我们可以从文本存储中获取单词的数量。当我们听到通知时，我们可以更新文本字段的字符串值属性。当我们开始打字时，我们可以看到单词数的变化。现在，如果我们想强调文本的一部分，我们可以使用键盘快捷键或菜单来应用格式化，像粗体。但是如果我们能够支持像Markdown这样的现代文本格式，使用控制字符指定格式，那就太好了。因此，如果我们开始插入星号前后，我们希望它是大胆的。但是我们应该用哪把锤子呢？我们想知道什么时候发生变化，我们想知道变化发生在哪里。但是通知并没有真正告诉我们关于这一变化的很多信息。因此，我们将使用更大的锤子并实现文本存储委托，具体地说是DeD PraseSeCuestIn方法。现在我们可以用我们现有的字体做一个新的粗体字体。

 And we can add that font  directly to our text storage for  the range that we want to be  bold. And now when we insert that last  asterisk, we can make it bold. Now we're feeling pretty good  about this whole Markdown thing  so what if we try inserting a  code snippet?  Now in Markdown it looks like  this. And if we add this last  back-tick, we want it to look  like a code block. It should have a background and  a header that says Swift Code. Now this is actually a complex  task, so we're going to need two  sledgehammers. And the first is a subclass  NSTextStorage. Now when we subclass  NSTextStorage, we need to  implement four required methods. And we can do this by operating  on a private instance of a  mutable string. Now let's pay attention to the  replaceCharacters method. Now we can add an NSTextBlock to  our paragraph style. And then we can add that  paragraph style to our text  storage over the range of that  code block.

> 我们可以将字体直接添加到文本库中，用于我们想要粗体的范围。现在，当我们插入最后星号时，我们可以让它变得大胆。现在我们对整个降价事件感觉很好，如果我们尝试插入一个代码片段呢？现在降价，看起来就是这样。如果我们添加最后一个回勾，我们希望它看起来像一个代码块。它应该有一个背景和一个标头Swift Code。这实际上是一项复杂的任务，所以我们需要两个大锤。第一个是NSTEXT存储子类。现在，当我们对NSTExtStar子类进行分类时，我们需要实现四种所需的方法。我们可以通过操作一个可变字符串的私有实例来实现这一点。现在我们来关注替换字符方法。现在我们可以在我们的段落样式中添加NSTETCBULD。然后我们可以在代码块的范围内将段落样式添加到文本存储中。

 Now NSTextBlock by itself  doesn't do any custom drawing by  itself. So we'll need to subclass that  too. Our NSTextBlock subclass needs  to have some padding with some  extra padding on the top and a  light gray background. We'll override drawBackground  and use string drawing to draw  the header Swift Code. Now this is actually all we need  to do to make a text block look  like a code snippet. Now back in our custom text  storage, we can create an  instance of our new code block  instead of using a plain text  block. Now, last but not least, we need  to tell our text view to use one  of our custom text storages, so  we'll replace the text storage  on the layout manager. Now this is turning into a real  WYSIWYG Markdown editor.

> 现在NSTextBlock自己不做任何自定义绘图。所以我们也需要子类。我们的NSTETCBULL子类需要在顶部加上一些填充和浅灰色背景的填充。我们将重写Debug背景并使用String绘图来绘制标题SWIFT代码。现在，实际上我们需要做的就是让一个文本块看起来像一个代码片段。现在回到我们的自定义文本存储中，我们可以创建一个新代码块的实例，而不是使用纯文本块。现在，最后但并非最不重要，我们需要告诉文本视图使用一个自定义文本存储，所以我们将替换布局管理器上的文本存储。现在，它变成了真正的WYSIWYG降价编辑器。

 Now a popular feature of most  Markdown editor's is a  side-by-side view with an  editing version on the left and  a rendering on the right. Now we can do this with two text  views side-by-side. We'll disable editing for the  one on the right. And now we have two text views  but we want them to display the  same content but look a little  different on the right. So we want a configuration like  this where we have one text  storage but two of everything  else. To do this, we will replace the  text storage on the right with  that from the left. Now let's see what this looks  like. Now this is actually really  cool. If we add any characters to the  left, they'll show up  immediately on the right-hand  side. Now usually the right-hand side  doesn't really show the Markdown  characters but since this is a  shared text storage, it means we  have to hide the characters  during the layout process. Now since we need to do it this  way, we really only have one  option and that's to implement  the shouldGenerateGlyphs method  on the NSLayoutManager delegate. This will allow us to intervene  in the glyph generation process. So we can take the glyphs that  are about to be laid out and if  they represent a Markdown  control character, we can apply  the null property to that glyph. Now this will eliminate the  glyph altogether during the  layout process without changing  the underlying text storage. Then, we will use the new glyphs  and tell the layout manager that  we want to present these glyphs  with our new properties. Now this is actually really  cool. So the left-hand side shows an  editable version with all the  Markdown characters included. And the right-hand side shows no  Markdown characters all, all  using the same text storage. Now building a side-by-side  Markdown editor is not something  all of us do every day, but it  was really good to see how  customizable TextKit is with  real world examples. If you'd like to learn more  about how to use and customize  TextKit, check out our amazing  programming guides.

> 现在大多数Markdown编辑器的一个流行特性是并排视图，左边是编辑版本，右边是渲染。现在我们可以用两个文本视图并排做这件事。我们将禁用右边的编辑。现在我们有两个文本视图，但是我们希望它们显示相同的内容，但是在右边看起来有点不同。因此，我们需要这样的配置，在这里我们有一个文本存储，但其他两个。要做到这一点，我们将用左边的文本替换右边的文本存储。现在让我们看看这是什么样子。现在这真的很酷。如果我们在左边加上任何字符，他们会马上出现在右边。现在通常右手边没有显示Markdown字符，但是因为这是一个共享文本存储，这意味着我们必须在布局过程中隐藏字符。现在，因为我们需要以这种方式完成，所以实际上只有一个选项，那就是在NSLayoutManager委托上实现.GenerateGlyphs方法。这将允许我们介入字形生成过程。所以我们可以获取将要布局的字形，如果它们代表Markdown控制字符，我们可以对那个字形应用null属性。现在，这将在布局过程中完全消除字形，而不改变底层文本存储。然后，我们将使用新的字形并告诉布局管理器，我们想用新的属性呈现这些字形。现在这真的很酷。所以左边显示了一个可编辑的版本，包含了所有的标记字符。右边没有显示标记字符，都使用相同的文本存储。现在，构建一个并排的Markdown编辑器并不是我们每天都做的事情，但是看到TextKit如何与真实世界的例子进行定制，真的很棒。如果您想了解更多关于如何使用和定制TeTKIT，请查看我们惊人的编程指南。

 And with that, I will hand it  back to Donna.  Thanks, Emily. Those are some really cool  examples. And I really hope you'll be able  to take some of the techniques  that she showed off and use them  in your own apps. But now let's shift gears a bit  and talk about some best  practices for working with text. So on the topic of correctness,  if your text doesn't render the  way you expect, it could be  related to incomplete or  incorrect attributes on your  attributed string. And so let's take a look at an  example to see this in practice. Let's say we have a UITextView  with some attributed text that  says don't hate. And it says this in the font  Comic Sans 24 point. And we want to programmatically  apply a bold typeface to the  word don't because if there's  any font more universally hated  than Comic Sans, it's Comic Sans  bold. And so at first blush, it might  seem reasonable to write code  like this. Now here we have our original  font. And we're going to use a font  descriptor to create a bold  version of this original font. Then, we're going to initialize  our mutable attributed string  using the original text. We're going to apply our new  font or new bold font to the  word don't and that's going to  be the first five characters. And then we're going to set the  attributed text property of our  UITextView to use this new  attributed string except when we  do that we'll see that our new  bold font applied to the word  don't just as we expected but  the rest of the string somehow  lost the original font. And now those of you who despise  Comic Sans might be happy about  that, but the result is wrong  and so that warrants a sad face. So why did this happen?  And to answer that, let's take a  closer look at how we're  initializing our attributed  string. So notice that we're using a  plain text string to initialize  it, and we're using the  initializer with no attribute  information. And when you create a new  attributed string and you don't  provide any attribute  information, that new attributed  string, we use the default  attributes. And the default font is  Helvetica 12 point.

> 然后，我会把它交还给堂娜。谢谢，艾米丽。这些都是很酷的例子。我真的希望你能把她展示的一些技巧运用到你自己的应用程序中。但是现在让我们稍微改变一下，并讨论一些使用文本的最佳实践。因此，关于正确性的主题，如果您的文本没有呈现您期望的方式，那么它可能与属性字符串上的不完整或不正确的属性有关。因此，让我们来看看一个例子，在实践中看到这一点。假设我们有一个UITExtVIEW，有一些不讨厌的文本。它在字体漫画SANS 24点说。我们想用编程的方式给这个词加粗字体，因为如果有比Comic Sans更普遍讨厌的字体，那就是Comic Sans bold。因此，乍一看，编写这样的代码似乎是合理的。现在我们有了原来的字体。我们将使用一个字体描述符来创建这个原始字体的粗体版本。然后，我们将使用原始文本初始化可变的属性字符串。我们将把我们的新字体或新的粗体字体应用到单词“不”上，这将是前五个字符。然后，我们将设置UITextView的属性文本属性以使用这个新的属性字符串，除非当我们这样做的时候，我们将看到应用到单词的新粗体字体不像我们预期的那样，但是字符串的其余部分不知何故丢失了原来的字体。现在那些鄙视喜剧演员的人也许会为此感到高兴，但结果是错误的，所以这张脸让人伤心。那么为什么会发生这种情况呢？为了回答这个问题，让我们仔细看看我们是如何初始化属性字符串的。请注意，我们使用一个纯文本字符串来初始化它，并且我们使用没有属性信息的初始化器。当您创建一个新的属性字符串，而不提供任何属性信息，即新的属性字符串时，我们使用默认属性。默认字体是HelviTi 12点。

 And so to recap what happened,  we started with this original  attributed string with the font  Comic Sans 24 applied to the  entire range. And then we created this new  attributed string, and it got  initialized with the default  attributes. And we applied our bold font to  the word don't on this new  string, and we ended up with  this incorrect result here where  the word don't is in Comic Sans  bold 24, and the rest of the  string is in the default font of  Helvetica 12. And so there are two different  ways that we could do this  correctly and one way is to  avoid mixing the plain and  attributed text altogether. So by initializing our new  attributed string using the  original one, we're going to  keep those original attributes. And then we can apply our new  attributes without getting this  reset effect with the default  ones. But it's not always feasible to  just avoid mixing plain and  attributed text. So if you've got to mix it up,  you can explicitly supply the  attributes when creating that  new attributed string from the  plain text string. And if we make sure to apply the  same attributes from the  original text, we'll get the  correct result. But you should be aware that  this reset effect can happen  with any attributes that have  default values and not just  fonts. And as you can see, there are a  lot of attributes with default  values. So I'd like to call out the  paragraph style here in  particular as being a sneaky  reset point.

> 因此，为了重述所发生的事情，我们从这个原始属性字符串开始，字体为Comic Sans 24，应用于整个范围。然后我们创建了这个新的属性字符串，并用默认属性初始化了它。我们将粗体字体应用于这个新字符串上的单词don't，最后得到这个错误的结果，其中单词don't位于Comic Sans粗体24中，而字符串的其余部分是Helvetica 12的默认字体。因此，有两种不同的方法可以正确地做到这一点，一种方法是避免将普通文本和属性文本完全混合。因此，通过使用原始的初始化我们的新属性字符串，我们将保留那些原始属性。然后我们可以使用新属性，而不必使用默认的重置效果。但是避免混合纯文本和属性文本并不总是可行的。因此，如果您必须混合使用，那么您可以在从纯文本字符串创建新的属性字符串时显式地提供属性。如果我们确保从原始文本中应用相同的属性，我们将得到正确的结果。但是您应该知道，重置效果可以发生在具有默认值而不仅仅是字体的任何属性上。正如你所看到的，有很多缺省值属性。所以我想把这里的段落叫作是一个鬼鬼祟祟的重置点。

 And to see why, we'll revisit  our earlier example. But instead of changing the  font, we're going to change the  paragraph style to truncate the  word hate because nobody likes  hate. So we want our text to look like  this, but when we run this code,  we'll get a result like this  with all of the text in  Helvetica 12 and using the  default paragraph style with the  default line break mode of word  wrapping. And, again, this is really great  for those of you who loathe  Comic Sans because it's been  totally eliminated from the  string but it's wrong. And it's wrong in a different  way from last time. And to understand the  difference, let's recall that  attribute fixing happens before  layout and this is where the  system repairs the inconsistent  attributes. And so here in our attributed  string we have a single  paragraph with multiple  paragraph styles and that's  pretty inconsistent. So when the system fixes the  attributes of this string, it's  going to take the first  paragraph style it finds and  apply it to the entire  paragraph. And that's how we ended up with  our attributed string displaying  with the default paragraph  style. And the key take away here is to  be explicit with your  attributes, especially when  you're mixing plain and  attributed text. So by doing this, you're going  to avoid this reset effect with  the default attributes.

> 要知道为什么，我们将重新审视我们先前的例子。但是，我们不改变字体，而是改变段落样式，以截断hate这个词，因为没有人喜欢hate。所以我们希望我们的文本看起来像这样，但是当我们运行这段代码时，我们将得到这样的结果：Helvetica 12中的所有文本，并使用默认的段落样式，以及单词包装的默认换行模式。再说一遍，这对于那些讨厌《无名漫画》的人来说真的很棒，因为它已经完全从剧组中删除了，但是它错了。从上一次来看，这是错误的。为了理解其中的差异，让我们回想一下，属性修复发生在布局之前，这是系统修复不一致属性的地方。因此，在属性字符串中，我们有一个具有多个段落样式的单个段落，这非常不一致。因此，当系统修复这个字符串的属性时，它将采用它找到的第一个段落样式并将其应用于整个段落。这就是我们用默认段落样式显示属性字符串的原因。这里的关键是明确你的属性，特别是当你混合纯文本和属性文本时。通过这样做，您将避免默认属性的重置效果。

 And for AppKit developers, this  is actually super important if  you're updating your app for  dark mode. So by using the explicit  attributes with the dynamic  colors like NSColor.textColor,  you'll ensure that your text is  drawn with the correct colors  for the context. So moving on. The next topic is performance. If you're working with large  amounts of text, a good way to  improve your apps performance is  to use noncontinuous layout. And to understand what that  means, let's revisit our old  friend the layout process. We said that the layout process  consists of glyph generation  followed by glyph layout. And so with continuous layout,  the layout manager is going to  perform glyph generation and  glyph layout starting at the  beginning of the text storage. And it goes in order from the  beginning to the end. And so if someone using your app  scrolls to some point in the  middle of your text view, the  layout manager has to generate  and layout the glyphs for all  the glyphs that come before that  point as indicated by the red  rectangle. And note that this also includes  the text that you can't see  that's been scrolled off the top  of the screen all the way back  to the beginning of the text  storage. And so if you have a lot of  text, that poor person might  have to wait a while for your  app to finish layout but  luckily, we can avoid this  situation by using noncontinuous  layout. And so as the name implies, with  noncontinuous layout, the layout  manager doesn't have to do glyph  generation and layout in order  from the beginning of the text  storage. So now when that person, using  your app, scrolls to the middle  of your text view, the layout  manager can perform glyph  generation and layout for that  middle section right away. So if your text storage has a  lot of text in it, using  noncontinuous layout is a huge  performance win. Great. So how do you turn this  on?  Well, noncontinuous layout is a  property of NSLayoutManager. And so for NSTextView, you can  access the text to use layout  manager and then you can set  that property there. For UITextView, you usually  don't have to do anything  because this is turned on by  default, but there's just one  important thing to remember. Since UITextView is a subclass  of UIScrollView, noncontinuous  layout will require scrolling to  be enabled. And this is because when you  disable scrolling, asking for  the intrinsic content size of  your text view is going to  require laying out all the text  and then you wouldn't get the  performance benefits of  noncontinuous layout in the  first place. And that brings me to a really  important point. You should avoid requesting  layout for all or most of the  text at once when you're using  noncontinuous layout since that  kind of defeats the purpose of  using it in the first place. So if you have only one text  container, don't ask for the  layout of the entire thing. And don't ask for layout for  large ranges of characters or  glyphs that include the end of  the text. And we didn't dig too deeply  into the topic of text  performance here because I gave  a great talk on this last year  at WWDC 2017, Efficient  unteractions with Frameworks. And you can access the video  from that more information link  at the end of the session. All right. Now it's time to talk about  everyone's favorite topic,  security.

> 对于AppKIT开发人员来说，如果你在黑暗模式下更新你的应用程序，这是非常重要的。因此，通过将显式属性与动态颜色（如NS..text.）一起使用，可以确保您的文本是用上下文的正确颜色绘制的。所以继续前进。下一个主题是性能。如果使用大量文本，提高应用程序性能的一个好方法是使用非连续布局。为了理解这意味着什么，让我们重温我们的老朋友的布局过程。我们说布局过程由字形生成和字形布局组成。因此，对于连续布局，布局管理器将从文本存储开始执行字形生成和字形布局。它从头到尾都是有序的。因此，如果使用应用程序的人滚动到文本视图中部的某个点，布局管理器必须生成并布局出现在该点之前的所有符号的符号，如红色矩形所示。请注意，这还包括从屏幕顶部一直滚到文本存储开始时看不到的文本。因此，如果你有很多文本，那个可怜的人可能要等一会儿才能完成你的应用程序布局，但幸运的是，我们可以通过使用不连续的布局来避免这种情况。因此，顾名思义，对于非连续布局，布局管理器不必从文本存储开始就按顺序进行字形生成和布局。所以现在，当那个人使用您的应用程序滚动到文本视图的中间时，布局管理器可以立即为中间部分执行字形生成和布局。因此，如果你的文本存储中有很多文本，使用非连续布局是一个巨大的性能胜出。伟大的。那你怎么打开这个？非连续布局是NSLABOUT管理器的一个属性。因此，对于NSTextView，您可以访问文本以使用布局管理器，然后可以在那里设置该属性。对于UITextView，通常不需要做任何事情，因为这是默认打开的，但是只需要记住一件重要的事情。由于UITExtVIEW是UISCRelVIEW的子类，非连续布局将需要启用滚动。这是因为当您禁用滚动时，要求文本视图的内在内容大小将需要布局所有文本，然后您首先无法获得非连续布局的性能优势。这给我带来了一个非常重要的观点。在使用非连续布局时，应避免同时请求对所有或大部分文本进行布局，因为这种布局一开始就达不到使用它的目的。所以，如果你只有一个文本容器，不要要求整个事物的布局。不要要求大范围的字符或字形的布局，包括文本的结尾。我们在这里没有深入探讨文本性能的主题，因为我去年在WWDC 2017上做了一个很棒的演讲，是关于框架的有效竞争。您可以在会话结束时从更多的信息链接访问视频。好的。现在是时候谈谈每个人最喜欢的话题，安全问题。

 So you may have noticed that  there have been incidents in the  recent past where some people on  the Internet have exploited bugs  in our software to cause  problems for people who use our  products. And in response, we're  continuing to devise techniques  for mitigating these kinds of  attacks, but today I'd like to  talk about how we can work  together to provide a stronger  defense against these attacks. So you may have heard of the  concept defense in depth. And in case you're not familiar  with the terms, defense in depth  refers to creating multiple  layers of protection to defend  against threats. And this concept has been around  for centuries. You can see it in the design of  medieval castles. The land around the outside is  clear of trees so you can see  attackers coming. And there's a moat to make  approaching the castle more  difficult and to prevent  tunneling underneath it. And the walls are another  defense. They're built tall so that  they're difficult to climb. And there are arrow slits in the  walls and crenellations at the  top to allow defenders to fire  on attackers from protected  locations. Now any one of these individual  protections might not be enough  to fend off an attack but  collectively they provide a  strong defense. And like the castle, we here at  Apple provide multiple layers of  defense against attacks, but  there's nothing stopping you  from also taking your own  defensive measures in your app  or framework. And by doing this, you're adding  another layer of protection and  improving your product security. Everyone wins. So let's talk about what you can  do here. And something I'd like you to  consider is setting limits on  text input in your app or  framework. And now I'd like to emphasize  that this might not always make  sense to do.

> 所以你可能已经注意到，最近发生了一些事件，互联网上的一些人利用我们软件中的漏洞给使用我们产品的人带来问题。作为回应，我们正在继续设计减轻此类攻击的技术，但今天我想谈谈我们如何能够共同努力，为防范这些攻击提供更有力的防御。所以你可能已经听说过概念防御的深入。如果你不熟悉这些术语，深度防御是指创建多层保护来防御威胁。这个概念已经存在了几个世纪。你可以在中世纪城堡的设计中看到它。外面的土地是清晰的树木，所以你可以看到袭击者来。有一条护城河，使城堡更难接近，并防止隧道下穿。墙壁也是另一道防线。它们建造得很高，很难攀登。墙上有箭缝，顶部有凿岩，以便防御者从受保护的地方向攻击者开火。现在，这些单独的保护措施中的任何一种都不足以抵御攻击，但是它们共同提供了强大的防御。和城堡一样，我们在苹果公司提供多层的防御攻击，但是没有什么可以阻止你在你的应用程序或框架中采取自己的防御措施。通过这样做，你添加了另一层保护，提高了产品的安全性。人人都赢。让我们来谈谈你能在这里做什么。我想让你考虑的是在应用程序或框架中设置文本输入的限制。现在我想强调的是，这样做可能并不总是有意义的。

 So, for example, if your app is  an authoring tool like that  journal app that Emily showed  earlier, it wouldn't really make  any sense to set a limit on the  length of the text there. So if it doesn't make sense, you  shouldn't do it. But in contrast, if your phone  app has a text field for  assigning a nickname to an  account, you probably have some  idea what a reasonable limit  would be there. And it's a good idea to set  these limits because all text  input is potentially untrusted. When you allow text input, you  allow copy and paste. You don't know what kind of text  can be pasted in there. It could be anything. It could be a string with  malicious character  combinations, or it could just  be a string that's really,  really, really long. And even though long strings  like that may not be malicious  in themselves, it could cause  your app to freeze or hang. So if you have a text field  that's intended for one line of  input and someone pastes the  entire contents of "War and  Peace" into it, which is about  3.1 million characters in  English, is that reasonable?  Probably not. So this is a great example of a  case where it makes sense to  impose your own limits.

> 因此，例如，如果你的应用程序是像Emily早些时候展示的那种日志应用程序一样的创作工具，那么对文本的长度设置限制就毫无意义了。所以，如果它没有道理，你就不应该这么做。但是，相比之下，如果你的手机应用程序有一个文本字段用于给账户分配昵称，你可能会知道合理的限制是什么。设置这些限制是个好主意，因为所有的文本输入都是不可信的。当允许文本输入时，允许复制和粘贴。你不知道什么样的文本可以粘贴在那里。它可以是任何东西。它可能是一个带有恶意字符组合的字符串，或者它可能只是一个字符串，它真的，真的，真的很长。即使像这样的长字符串本身可能不是恶意的，它可能会导致你的应用程序冻结或挂起。因此，如果你有一个文本字段，用于一行输入，有人将“战争与和平”的全部内容粘贴到该字段中，这个字段大约有310万英文字符，这样合理吗？大概不会。所以，这是一个很好的例子，说明你有能力限制自己。

 And here are the recommended  approaches for setting these  kinds of limits. You want to validate the input  string before it's set on the  text field. And so for UITextFields, you can  do this by using  UITextFieldDelegate. And for NSTextFields, you should  use a custom NSFormatter to  implement your validation logic. Oh, and we've also got some  additional security enhancements  coming your way.

> 下面是设置这些限制的推荐方法。要在文本字段上设置输入字符串之前验证它。因此，对于UITextFields，可以使用UITExtFieldAdvutt来实现这一点。对于NSTextFields，您应该使用自定义的NSFATATER来实现验证逻辑。哦，我们也有一些额外的安全增强。

 So keep an eye out for them in  the release notes and come see  us at the labs this week if you  have any questions. All right. We're just about out of time so  let's recap. You know how to choose the right  control, customization point,  and customization approach and  you know the best practices to  follow in the areas of  correctness, performance, and  security. So use this knowledge to go  forth and create great things  with TextKit. Oh, and before you go, here's  that super important more  information link where you can  find all of the great past  sessions and documentation that  we've referenced today. And come visit us at the labs on  Thursday and Friday. Thank you and enjoy the rest of  the conference.

> 所以在发行笔记中留意他们，如果你有任何问题，本周在实验室见我们。好的。我们快过时了，让我们来回顾一下。您知道如何选择正确的控件、定制点和定制方法，并且您知道在正确性、性能和安全性方面遵循的最佳实践。所以用这些知识向前发展，用ToTKIT创造伟大的东西。哦，在你走之前，这里有一个超级重要的信息链接，你可以找到我们今天引用的所有过去的会议和文档。星期四和星期五在实验室拜访我们。谢谢你，享受会议的其余部分。

