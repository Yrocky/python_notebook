  Hello everybody. Thanks for coming out this  morning. I'm Louis Gerbarg. I work on the dyld Team, and  today we're going to talk about  App Startup, Past, Present and  Future. So we got a lot to go through,  so I'm just going to get into  it. So first off I want to do an  overview of what we're going to  be talking about today. So first we're going to review  some advice we gave from last  year. Then I want to talk about some  new tooling we've developed to  make finding certain types of  app startup time problems  easier. After that I want to take a side  tour into a brief history of  dyld on our platforms, and then  I want to discuss the all new  dyld that we're going to be  shipping in macOS High Sierra  and iOS 11.

大家好。谢谢你今天早上出来。我是Louis Gerbarg。我在DYLD团队工作，今天我们将讨论应用程序启动、过去、现在和将来。所以我们有很多事情要做，所以我就要去做了。首先，我想对我们今天要讲的内容做一个概述。所以我们首先回顾一下去年我们提出的一些建议。然后，我想谈谈我们开发的一些新工具，以便发现某些类型的应用程序启动时间问题更容易。在那之后，我想参加一个关于dyld在我们平台上的简短历史的侧记，然后我想讨论一下我们将在macOS High Sierra和iOS 11上发货的所有新dyld。

 And then finally, I want to talk  about best practices for this  new dyld. So before that I just want to do  a little bit of bookkeeping. So first off, we want your  feedback. So if you have anything you want  to tell us, please file bugs  with the title DYLD USAGE, and  hopefully they will get back to  us. And now I want to talk about  some terminology that I'm going  to use in the rest of this talk. So first off, what does startup  time mean?  And startup time for the  purposes of this talk means time  spent before main. Now, if you are writing an app,  you have to do more than that. After that happens, there will  be nib loading and other things  like that and you have codes to  run after you -- in UI  application delegates and what  not, but you have more  visibility into that and there  are many other talks about that. Today we just want to talk about  what happens before your main  executes and how you can speed  that up. Additionally, I want to define a  launch closure, and this is a  new term. And a launch closure is all of  the information necessary to  launch your application. So what dylibs it uses, what the  offsets in them are for various  symbols, where their code  signatures are. And with that, let's go into the  main body of the talk. So last year I said do less, and  I'm going to say that again this  year and I'm always going to say  that because the less you do,  the faster we can launch.

最后，我想谈谈这个新的DYLD的最佳实践。所以在那之前，我只想做一点记账。首先，我们需要你的反馈。所以，如果您有什么想告诉我们的，请用标题DYLD USAGE来归档bug，希望它们能回复我们。现在我想谈谈我在接下来的谈话中要用到的一些术语。首先，启动时间意味着什么？启动此会话的时间意味着花费在主体之前的时间。现在，如果你正在编写一个应用程序，你必须做更多的事情。在那之后，将会有nib加载和其他类似的事情，并且您有代码要跟随您运行——在UI应用程序委托中，等等，但是您对此有更多的可见性，并且还有许多其他的讨论。今天，我们只想讨论在你们的主要执行之前发生了什么，以及如何加快速度。另外，我想定义一个发射闭包，这是一个新的术语。启动关闭是启动应用程序所需的全部信息。因此，它使用什么样的DyLBS，它们的偏移量对于各种符号，它们的代码签名是什么。然后，让我们进入谈话的主体。所以去年我说少做，今年我再说一遍，我总是这么说，因为你做的越少，我们发射的速度就越快。

 And no matter how much we speed  things up, if we have less work,  it's going to go faster. And the advice is basically the  same. You should use fewer dylibs, if  you can, you should embed fewer  dylibs. System ones are better in  certain ways from a time  perspective, and we'll go into  that. You should declare fewer classes  and methods and you should run  fewer initializers. Finally, I'm going to tell you  you can do a little bit more of  something. You can use more Swift, and the  reason is Swift is designed in  such a way that it avoids a lot  of pitfalls that C, C++ and  Objective-C allow you to do. Swift does not have  initializers. Swift does not allow certain  types of misaligned data  structures that cost us time in  launch. So, in general, moving to Swift  will make it easier for you to  get very responsive app startup. So also, there are the Swift  size improvements and smaller is  better, so please move to this  new Swift that we've shipped  this year with the size  improvements and that's going to  help you out.

不管我们如何加快速度，如果我们的工作少了，它就会走得更快。这个建议基本上是一样的。你应该使用更少的DyLBS，如果你可以，你应该嵌入更少的DyLIB。从时间的角度来看，系统的方法在某些方面是更好的，我们将对此进行讨论。您应该声明较少的类和方法，并且应该运行更少的初始化器。最后，我要告诉你，你可以做更多的事情。您可以使用更快捷的方式，其原因是SWIFT是以这样的方式设计的，它避免了C、C++和ObjuleC允许您做的许多陷阱。SWIFT没有初始化器。SWIFT不允许某些类型的未对齐的数据结构花费了我们在发射时的时间。所以，一般来说，移动到SWIFT会让你更容易得到非常敏感的应用程序启动。所以，还有Swift尺寸的改进，更小更好些，所以请转到我们今年装运的Swift尺寸的改进，这将帮助您。

 So now let me talk about some  new tooling we have. So new in iOS 11 and macOS High  Sierra, we've added Static  Initializer Tracing to  Instruments. So, yes, this is pretty exciting  stuff because initializers are  code that have to run before  main to set up objects for you,  and you haven't had much  visibility into what happens  before main. So they're available through  Instruments and they provide  precise timing for each static  initializer. So with that, I'd like to go to  a demo right now. So over here I have an  application, and as most  applications at WWDC are, it's a  way of sharing cute pictures of  animals. So here, let me launch it. And, you know, it's taking a  little while here, but it's  still taking a while and it gets  up and we can see some  chinchillas and some cats. And so let's take a look at why  it took that time. So I'm going to go and I'm going  to rerun it under Instruments. So we'll stop the execution of  the current one and run it. And now if we go in, I'm going  to start with a blank template  and we can add the new Static  Initializer tool, which is right  there. And while we're at it, I'm also  going to add a Time Profiler  because it's always kind of nice  to see what's going on.

现在让我来谈谈一些新的工具。因此，在iOS 11和MaOS高Sierra中，我们向工具添加了静态初始化器跟踪。因此，是的，这是非常令人兴奋的事情，因为初始化程序是在main之前必须运行的代码，以便为您设置对象，并且您对main之前发生的事情没有太多可见性。因此，它们可以通过仪器获得，并且为每个静态初始化器提供精确的定时。因此，我现在想去演示一下。所以在这里我有一个应用程序，因为WWDC的大多数应用程序都是分享动物可爱图片的一种方式。所以，让我启动它。还有，你知道，这里要花点时间，但还要花点时间，它起床了，我们可以看到一些栗鼠和一些猫。让我们来看看为什么要花这个时间。所以我要走了，我要在仪器下重新运行它。因此，我们将停止执行当前的一个并运行它。现在，如果我们进入，我将从一个空白的模板开始，我们可以添加新的静态初始化工具，它就在那里。当我们在这里的时候，我还要添加一个时间分析器，因为它总是很好地看到发生了什么。

 There we go. Okay. So now that we have those,  let's start running our  application. So we're getting in our trace  data, and it's still not up, but  it just came up and as you can  see in the background there, we  had something fill in there. So I'm going to just zoom in so  you can get a look, and I have a  function there called  waitForNetworkDebugger, and  that's right, because I was  loading these off of an adjacent  feed that we had up on our site. I was trying to debug that. So let's go and -- I just want  to actually take a quick look  here in the CPU Usage tool. So you can see that that  initializer's roughly the same  length as my CPU usage. So if I go down there, I can  actually drill down into dyld,  and if I do that, we're actually  going to see what was taking all  that time, and that time is 9.5  seconds, 9.5 seconds into the  initializer. It's pretty deep. You don't usually have to do  this, but I want to show you  what's going on. And down in here I can finally  see waitForNetworkDebugger,  which is what we saw up in the  initializer call, but now it's  very easy for you to find that. So now that we've done that, I'm  going to go back over into Xcode  and, oh, yeah, that's the  waitForNetworkDebugger call that  I implemented. I implemented it in C because  Swift won't even let you do  something like this, which is  because this is a bad idea, but  I created a constructor there. So if I go back to my source  code -- if I go back to my  source code, I can just delete  that function because it was  just for debugging anyway. If I run it, my app's going to  come up almost instantly. So we just saw how to quickly  find what stack initializers are  causing you slowdowns. This will work across multiple  dylibs, including system dylibs  that may be taking a long time  because of inputs you've given  them, such as complicated nibs. It depends on new infrastructure  in High Sierra and iOS 11's  kernel and dyld, so you need to  be running the new builds to see  this.

我们走了。可以。现在我们有了这些，让我们开始运行我们的应用程序。所以我们正在获取跟踪数据，它仍然没有出现，但是它刚刚出现，正如您可以在背景中看到的，我们在那里填充了一些内容。所以我要放大，这样你就可以看看，我在那里有一个叫做waitForNetworkDebugger的函数，没错，因为我是从我们站点上相邻的提要中加载这些内容的。我试图调试它。让我们去，我只想在CPU使用工具中快速查看一下。因此，您可以看到初始化器的长度与CPU使用的长度大致相同。所以，如果我到那里，我可以深入到dyld，如果我那样做的话，我们实际上会看到，在初始化器中花费的时间，是9.5秒，9.5秒。它相当深。你通常不必这么做，但我想告诉你发生了什么事。在这里，我终于可以看到waitForNetworkDebugger，这是我们在初始化器调用中看到的，但是现在很容易找到它。现在我们已经完成了，我将回到Xcode中，哦，是的，这是我实现的waitForNetworkDebugger调用。我用C实现了它，因为Swift甚至不允许您做这样的事情，这是因为这是个坏主意，但是我在那里创建了一个构造函数。所以，如果我回到我的源代码——如果我回到我的源代码，我就可以删除那个函数，因为它只是为了调试。如果我运行它，我的应用程序几乎马上就会出现。因此，我们刚刚看到如何快速找到堆栈初始化器导致您减速。这将在多个dylib之间工作，包括系统dylib，因为您已经给它们提供了输入，比如复杂的nib，可能需要很长时间。这取决于High Sierra和iOS 11的内核和dyld中的新基础设施，所以您需要运行新的构建才能看到这一点。

 And it catches most initializers  now and there's some edge cases  we're still working on adding,  but we think this is going to  allow you to quickly find out  what is taking time during your  app launch so that you get  quicker, more responsive  application launches that will  make your users happy. Thank you. Okay. So now I said we'd do a  brief history of dyld. So Dynamic Linking Through the  Ages. So originally we shipped the  first dyld -- these didn't have  version numbers, but  retroactively we're giving them  them. And this was dyld 1 and it  shipped as part of NeXTStep 3.3  back in 1996. Before that, NeXT used static  binaries. And it's worth noting this  predates the POSIX dlopen calls  being standardized. Now, dlopen did exist on some  Unix. They were proprietary extensions  that later people adopted. And NeXTStep had different  proprietary extensions, so  people wrote third-party  wrappers on the early versions  of macOS 10 to support standard  Unix software. The problem was they didn't  quite support the same  semantics.

现在它抓住了大多数的初始化程序，还有一些我们仍在努力添加的优势情况，但是我们认为这将允许您快速地找出在应用程序启动期间需要花费的时间，以便您更快、响应性更强的应用程序启动，从而使您的用户更愉快。Py。谢谢您。可以。所以我说我们要做DyLD的简短历史。所以动态链接历代。所以最初我们运送了第一个DYLD，它们没有版本号，但是追溯性地我们给了它们。这是DYLD 1，它作为NeXSTEP 3.3的一部分在1996返回。在此之前，接下来使用静态二进制文件。值得注意的是，这之前的POSIX DLOPEN调用被标准化。现在，在某些UNIX上确实存在DLOPEN。它们是后来人们采用的专有扩展。NeXTStep有不同的专有扩展，因此人们在早期版本的MacOS10上编写了第三方包装来支持标准的Unix软件。问题是他们并不完全支持相同的语义。

 There were some weird edge cases  where it didn't work, and  ultimately they were kind of  slow. It also was written before most  systems used large C++ dynamic  libraries, and this is  important. C++ has a number of features,  such as how its initializer  ordering works. And one definition rule; they  work well in a static  environment, but are actually  fairly hard to do, at least with  good performance, in a dynamic  environment. So large C++ code bases cause  the dynamic linker to have to do  a lot of work and it was quite  slow. We also added one other feature  before we shipped macOS 10.0,  Cheetah, and that's called  prebinding. And for those of you in the  audience who know what  prebinding is, I know it was  kind of painful; and for the  rest of you, prebinding was a  technology where we would try to  find fixed addresses for every  dylib in the system and for your  application, and the dynamic  loader would try to load  everything at those addresses  and if it succeeded, it would  edit all of those binaries to  have those precalculated  addresses in it, and then the  next time when it put them in  the same addresses, it didn't  have to do any additional work. And that sped up launch a lot,  but it meant that we were  editing your binaries on every  launch, and that's not great for  all sorts of reasons, not the  least of which is security. So then came dyld 2, and we  shipped that as part of macOS  Tiger. And dyld 2 was a complete  rewrite of dyld. It had correct support for C++  initializer semantics, so we  slightly extended the mach-o  format and we updated dyld so  that we could get efficient C++  library support. It also has a full native dlopen  and dlsym implementation with  correct semantics, at which  point we deprecated the Legacy  API's. They are still on macOS. They have never shipped on any  of our other platforms. It was designed for speed and  because it was designed for  speed, it had limited sanity  checking.

有一些奇怪的边缘情况不起作用，最终它们有点慢。它也是在大多数系统使用大型C++动态库之前编写的，这一点很重要。C++具有许多特性，例如初始化器排序如何工作。还有一个定义规则：它们在静态环境中工作得很好，但在动态环境中，实际上很难做到，至少要有良好的性能。因此，大型C++代码库导致动态链接器不得不做大量的工作，而且速度相当慢。我们还添加了另一个特性，然后我们发送MaCMOS 10，猎豹，这就是所谓的预绑定。对于听众中那些知道预绑定的人来说，我知道这有点痛苦；对于你们其他人来说，预绑定是一种技术，我们将试图为系统中的每个dylib和您的应用程序找到固定的地址，并且动态加载器将尝试加载。所有地址都位于这些地址处，如果成功，它将编辑所有那些二进制文件，以便在其中包含那些预先计算的地址，然后下一次当它将它们放入相同的地址时，它不需要做任何额外的工作。这大大加快了启动的速度，但这意味着我们在每次启动时都编辑您的二进制文件，而且由于各种原因，这并不太好，尤其是安全性。然后DyLD 2来了，我们把它作为MaOS老虎的一部分。DYLD 2是DYLD的完全重写。它对C++初始化器语义有正确的支持，所以我们稍微扩展了MACH-O格式，并且我们更新了DYLD，这样我们就可以得到有效的C++库支持。它还有一个具有正确语义的完整的本机dlopen和dlsym实现，在这一点上，我们反对遗留API。他们从来没有在我们的其他平台上发货过。它是为速度而设计的，因为它是为速度设计的，它限制了理智的检查。

 We did not have the malware  environment we have today. It also has security issues  because of that, that we had to  go back and retrofit in a number  of features to make it safer on  today's platforms. Finally, because it was so much  faster we could reduce the  amount of prebinding. Rather than editing your  applications, we just edited the  system libraries and we could do  that just at software update  times. And if you've ever seen the  phrase optimizing system  performance appear in your  software update, that was added  to the installer to be displayed  during the time we were updating  prebinding. Nowadays it is used for all the  optimizations, but that was the  impetus. So we shipped dyld 2 back then  and we've done a number of  improvements over the years,  significant improvements. First off, we've added a ton of  more architectures and  platforms. Since dyld 2 shipped on PowerPC,  we've added x86, x86 64 arm,  arm64, and a number of  subvariants of those. We've also shipped iOS, tvOS,  and watchOS, all of which  required significant new work in  dyld. We've improved security in a  number of ways. We added codesigning support, we  added some for ASLR, which is a  technology Address Space Layout  Randomization, which means that  every time you loaded the  libraries it may be at a  different address. If you want more details on  that, last year's talk where  Nick went into extreme detail on  how we launch an app, goes into  that. And finally, we added a  significant bounds checking to a  number of things in the mach-o  header so that you couldn't do  certain types of attach with  malformed binaries.

我们没有今天的恶意软件环境。由于这个原因，它还存在安全问题，因此我们不得不对许多特性进行回顾和改进，以使其在当今的平台上更安全。最后，因为它快得多，我们可以减少预绑定的数量。我们不是编辑应用程序，而是编辑系统库，我们可以在软件更新时这样做。如果你曾经看到过优化系统性能这个短语出现在你的软件更新中，那就是在我们更新预绑定时添加到安装程序中显示的。如今，它被用于所有的优化，但这是动力。因此，我们发货DyLD 2当时，我们已经做了一些改进，这些年来，显著改善。首先，我们增加了更多的架构和平台。自从DyLD 2在PowerPC上发运以来，我们增加了x86、x86 64 ARM、ARM64和一些子变体。我们还运送了iOS、TVOS和WATOCHS，所有这些都需要DYLD中的重大新工作。我们通过多种方式提高了安全性。我们添加了代码签名支持，我们添加了一些用于ASLR，这是一种地址空间布局随机化的技术，这意味着每次加载库时，它可能位于不同的地址。如果你想了解更多这方面的细节，在去年的谈话中，Nick谈到了我们如何发布应用程序的极端细节。最后，我们对mach-o报头中的许多内容添加了重要的边界检查，以便您不能用格式错误的二进制文件执行某些类型的连接。

 Finally, we improved  performance, and because we  improved performance, we could  get rid of prebinding and  replace it with something called  the shared cache. So what is the shared cache?  Well, it was introduced in iOS  3.1 and macOS Snow Leopard, and  it completely replaced  prebinding. It's a single file containing  most of the system dylibs. And because we merged them into  a single file, we can do certain  types of optimizations. We can rearrange all of their  text segments and all of their  data segments and rewrite their  entire symbol tables to reduce  the size and to make it so we  need to mount fewer regions in  each process. It also allows us to pack binary  segments and save a lot of RAM. It effectively is a prelinker  for the dylibs. And while I'm not going to go  into any particular  optimizations here, the RAM  savings are substantial. On an average iOS system, this  is the difference in about 500  megs to a gigabyte of RAM at  runtime. It also prebuilds data  structures that dyld and Ob-C  are going to use at runtime so  that we don't have to do it on  launch. And again, that saves more RAM  and a lot of time. It's built locally on macOS, so  when you see optimizing system  performance, we are running  update dyld shared cache, among  things that happen, but on all  of our other platforms we  actually build it at Apple and  ship it to you. So now that I've talked about  the shared cache, I want to move  into dyld 3. dyld 3 is a brand-new dynamic  linker, and we're announcing it  today. It's a complete rethink of how  we do dynamic linking and it's  going to be on by default for  most macOS system apps in this  week's seed, and it will be on  by default for all system apps  on 2017 Apple OS platforms. We will completely replace dyld  2 in future Apple OS platforms  for all third-party apps as  well. So why did we rewrite the  dynamic linker again?  Well, first off, performance. In case that's not a recurring  theme, we want every ounce of  launch speed we can get. Additionally, we thought what is  the minimum, what is the  theoretical minimum that we  could do to get an app up and  running and how could we achieve  that. Security. So as I said, we  retrofitted a number of security  features into dyld 2, but it's  really hard to add that kind of  stuff after the fact.

最后，我们改进了性能，并且由于我们改进了性能，所以我们可以摆脱预绑定，用称为共享缓存的东西替换它。那么共享缓存是什么呢？它在iOS 3.1和MaOS雪豹中被引入，它完全取代了预绑定。它是包含大多数系统DyLIB的单个文件。因为我们将它们合并成一个文件，所以我们可以进行某些类型的优化。我们可以重新安排它们的所有文本段和它们的所有数据段，并重写它们的整个符号表，以减小其大小并使之变小，因此我们需要在每个过程中安装更少的区域。它还允许我们打包二进制段并节省大量RAM。它实际上是DyLIB的预链接器。虽然我不打算在这里进行任何特定的优化，但是RAM的节省是很重要的。在平均iOS系统上，这是运行时大约500兆字节到千兆字节RAM的差值。它还构建了DyLD和OB-C将在运行时使用的数据结构，这样我们就不必在启动时执行它。而且，这节省了更多的RAM和大量的时间。它是在macOS上本地构建的，所以当你看到优化系统性能的时候，我们正在运行更新的dyld共享缓存，当然还有可能发生的事情，但是在我们所有其他平台上，我们实际上是在苹果公司构建的，并将其交付给你。现在我已经讨论了共享缓存，我想移入DyLD 3。DYLD 3是一个全新的动态链接器，我们今天宣布它。这是对我们如何进行动态链接的完全反思，在本周的种子版中，大多数MacOS系统应用默认都会打开动态链接，2017苹果OS平台上的所有系统应用默认都会打开动态链接。我们将完全取代DyLD 2在未来的苹果OS平台的所有第三方应用程序。那么为什么我们要重写动态链接器呢？首先，演出。如果这不是一个重复的主题，我们希望每盎司的发射速度，我们可以得到。此外，我们还想了什么是最低限度，我们能够为启动和运行应用程序所做的理论上的最低限度是什么，以及我们如何实现这一点。安全性。正如我所说，我们对dyld 2进行了许多安全特性的改进，但事实上很难添加这样的内容。

 I think we've done a good job  with it in recent years, but  it's really, really difficult to  do that. And so can we have more  aggressive security checking and  be designed for security up  front?  Finally, testability and  reliability. Can we make dyld easier to test?  So Apple ships a ton of great  testing frameworks, like XCTest,  that you should be using, and we  should be using, but they depend  on low level features of dynamic  linker to insert those libraries  into processes, so they  fundamentally cannot be used for  testing the existing dyld code,  and that also makes it harder  for us to test security and  performance features. And so how did we do that?  Well, we've moved most of dyld  out of process. It's now mostly just a regular  daemon and we can test that just  like everybody else does with  standard testing tools, which is  going to allow us to move even  faster in the future in  improving this. It also lets the bit of dyld  that stays in process be as  small as possible and that  reduces the attack surface in  your applications. It also speeds up launch because  the fastest code is code you  never write, followed closely by  code you almost never execute. So to tell you how we did this  I'm going to briefly show how  dyld 2 launches an app. And again, we went into this in  much more detail in last year's  talk, Optimizing App Startup  Time, so if you want to pause,  if you're watching this on  video, and go watch that, that  might be a good idea. Or if you just want to follow  along here, I'm going to go  through it briefly. So first off we have dyld 2 and  your app starts launching. So we have to parse your mach-o,  and as we parse your mach-o we  find what libraries you need,  and then they may have other  libraries that they need, and we  do that recursively until we  have a complete graph of all  your dylibs, and for an average  graph of application on iOS  that's between 3- and 600  dylibs, so it's a lot of them  and a lot of work.

我认为最近几年我们做得很好，但是真的很难做到。那么，我们可以进行更积极的安全检查并为安全起见而设计吗？最后，可测试性和可靠性。我们能让DLLD更容易测试吗？因此，苹果公司发布了大量优秀的测试框架，比如XCTest，您应该使用它们，我们也应该使用它们，但它们依赖于动态链接器的低级特性来将这些库插入到进程中，因此它们根本不能用于测试现有的dyld代码。这也使得我们更难测试安全性和性能特性。那么我们是怎么做到的呢？好吧，我们已经把DYLD大部分移走了。现在，它基本上只是一个普通的守护进程，我们可以像其他人一样使用标准测试工具进行测试，这将允许我们在将来以更快的速度改进它。它还允许保持进程的dyld位尽可能小，从而减少应用程序中的攻击面。它也加快了发射速度，因为最快的代码是你从不写的代码，紧跟着你几乎从不执行的代码。因此，告诉你我们是如何做到这一点的，我将简要展示DyLD 2是如何启动一个应用程序的。在去年的演讲“优化应用程序启动时间”中，我们再次对此进行了更详细的讨论，所以如果你想停下来，如果你正在视频中观看，去看看，那可能是个好主意。或者，如果你只想跟在这里，我将简要地介绍一下。所以首先我们有DYLD 2和你的应用程序开始启动。所以我们要为您解析Mach-O，当我们为您解析Mach-O我们找到您需要的库，然后他们可能有其他的图书馆，他们需要的，我们这样做，我们有一个完整的图递归直到你所有dylibs，为3的iOS应用之间的平均图-还有600个DyLBS，所以很多，还有很多工作。

 We then map in all the mach-o  files so we get them into your  address space. We then perform symbol lookups,  so we actually look and say if  your application uses printf, we  go and look and see that printf  is in lib system, and we find  the address of it and we  basically copy that into a  function pointer in your  application. Then we do what's called binding  and rebasing, which is where we  copy those pointers in and we  also -- because you're at a  random address all of your  pointers have to have that base  address added to them. And then finally, we can run all  of your initializers, which is  what I showed the tooling for  earlier, and at that point we're  ready to call your main in  launch, and that's a lot of  work. So how can we make this faster  and how can we move it out of  process?  Well, first off we identify the  security sensitive components. And from our perspective the  biggest ones of those are  parsing mach-o headers and  finding dependencies because  malformed mach-o headers allow  people to do certain attacks and  your applications may use  @rpaths, which are search paths,  and by malforming those or  inserting libraries in the right  places, people can subvert  applications. So we do all of that out of  process in the daemon, and then  we identify the expensive parts  of it, which are cache-able, and  those are the symbol lookups. Because in a given library,  unless you perform the software  update or change the library on  disk, the symbols will always be  at the same offset in that  library. So we've identified these. Let me show you how they look in  dyld 3.

然后我们在所有的MACH-O文件中映射，这样我们就把它们放进你的地址空间。然后，我们执行符号查找，所以我们实际上查找并判断您的应用程序是否使用printf，我们查找并查看printf在lib系统中，然后我们找到它的地址，并且基本上将其复制到应用程序中的函数指针中。然后我们进行所谓的绑定和重新绑定，这就是我们复制这些指针的地方，我们也是.——因为您处于一个随机的地址，所以所有指针都必须添加那个基本地址。最后，我们可以运行您的所有初始化程序，这是我前面介绍的工具，此时，我们已经准备好在启动时调用您的main，这需要做很多工作。那么，我们怎样才能更快地实现这一目标，如何将其从过程中移开呢？首先，我们识别安全敏感组件。从我们的角度来看，其中最大的一个是解析mach-o报头和查找依赖项，因为格式错误的mach-o报头允许人们进行某些攻击，并且您的应用程序可以使用@rpaths，这是搜索路径，以及通过将这些库错误形成或在ri中插入库。GHT的地方，人们可以颠覆应用程序。因此，我们在守护程序中进行所有这些非进程操作，然后我们识别其中昂贵的部分，它们是可高速缓存的，并且这些是符号查找。因为在给定的库中，除非您执行软件更新或更改磁盘上的库，否则该库中的符号将始终处于相同的偏移量。所以我们已经确定了这些。让我给你们看看它们在3号的外观。

 So we moved those all up front,  at which point we write a  closure to disk. So as I said earlier, a launch  closure is everything you need  to launch the app. And then we move it -- we can  use that in process later. So dyld 3 is three components. It's an out-of-process mach-o  parser and compiler. It's an in-process engine that  runs launch closures, and it's a  launch closer caching service. Most launches use the cache and  never have to invoke the  out-of-process mach-o parser or  compiler. And launch closures are much  simpler than mach-o. They are memory map files we  don't have to parse in any  complicated way. We can validate them simply.

所以我们把所有的都移到前面，在这一点上我们给磁盘写了一个闭包。正如我之前说过的，启动关闭是启动应用程序所需的一切。然后我们移动它——我们可以在以后使用它。因此DYLD 3是三个分量。这是一个进程外的MACH-O解析器和编译器。这是一个正在运行的引擎，运行启动闭包，这是一个更近的缓存服务。大多数启动使用缓存，而不必调用进程外的MACH-O解析器或编译器。启动闭包比MACH-O要简单得多，它们是内存映射文件，我们不必以任何复杂的方式进行解析。我们可以简单地验证它们。

 They are built for speed. And so let's talk about each one  of those parts a little bit  more. So dyld 3 is an out-of-process  mach-o parser. So what does that do?  It resolves all the search  paths, all the rpaths, all the  environment variables that can  affect your launch. Then it parses the mach-o  binaries and it performs all of  those symbol lookups. Finally, it creates the closure  with the results, and it's that  normal daemon so that we can get  that improved testing  infrastructure. dyld is a small in-process  engine as well, and this is the  part that will be in your  process and this is what you  will mostly see. So all it does is it validates  that the launch closure is  correct and then it just maps in  the dylibs and jumps to main. And one of the things you may  notice is it never needs to pars  a mach-o header or perform a  symbol lookup. We don't have to do those to  launch your app anymore. And since that's where we're  spending most of our time, it's  going to result in much faster  app launches for you. Finally, dyld 3 is a launch  closure caching service. So what does that mean?  Well, system app closures we're  just building directly into the  shared cache. We already have this tool that  runs and analyzes every mach-o  in the system. We can just put them directly  into the shared cache, so it's  mapped in with all the dylibs to  start with. We don't even need to open  another file. For third-party apps we're going  to build your closure during app  install or system updates  because at that point the system  library has changed. So by default these will all be  prebuilt for you on iOS and tvOS  and watchOS before you even run. On macOS, because you can side  load applications, the  in-process engine can RPC out to  the daemon if necessary on first  launch, and then after that it  will be able to use a cached  closure just like everything  else. But like I said, that is not  necessary on any of our other  platforms.

它们是为了速度而建造的。所以让我们来讨论一下其中的每一个部分。因此DYLD 3是一个进程外的MACH-O解析器。那怎么办呢？它解决所有的搜索路径，所有的RPATH，所有可能影响你的启动的环境变量。然后它解析MACH-O二进制文件，并执行所有这些符号查找。最后，它用结果创建闭包，它是正常守护进程，这样我们就可以得到改进的测试基础设施。DYLD也是一个小型的过程引擎，这是在你的过程中的一部分，这就是你将看到的。所以它所做的就是验证发射关闭是正确的，然后它只是在DyLIB中映射并跳转到主。你可能注意到的一件事是它不需要分派一个MACH-O头或执行一个符号查找。我们不必再做这些来启动你的应用程序了。因为这是我们花费大部分时间的地方，这将导致更快的应用程序启动。最后，DyLD 3是一个启动闭包缓存服务。那么这意味着什么呢？嗯，系统应用程序关闭，我们只是直接构建到共享缓存中。我们已经有这个工具运行和分析系统中的每一个Mac -O。我们可以把它们直接放入共享缓存中，这样就可以用所有DyLIB来映射。我们甚至不需要打开另一个文件。对于第三方应用程序，我们将在应用程序安装或系统更新期间建立闭包，因为此时系统库已经更改。因此，默认情况下，这些都将为您在iOS、TVOS和WATCHOs之前预构建。在MaOS上，因为你可以边加载应用程序，如果需要在第一次启动时，进程内引擎可以将RPC输出到守护进程，然后它就可以像其他任何一样使用缓存的闭包。但就像我说的那样，在其他任何平台上都是不必要的。

 So now that I've talked about  this dynamic linker that we'll  be using for system apps this  year and for your apps in the  future, I want to talk to you  about some potential issues you  might see with it so that you  can start updating your apps for  it now. So first off, it is fully  compatible with dyld 2.x. So  some existing API's will cause  you to run slower or use  fallback modes in dyld 3 though,  so we'd like you to avoid those,  and we'll go into those in a  second. Also, some existing  optimizations that you are doing  may not be necessary anymore, so  you don't have to rip them out  but, you know, it may not be  worth putting in a lot of  effort. The other thing I want to talk  about is that we're going to  have stricter linking semantics. So what do I mean by that?  Well, there's a lot of things  that maybe work most of the  time, but aren't actually  correct even today and so we've  identified a lot of those. As we've been putting the new  dynamic linker in, that tends to  find all these edge cases.

现在我已经谈到了这个动态链接器，我们今年将用于系统应用程序和将来用于您的应用程序，我想与您讨论一些您可能看到的潜在问题，以便您现在可以开始为它更新应用程序。首先，它与dyld 2.x完全兼容。因此，一些现有的API将使您在dyld 3中运行得更慢或使用回退模式，所以我们希望您避免这些模式，并且我们将在一秒钟内讨论它们。此外，您正在做的一些现有优化可能不再是必须的，因此您不必将它们拆卸掉，但是，您知道，可能不值得投入大量精力。我想谈的另一件事是我们将有更严格的连接语义。那么，我的意思是什么？嗯，很多事情在大部分时间里可能都管用，但实际上今天还不正确，所以我们已经确认了很多。正如我们已经把新的动态链接器，往往会发现所有这些边缘情况。

 So what we've been doing is  we've been putting in  workarounds for old binaries,  but we do not intend to carry  those forward. We will do linked on or after  checks to see what SDK you were  built with and we will disable  those workarounds for new  binaries so that you move to  these improved -- you fix these  issues. So new binaries will cause  linker issues. So, first off, I want to talk  about unaligned pointers in your  data segments. So what do I mean by this?  Well, when you have a global  structure that points to a  function or another global  structure, that's a pointer that  we have to fix up before you  launch, and pointers must be  naturally aligned on our system  for best performance. And fixing up unaligned pointers  is much more complex. They can span multiple pages,  which can cause more page faults  and other issues, and they can  have atomicity issues related to  multiprocessors. The static linker already emits  a warning for this, ld warning,  pointer not aligned at address,  and that's an address, often  your data segments. And if you're fixing all  warnings, you should --  hopefully you've already taken  care of this. The seeds that we have out this  week have some issues with Swift  keypaths, but they will be fixed  so you can ignore those, but  other than that, please go and  fix these issues. So for those of you who are  asking how would you get  something like this, I'm going  to just show you real quick. If you don't know how, it takes  a lot of work.

所以我们一直在做的是，我们已经为旧二进制文件提供了解决方案，但是我们并不打算把这些二进制文件转发出去。我们将在检查之上或检查之后进行链接以查看您是使用什么SDK构建的，我们将禁用那些用于新二进制文件的变通方法，以便您转到这些改进的地方.——您可以修复这些问题。因此，新的二进制文件会导致链接器问题。首先，我想谈谈你的数据段中未对齐的指针。那么我的意思是什么呢？嗯，当你有一个指向一个函数或者另一个全局结构的全局结构时，这是一个指针，在你启动之前，我们必须先修好，指针必须自然地在我们的系统上对齐，才能达到最佳性能。修复未对齐的指针要复杂得多。它们可以跨越多个页面，这会导致更多的页面错误和其他问题，并且它们可能具有与多处理器相关的原子性问题。静态链接器已经为此发出了警告，ld警告，不在地址处对齐的指针，这是一个地址，通常是数据段。如果你正在修正所有的警告，你应该——希望你已经注意到了。我们这周发布的种子有一些关于Swift键路径的问题，但是它们将被修复，所以您可以忽略它们，但是除此之外，请去修复这些问题。所以对于那些问你如何得到这样东西的人，我会很快的告诉你们。如果你不知道怎么做，那就需要很多的工作。

 You can't do it in Swift. So again, use more Swift. This code here will do it, so  let me show you what's going on. First off, I have attributes  forcing specific alignment. So by default the compiler's  going to align it correctly for  you. But sometimes you may need  special alignments and this case  I've said change whatever the  default alignment rules are to  one, and I've done that in two  different ways just to be  really, really bad, so you have  to fix both of these. Then I constructed a global  variable. That global variable sets a  pointer in with the structures  and that's going to force the  dynamic linker to fix up that  pointer on launch. So if you see code like this,  you can just remove the  alignments. You could rearrange the  structure so that the pointer  goes first, because that's a  better alignment thing. And there's plenty of guides  online about C structure  alignment if you want to get  into the nitty-gritty, but  hopefully you don't have to deal  with this, and if you write  Swift, you definitely don't have  to.

你不能在斯威夫特做这件事。所以，再次使用更快。这里的代码可以做，所以让我告诉你发生了什么。首先，我有强制特定对齐的属性。默认情况下编译器会为你正确地对齐它。但有时您可能需要特殊对齐，这种情况下，我说过无论默认对齐规则是什么，都要更改为一，并且我用两种不同的方式进行了更改，只是为了变得非常非常糟糕，所以您必须修复这两者。然后构造了一个全局变量。该全局变量将指针与结构一起设置，这将迫使动态链接器在启动时修复该指针。因此，如果你看到这样的代码，你可以删除对齐。您可以重新排列结构，以便指针先行，因为这是一个更好的对齐方式。如果你想深入了解C结构的细节，网上有很多关于C结构对齐的指南，但是希望您不必处理这个，并且如果您编写Swift，您肯定不必。

 So next off, eager symbol  resolution. So what do I mean by this?  So dyld 2 performs what we call  lazy symbol resolution. So I said up front that dyld has  to load all those symbols and  that's something expensive that  we want to cache. It's actually too expensive to  run up front on existing  applications. It would take too long. So instead, we use a mechanism  we call lazy symbol resolution,  where, by default, the function  pointer in your binary for,  let's say, printf, doesn't point  to printf. By default it points to a  function in dyld that returns a  function pointer to printf. And so when we launch, you'll  call printf, it goes into dyld,  we return what we call the  printf and call it on your  behalf the first time and then  on the second time you go  straight to printf. But since we are caching and  calculating all these symbols up  front now, there's no additional  cost at app launch time to find  them all up front, so we are  going to do that. Now, having said that, missing  symbols behave differently when  you do this. On existing lazy systems, if you  are missing a symbol, the first  call -- you'll launch correctly  and the first time you call that  symbol, you'll crash. With eager symbols you'll crash  up front. So we do have a compatibility  mode for this, and the way we're  going to do that is that we are  going to just have a symbol  inside dyld 3 that automatically  crashes, and if we can't find  your symbol, we will bind that  symbol, so on first call you  will crash. But again, that's how it works  on today's SDK. If future SDK's we are going to  force all symbol resolution to  be up front. So if you are missing a symbol,  you will crash, and that should  hopefully result in you  discovering crashes during  development instead of your  users discovering them at  runtime.

所以下一步，急于符号分辨率。那么我的意思是什么呢？所以DYLD 2执行我们所说的懒惰符号解析。所以我前面说DYLD必须加载所有这些符号，这是我们想要缓存的昂贵的东西。它实际上太昂贵，无法在现有的应用程序上运行。这要花太长时间。因此，我们使用一种称为惰性符号解析的机制，其中默认情况下，二进制文件中的函数指针（例如，printf）不指向printf。默认情况下，它指向DyLD中返回一个函数指针到PrtTf的函数。因此，当我们启动时，您将调用printf，它进入dyld，我们返回我们所谓的printf，并且第一次代表您调用它，然后第二次直接调用printf。但是，由于我们现在正在预先缓存和计算所有这些符号，所以在应用程序启动时没有额外的成本来预先找到它们，所以我们将这样做。现在，当你这样做时，缺失符号的行为不同。在现有的惰性系统中，如果缺少一个符号，则第一次调用——将正确启动，而第一次调用该符号时，将崩溃。用渴望的符号你会在前面崩溃。所以我们确实有一个兼容模式，这样做的方式是，我们只要在dyld 3内部有一个自动崩溃的符号，如果我们找不到您的符号，我们就绑定那个符号，所以第一次调用您就会崩溃。但是，这也是今天SDK的工作原理。如果未来SDK的，我们将强制所有符号分辨率是最前面的。因此，如果您丢失了一个符号，那么您将崩溃，并且希望这会导致您在开发期间发现崩溃，而不是让用户在运行时发现它们。

 And you can simulate that  behavior now today. There's a special linker flag  which is dyld bind at load, so  if you add this to your debug  build, as I said, it's much  slower, so please only put it in  your debug builds, but add this  to your debug builds and you'll  get more reliable behavior today  and it will get you ready for  what we're going to be doing in  dyld 3. Again, only use that in your  test builds. Dlopen, dlsym and dladdr. So last year I got up here and  said please don't use them  unless you have to, but we  understand that you may have to,  and that's the same thing I'm  saying this year. They have some problematic  semantics, but they are still  necessary in some cases. Particularly, symbols found with  dlsym, we need to find it at  runtime. We don't know ahead of time what  they are. We can't do all that prefetching  and presearching. So as soon as you use dlopen or  dlsym, we're going and we're  reading in all the pages for  your symbol table that we didn't  have to touch before. So it's going to be a lot more  expensive. Additionally, we might have to  RPC out to the daemon, depending  on how complicated it is. So we're working on some better  alternatives. We don't have those yet.

现在你可以模拟这种行为。有一个特殊的链接器标志，在加载时是dyld绑定的，所以如果你把这个添加到你的调试构建中，就像我说的，它要慢得多，所以请只把它放在你的调试构建中，但是把这个添加到你的调试构建中，你今天会得到更可靠的行为，它会让你准备好我们所要做的。将在DYLD 3做。同样，只在测试中使用。Dlopen，DLSIMM和DLADDR。所以去年，我到这里说，除非你非要用，否则请不要使用它们，但是我们理解你可能非要用，这和我今年说的是一样的。他们有一些问题的语义，但它们仍然是必要的，在某些情况下。特别是，用DLySM发现的符号，我们需要在运行时找到它。我们不知道他们是什么样的人。我们不能做所有的预取和预处理。所以只要您使用dlopen或dlsym，我们就会去阅读以前不必触摸的符号表的所有页面。所以要贵很多。另外，我们可能不得不根据Doimon的复杂程度来将它释放给守护进程。所以我们正在做一些更好的选择。我们还没有这些。

 But we also need to hear about  your use cases to make sure  we're designing something that  will work for you. So please, again, they're not  going away, but they will be  slower and we want your  feedback. I want to take a second to talk  about dlclose specifically. And so dlclose is a bit of a  misnomer. It's a Unix API, so that's the  name, but on our system, if we  had been writing it, it probably  would be called dlrelease  because it doesn't actually  close the dylib. It decrements a refcount and if  the refcount hits zero, it  closes it. And why is that important?  Well, it's not appropriate for  resource management. If you have a library that  attaches to a piece of hardware,  you shouldn't shut down the  hardware in response to a  dlclose because some other code  in your app may have opened it  behind your back and so now your  hardware's not shutting down. You should have explicit  resource management. There are also a number of  features on our platforms that  prevent dylibs from unloading,  and I'd like to go through a few  of those because maybe you do  them. You can have Objective-C classes  in your dylib.

但是我们也需要听到你的用例来确保我们设计出能为你工作的东西。所以，请再说一遍，它们不会消失，但它们会变慢，我们需要你的反馈。我想用一秒钟的时间来具体谈谈DLHORD。所以DLCOND有点误入歧途。它是一个Unix API，所以这就是它的名字，但是在我们的系统中，如果我们正在编写它，它可能会被称为dl.，因为它实际上没有关闭dylib。它减少了ReQueCo，如果ReFoCo达到零，它就关闭它。为什么这么重要？嗯，它不适合于资源管理。如果您有一个连接到硬件的库，那么就不应该响应dlclose关闭硬件了，因为应用程序中的其他一些代码可能在您的背后打开了它，所以现在您的硬件没有关闭。你应该有明确的资源管理。我们的平台上还有许多特性可以防止dylibs卸载，我想介绍其中的一些特性，因为您可能需要这样做。您可以在DyLIB中使用ObjtoE-C类。

 That will make it not  unloadable. You could have Swift classes. That will also make it not  unloadable. And you can have C under bar  thread or C++ thread local  variables, all of which make it  impossible to unload a dylib. So on macOS, where there's a  number of existing Unix apps,  obviously we will keep this  working, but because almost  every dylib on all of our other  platforms does one of these  things, effectively it hasn't  really worked on any of them  ever. So we are considering making it  just a straight up no-op, that  will not do anything on any of  those platforms. If there's a reason why that's a  problem, please, we want to hear  about it. Finally, I want to talk about  the dyld all image infos. So this is an interface for  introspecting dylibs in a  process, and it comes from the  original dyld 1. But it's just a struct in  memory, it's not an API, and  that was okay when we had five,  ten dylibs. But as we've gotten to 300, 400,  500 dylibs, the way it's  designed wastes a lot of memory,  and we want that memory back.

这将使它无法卸载。你可以快速上课。这也会使它无法卸载。并且可以在C线程或C++线程局部变量下设置C，所有这些都使得卸载DyLIB变得不可能。因此，在macOS上，有很多现有的Unix应用程序，显然我们会继续工作，但是因为几乎所有其他平台上的dylib都做这些事情之一，实际上它从来没有真正对它们进行过工作。因此，我们正在考虑让它成为一个直截了当的NOP，这将不会在任何平台上做任何事情。如果这是一个问题的原因，请，我们想听听。最后，我想谈谈DyLD的所有图像信息。这是一个在进程中内省DyLIB的接口，它来自原始DYLD 1。但它只是内存中的一个结构，它不是API，当我们有五、十个DyLIB时就没问题了。但是，当我们得到300, 400, 500个DyLIB时，它的设计方式浪费了大量的内存，我们希望内存返回。

 We always want our performance  and we always want our memory. So we're going to take it away  in future releases, but we will  be providing replacement API's  for it. And so it's very rarely used,  but if you're using it, again, I  want to know why you're using it  and how you're using it and make  sure we design API's that fit  your use case. There are a number of bits of it  that are vestigial and don't  quite do what you expect or work  anyway today, so if you aren't  using those, they may just go  away and we need to hear about  that. So please let us know how you  use it. So finally, let's talk about  best practices. First, make sure you launch your  app with bind at load in your LD  FLAGS for debug builds only. Fix any unaligned pointers in  your data segments. Again, this warning is there. You should try to be fixing all  of your warnings. If you see it with the new Swift  keypath feature, you can ignore  that because we'll fix that. You can make sure you are not  depending on any terminators  running when you call dlclose. And we want you to let us know  why you're using dlopen, dlsym,  dladdr, and the all image info  structures to make sure that our  replacements are going to suit  your needs. In the case of the ones that are  part of POSIX, they will stay  around, they will just be lower  performance. In the case of all image infos,  it is going to go away to save  that memory. Please file bug reports using  DYLD USAGE in their titles so  that they get to us so that we  can find out all of your usage  cases that we need to support. And for more information, you  can go to this URL. Related sessions. So last year we did Optimizing  App Startup Time, so you may  want to go and watch that for a  refresher on how traditional  dynamic linking works.

我们总是想要我们的表现，我们总是想要我们的记忆。所以我们将在未来的版本中把它拿走，但是我们会为它提供替换API。所以很少使用它，但是如果您使用它，我想再次了解您为什么使用它以及如何使用它，并确保我们设计的API适合您的用例。有许多地方是残留的，而且今天无论如何都不能做你期望或工作的，所以如果你不使用它们，它们可能就会消失，我们需要听到这些。所以请让我们知道你是如何使用它的。最后，让我们来谈谈最佳实践。首先，确保只在调试版本中使用LD标志加载BAND应用程序。修复数据段中的任何未对齐指针。同样，这个警告是存在的。你应该试着去修正你所有的警告。如果你用新的SWIFT键路径特性看到它，你可以忽略它，因为我们会修复它。在调用DLCOND时，您可以确保不依赖于任何终止符运行。我们想让你们知道为什么你们使用dlopen、dlsym、dladdr和所有的图像信息结构来确保我们的替换物能满足你们的需要。在POSIX部分的情况下，它们将保持在周围，它们将只是较低的性能。在所有图像信息的情况下，它将消失以保存该内存。请在标题中使用DYLD USAGE提交bug报告，以便它们能联系到我们，以便我们能够找到您需要支持的所有用例。更多信息，您可以访问这个URL。相关会议。所以去年我们做了优化应用程序启动时间，所以您可能想去看看，了解一下传统的动态链接是如何工作的。

 It goes into much more detail  than I did here since I was  trying to discuss all the new  stuff we're doing. So thank you everybody for  coming. I hope you've had a great WWDC.

它比我在这里做的更详细，因为我正试图讨论我们正在做的所有新的事情。谢谢大家的光临。我希望你有一个很棒的WWDC。

