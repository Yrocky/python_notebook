  Good afternoon. My name is Shane. I'm with the Darwin Runtime  team. And I'd like to welcome you to  measuring performance using  logging. So we heard a lot about  performance on Monday. Performance is one of those  things that's key to a great  user experience. People love it when their games  and their apps are fast,  dynamic, and responsive. But software is complex so that  means that when your app is  trying to do something,  sometimes a ton of things can be  going on and that means you can  find some performance wins in  some pretty unlikely places. But doing so, unearthing those  of performance wins requires an  understanding, sometimes a deep  understanding of what it is your  program is doing. It requires you to know when  your code is executing exactly,  how long a particular operation  is taking.

下午好。我叫尚恩·斯蒂芬·菲南。我和达尔文的运行团队在一起。我欢迎你们用日志来测量性能。所以我们在星期一听到很多关于演出的消息。性能是用户体验的关键之一。人们喜欢它的游戏和他们的应用程序是快速，动态，和响应。但是软件是复杂的，这意味着当你的应用程序试图做某事时，有时会有大量的事情发生，这意味着你可以在一些不太可能的地方找到一些性能上的赢家。但这样做，发掘性能赢家需要理解，有时深刻理解你的程序正在做什么。它要求你知道你的代码是什么时候执行的，一个特定的操作需要多长时间。

 So this is one place where a  good tool can make a real  difference. And we know that building better  tools, making them available to  you, is one of the ways that we  can help you be a more  productive developer. So today I'm going to talk about  one of those tools. Today, I'm going to talk about  signposts. Signposts are a new member of  the OSLog family. And we're making them available  to you in macOS. We're making them available to  you in iOs. And you can use them in Swift  and in C, but the coolest thing  is we've integrated them with  Instruments. So that means Instruments can  take the data that signposts  produce and give you a deep  understanding of what it is your  program is doing. So first a little history. We introduced OSLog a couple of  years ago.

所以这是一个好工具能产生真正差异的地方。我们知道，构建更好的工具，使它们提供给您，是我们能够帮助您成为一个更有生产力的开发人员的方法之一。今天我要谈谈其中的一个工具。今天，我要谈谈路标。路标是OSLog家族的新成员。我们让他们在MaOS中提供给你。我们让他们在iOS中提供给你。你可以在Swift和C中使用它们，但最酷的是我们已经把它们和仪器结合起来了。因此，这意味着仪器可以获取路标产生的数据，并让您深入了解程序正在做什么。所以先说一点历史。几年前我们引进了OsLog.

 It's our modern take on a  logging facility. It's our way of getting  debugging information out of the  system. And it was built with our goals  of efficiency and privacy in  mind. Here you can see an example of  OSLog code where I've just  created a simple log handle and  posted a hello world to it. Signposts extend the OSLog API,  but they do it for the  performance use case. And that means they are  conveying performance related  information, and they're  integrated with our developer  tools and that means you can  annotate your code with  signposts and then pull up  Instruments and see something  like this. So Instruments is showing you  this beautiful visualization of  a timeline of what your program  is doing and the signpost  activity there. And then on the bottom there's  that table with statistical  aggregation and analysis of the  signpost data, slicing and  dicing to see what your  program's behavior is really  like. In this session, I'll talk about  adopting signposts into your  code and show you some of what  they're capable of. And then we're going to  demonstrate the new Instrument  signpost visualization to give  you an idea how signposts and  Instruments work together.

这是我们现代的伐木设施。这是我们从系统中获取调试信息的方法。它是建立在我们的效率和隐私的目标。这里你可以看到一个OSLoC代码的例子，我刚刚创建了一个简单的日志句柄，并向它发布了一个Hello World。路标扩展了OsLogAPI，但它们是为性能用例而做的。这意味着它们传递的是性能相关的信息，并且它们与我们的开发工具集成在一起，这意味着您可以用路标来注释代码，然后拉起.ments来看像这样的东西。所以.ments正在向你展示一个关于你的程序正在做什么和路标活动的时间表的美丽可视化。然后在底部有一个表格，上面有对路标数据的统计汇总和分析，切片和切片，看看你的程序的行为到底是怎样的。在本次会议中，我将讨论在你的代码中采用路标，并向你展示他们的能力。然后我们将演示新的仪器路标可视化，以让您了解路标和仪器如何一起工作。

 So let's start. I'm going to start with a really  basic example. Imagine that this is your app. And what you're trying to  investigate is the amount of  time a particular part of the  interface takes to refresh. And you know to do that you want  to load some images and put them  on the screen. So once again, an abstract,  simple view of this app might be  that you're doing the work to  grab an asset. And after you've gotten them  all, the interface is refreshed. What a signpost allows us to do  is to mark the beginning and the  end of a piece of work and then  associate those two points in  time, those two log events with  each other. And they do it with an os  signpost function call. There are two calls. One with .begin and one with  .end. Here I've represented the begin  with that arrow with the b  underneath it. And I represented the end with  the arrow with the e under it. And then we're going to relate  those two points to each other  to give you a sense of what the  elapsed time is for that  interval. All right. In code, there's this simple  implementation of that algorithm  where for each element in our  interface, we're going to fetch  that asset and that's the piece  of operation that we're  interested in measuring. So to incorporate signpost into  this code base, we're going to  simply import the module  os.signpost that contains that  functionality.

那么，让我们开始吧。我将从一个非常基本的例子开始。想象一下这是你的应用程序。你要研究的是一个特定的接口部分需要刷新的时间。你要做的是，你想加载一些图像，并把它们放在屏幕上。因此，对这个应用程序的一个抽象、简单的观点可能是你正在做的工作是攫取资产。当你把它们都弄到手后，界面就被刷新了。路标允许我们做的是标记一件工作的开始和结束，然后将这两个时间点、这两个日志事件彼此关联。他们用OS标志函数调用来完成。有两个电话。一个开始，一个结束，一个结束。这里我用箭头表示了下面的箭头。我用箭头表示E的末尾。然后我们将把这两点联系起来，让你们了解这段时间间隔所经过的时间。好的。在代码中，有这种算法的简单实现，对于接口中的每个元素，我们将获取该资产，这是我们感兴趣的测量操作。因此，为了将路标合并到这个代码库中，我们将简单地导入包含该功能的模块os.signpost。

 And then because signposts are  part of the OSLog functionality,  we're going to create a log  handle. Here, this log handle takes two  arguments, a subsystem and a  category. The subsystem is just probably  the same throughout your  project. It looks a lot like your bundle  ID. And it represents the component  or the piece of software, maybe  the framework that you're  working on. The category is used to relate  -- to group related operations  together or related signposts. And you'll see why that could be  useful later in the session. Once we have that log handle,  we're just going to make two  calls to os signpost. One with .begin. One with .end. We're going to pass that log  handle into those calls. And then for the third argument,  we have a signpost name. The signpost name is a string  literal that identifies the  interval that identifies the  operation that we're interested  in measuring. That string literal is used to  match up the begin point that  we've annotated or that gets  marked up with that os signpost  begin called and the end point. So on our timeline, it just  looks like this.

然后因为路标是OSlog功能的一部分，所以我们将创建一个日志句柄。这里，这个日志句柄有两个参数，一个子系统和一个类别。子系统在整个项目中可能是相同的。它看起来很像您的bundle ID。它表示组件或软件，可能是您正在处理的框架。该类别用于关联-将相关操作分组在一起或相关的路标。你会明白为什么这会在稍后的会议中有用。一旦我们有了这个日志句柄，我们就要对OS标识进行两次调用。一开始。一个结束。我们将把那个日志句柄传递到那些调用中。然后，对于第三个参数，我们有一个路标名称。路标名称是一个字符串字面值，用于标识我们感兴趣的测量操作的间隔。该字符串字面值用于匹配我们注释的开始点或用os路标开始调用的标记和结束点。所以在我们的时间表上，它看起来就是这样。

 At the beginning of each piece  of work, we've dropped an os  signpost. At the end of each piece of  work, we've dropped an os  signpost. And because those string  literals at the begin and end  call sites line up with each  other, we can match those two  together. But what if we're interested in  also measuring the entire amount  of time the whole operation,  that whole refresh took?  Well, in our code, we're just  going to add another pair of os  signpost begin and end calls. Pretty simple. And this time I've given it a  different string literal, so a  different signpost name. This time refresh panel to  indicate that this is a separate  interval, separate from the one  inside the loop. In our timeline, we're just  marking two additional  signposts. And that matching string literal  of refresh panel will let the  system know that those two  points are associated with each  other. All right. It's not a super simple example. If your program ever does step  one and then step two then step  three in a sequential fashion  then that would work. But in our systems, often we  have a lot of work that happens  asynchronously. Right. So instead of having step one,  step two, step three, we're  often kicking things off in  sequence, right, and then  letting them complete later. So that means that these  operations can happen  concurrently. They can overlap. In that case, we need to give  some additional piece of  information to the system in  order for it to tell those  signposts apart from each other. And to do that, so far we've  only used that name.

在每一项工作的开始，我们都删除了一个操作系统的路标。在每一项工作的最后，我们都删除了一个操作系统的路标。因为在开始和结束呼叫站点的那些字符串文字彼此对齐，我们可以将两者匹配在一起。但是，如果我们感兴趣的是测量整个操作的全部时间，那么整个刷新需要什么呢？在我们的代码中，我们将添加另一对OS标志开始和结束调用。很简单。这次我给了它一个不同的字符串文字，所以有一个不同的路标名称。这一次刷新面板以指示这是一个单独的间隔，与循环中的一个间隔分开。在我们的时间表中，我们只是在标记两个额外的路标。刷新面板的匹配字符串文字将让系统知道这两个点是相互关联的。好的。这不是一个简单的例子。如果你的程序曾经执行步骤一步，然后步骤二，然后按顺序的方式步骤三，那就行了。但是在我们的系统中，我们经常有很多异步发生的工作。正确的。因此，我们没有第二步，第二步，第三步，我们经常按顺序把事情踢开，然后让他们完成。这意味着这些操作可以同时发生。它们可以重叠。在这种情况下，我们需要给系统附加一些信息，以便它能把这些路标彼此分开。为了做到这一点，到目前为止，我们只使用了这个名字。

 Right. That name will match up the end  and the beginning point. So that string literal so far  has identified intervals, but it  hasn't given us a way to  discriminate between overlapping  intervals. To do that, we're going to add  another piece of data to our  signpost calls called a signpost  ID. The signpost ID will tell the  system that these are the same  kind of operation but each one  is different from each other. So if two operations overlap but  they have different signpost  IDs, the system will know that  they're two different intervals. As long as you pass the same  signpost ID at the begin call  site and the end call site,  those two signposts will be  associated with each other. You can make signpost IDs with  this constructor here that takes  a log handle, but you can also  make them with an object. This could be useful if you have  some object that represents the  work that you're trying to do  and the same signpost ID will be  generated as long as you use the  same instance of that object. So this means you don't have to  carry or store the signpost ID  around. You can just use the object  that's handy. Visually, you can think of  signpost IDs as allowing us to  pass a little bit of extra  context to each signpost call  which can relate the begin and  end markers for a particular  operation with each other. And this is important because  not only can these operations  overlap, but they often take  differing amounts of time. Let's see this in our code  example. So here's our code. I'm going to transform that  synchronous fetch async call in  to an asynchronous one.

正确的。这个名字将与结束和开始点相匹配。所以到目前为止，字符串字面值已经识别出间隔，但是它没有给我们一种区分重叠间隔的方法。为了做到这一点，我们要给路标呼叫添加另一段数据，称为路标ID。路标ID将告诉系统这些操作是相同的，但是每个操作是不同的。因此，如果两个操作重叠，但它们具有不同的路标ID，则系统将知道它们是两个不同的间隔。只要您在开始呼叫站点和结束呼叫站点传递相同的路标ID，这两个路标就会彼此关联。你可以用这个构造函数在这里使用一个日志句柄来做路标ID，但是你也可以用一个对象来制作它们。如果您有一些对象表示您正在尝试执行的工作，并且只要您使用该对象的相同实例，就会生成相同的路标ID，那么这可能是有用的。这意味着你不必携带或存储路标ID。你可以只使用方便的对象。从视觉上讲，您可以认为路标ID允许我们向每个路标调用传递一些额外的上下文，这些上下文可以将特定操作的开始和结束标记彼此关联。这很重要，因为这些操作不仅可以重叠，而且通常需要不同的时间。让我们在代码示例中看到这一点。这是我们的代码。我将把同步获取异步调用转换为异步调用。

 So here I'm just going to give  it a completion handler. This is a closure that will run  after the fetch asset is  complete. And then I've also added a  closure, a completion handler  for running after all the assets  have been fetched. In each case, I've moved that os  signpost end call inside of a  closure to indicate that that's  when I want that marked period  of time to end. Okay. So because we think that these  intervals will overlap with each  other, we're going to create new  signpost IDs for each of them. Notice in the top example I've  created one with the constructor  taking a log handle. And the second one, I've made  off that object that is being  worked on, the element. And then I simply pass those  signpost IDs into the call sites  and we're done. You can think of signpost as  being organized as a kind of  classification or hierarchy. Right. All these operations are related  together by the log handle  meaning that log category. And then for each operation that  we're interested in, we've given  it a signpost name. Then because those signposts  could overlap with each other,  we've given them that signpost  ID that tells the system that  that's a specific instance of  that interval. This interface was built  specifically to be flexible so  you control all the arguments  into your begin site and your  end site. You control that signpost name,  the log handle you give it, and  the ID. We've done this because as long  as you can give the same  arguments at the begin site and  the end site, those two  signposts will get matched with  each other. That means your begin and end  sites can be in separate  functions. They can be associated with  separate objects. They may even live in separate  source files. We've done this because we want  you to be able to adopt it into  your code base. And so whatever entry and exit  conventions you have, you can  use these calls. So that's how to measure  intervals with signposts. You may want to convey some  additional information, some  additional performance relevant  information along with your  signposts. And for that, we have a way to  add metadata to signpost calls. So here's your basic signpost  call. To that, we can add an  additional string literal  parameter. This allows you to add some  context to your begin and end  call sites. Perhaps you have multiple begin  and exit points for a particular  operation, but the string  literal is also an OSLog format  string.

所以我要给它一个完整的处理程序。这是一个在获取资产完成后运行的闭包。然后我还添加了一个闭包，一个完成处理程序，用于在所有的资产被取出之后运行。在每种情况下，我都将os路标结束调用移动到闭包内部，以指示我希望结束那个标记的时间段。可以。因此，因为我们认为这些时间间隔会相互重叠，所以我们将为每个时间间隔创建新的路标ID。注意，在上面的示例中，我创建了一个带有日志句柄的构造函数。第二个，我已经把正在处理的那个元素，元素。然后我把那些路标ID传递到呼叫站点，我们就完成了。你可以认为路标被组织成一种分类或等级制度。正确的。所有这些操作都由日志句柄相关联，这意味着日志类别。然后对于我们感兴趣的每一个操作，我们给它一个路标名称。然后，因为这些路标可能相互重叠，所以我们给了他们路标ID，它告诉系统那是那个时间间隔的特定实例。这个接口是特别灵活的，所以你可以把所有的参数控制到你的起始站点和你的站点。您可以控制路标名称、日志句柄和ID。之所以这样做，是因为只要您可以在开始站点和结束站点上给出相同的参数，那么这两个路标就会彼此匹配。这意味着您的开始和结束站点可以在不同的功能中。它们可以与单独的对象相关联。他们甚至可以生活在不同的源文件中。我们这样做是因为我们希望你能够把它应用到你的代码库中。因此，无论你有什么进出公约，你都可以使用这些电话。这就是如何用路标测量间隔的方法。您可能想要传达一些附加信息、一些附加的性能相关信息以及您的路标。为此，我们有一种方法将元数据添加到路标调用中。这是你的基本路标呼叫。为此，我们可以添加一个附加字符串文字参数。这允许您在开始和结束调用站点中添加一些上下文。也许对于特定的操作，您有多个开始点和退出点，但是字符串文字也是OSLog格式的字符串。

 And that means I can use it to  pass additional data into the  signpost. So here, for example, I've used  that %d to pass in four  integers. But because it's an OSLog format  string, I can also use it to  pass many arguments of different  types. So here I've passed in some  floating-point numbers. And I've even used the format  specifier to tell the system how  much precision I want. You can pass dynamic strings in  with the string literal  formatter.

这意味着我可以用它把额外的数据传递到路标。例如，在这里，我使用了%d来传递四个整数。但是因为它是一个OSLO格式字符串，所以我也可以使用它来传递许多不同类型的参数。我在这里通过了一些浮点数。我甚至使用格式说明符来告诉系统我想要多少精度。可以使用字符串文字格式化程序传递动态字符串。

 And that'll let us pass in  information that comes from a  function call or comes from a  user entered piece of  information. And we reference that format  string literal with a fixed  amount of storage which means  that you can feel free to make  it as long and as human readable  as you like. This human readable string is  the same one that will be  rendered up in the Instruments. So you can feel free to give it  some context. I've given it here for the  various arguments. And Instruments will be able to  show that full rendered string,  or it still has programmatic  access to the data that's  attached. In addition to metadata for  those intervals, you may want to  add individual points in time. That is, in addition to the  begin signpost and the end  signpost, you may have a  signpost that's not tethered to  a particular time interval but  rather just some fixed moment. And for that, we have an os  signpost with the event type. The os signpost with the event  type call looks just like the  same as the begin and end, this  time with the event type. And it marks a single point in  time. You could use this within the  context of an interval or maybe  because you want to track  something that's independent of  an interval like a user  interaction. So for that fetch asset interval  we're talking about, maybe you  want to know when you've  connected to the service that  provides that asset. Or maybe you want to know when  you've received a few bytes of  it. You can use this to update the  status or progress of a  particular interval many times  throughout that time of that  interval. Or you might be tracking maybe a  triggering event like maybe a  user interface interaction like  somebody has just swiped to  update that interface. Although, if you're really  investigating in a performance  problem, they might be swiping a  lot so this might be what you  see instead. If you have signpost enabled,  they're usually on by default,  but I'd like to talk about  conditionally turning them on  and off. First I'd like to emphasize that  we built signpost to be  lightweight. That means we've done a lot of  work to optimize them at emit  time. We've done this through some  compiler optimizations that make  sure that work is done in front  instead of runtime.

这会让我们传递来自函数调用或来自用户输入的信息的信息。我们用固定存储量的字符串字面表示这种格式，这意味着您可以随意地让字符串尽可能长、尽可能人性化。这种人类可读的字符串与仪器中的字符串相同。所以你可以随意给它一些背景。我在这里给出了各种论证。并且仪器将能够显示完整的呈现字符串，或者它仍然具有对附加数据的编程访问。除了这些间隔的元数据之外，您还可能希望及时添加单独的点。也就是说，除了开始路标和结束路标之外，您可能还有一个路标，该路标没有绑定到特定的时间间隔，而只是某个固定的时刻。为此，我们有一个带有事件类型的OS标志。带有事件类型调用的OS标志看起来就像开始和结束一样，这次是事件类型。它标志着一个单一的时间点。您可以在间隔的上下文中使用它，或者可能因为您想要跟踪与间隔无关的东西，比如用户交互。因此，对于我们讨论的获取资产间隔，您可能想知道何时连接到提供该资产的服务。或者你想知道你什么时候收到了它的几个字节。您可以使用该方法在该间隔的整个时间内多次更新特定间隔的状态或进度。或者您可能正在跟踪触发事件，比如用户界面交互，比如某人刚刚刷新了该界面。尽管如此，如果你真的在研究性能问题，它们可能正在进行大量的修改，所以这可能是你所看到的。如果你启用了路标，它们通常默认是打开的，但我想谈谈有条件地打开和关闭它们。首先，我要强调的是，我们建造的路标是轻量级的。这意味着我们在EIT时间做了很多工作来优化它们。我们通过一些编译器优化来实现这一点，确保工作在前面而不是运行时完成。

 We've also deferred a lot of our  work so that they're done on the  Instruments backend. And that means that while  signposts are being emitted,  they should take very few system  resources. We've done this because we want  to minimize the impact to  whatever your code is running. And we've also done it because  we want to make sure that even  if you have very small time  span, you can emit a lot of  signposts to get some  fine-grained measurements. But you may want to be able to  turn your signposts off. Maybe you want to eliminate as  much overhead as you can from a  particular code path. Or you might have two categories  of signposts, both of which are  super-high volume and you really  are only interested in debugging  one or the other at a given  point in time. Well, to do that we're going to  take advantage of a feature of  OSLog, the disabled log handle.

我们还推迟了大量的工作，以便在仪器后端完成。这意味着，当路标被发射时，他们只需要很少的系统资源。我们这样做是因为我们希望最小化对代码运行的影响。我们这样做也是因为我们想确保，即使你的时间跨度很小，你也可以发出许多路标来获得一些细粒度的测量。但你可能希望能够把你的路标关闭。也许你想从一个特定的代码路径中消除尽可能多的开销。或者您可能有两类路标，这两类路标都非常大，并且您真正感兴趣的是在给定时间点调试其中一个路标。为了做到这一点，我们将利用OSlog的一个特性，即禁用的日志句柄。

 So the disabled log handle is a  simple handle. And what it does is every OSLog  and os signpost call made  against that handle will just  turn into something very close  to a no-op. In fact, if you adopt this in C,  we'll even do the check for you  in line and then we won't even  evaluate the rest of the  arguments. So you can just change this  handle at runtime. Let me show you an example. So we're going to go back to the  very first example code that we  had. And you see that initialization  of that log handle up top. Well, instead I'm going to make  that initialization conditional. So I'm either going to assign it  to the normal os log constructor  or I'm going to assign it to  that disabled log handle. If we take the first path, all  the os signpost calls will work  as I described, but if we take  the second path, those os  signpost calls will turn into  near no-ops. So as I said before, notice that  I didn't have to call any of my  call -- I didn't have to change  any of my call sites. I only had to change the  initialization. And I made the initialization  conditional on an environment  variable. This is the kind of thing that  you can set up in your Xcode  scheme while you're debugging  your program.

因此，禁用的日志句柄是一个简单的句柄。它的作用是每个针对该句柄的OSLog和os路标调用都会变成非常接近于不可操作的东西。事实上，如果您在C中采用这个方法，我们甚至会为您在线进行检查，然后我们甚至不会评估其余的参数。所以你可以在运行时改变这个句柄。让我给你举个例子。所以我们将回到我们的第一个示例代码。您可以看到，该日志句柄的初始化在顶部。好吧，相反，我要使条件初始化。所以我要么把它分配给普通OS日志构造器，要么把它分配给那个禁用的日志句柄。如果我们采用第一条路径，所有的操作系统路标调用都将如我所描述的那样工作，但是如果我们采用第二条路径，那么那些操作系统路标调用将变成几乎不操作。正如我之前所说的，注意到我不需要打任何我的电话——我不需要改变我的任何呼叫站点。我只需要改变初始化。我用环境变量初始化了条件。这是在调试程序时可以在XCODE方案中设置的东西。

 Now I said you didn't have to  change in the call sites, but  maybe you have some  functionality that is  instrumentation specific. That is, it might be expensive  but it might only be used for  while debugging. So in that case, you can check a  particular log handle to see if  signposts are turned on for it  with the signposts enabled  property. The signposts enabled property  can then be used to gate that  additional operation. Okay. So all the examples that I've  shown so far have been in Swift,  but signposts are also available  in C. All the functionality I've  talked about so far is  available: the long handles,  emitting the three different  kinds of signposts, and managing  your signpost identifiers. For those of you who are  interested in adopting in C, I  encourage you to read the header  doc. and header doc covers all this  information that I have but from  a C developer's perspective. All right. Now you've seen how to adopt  signposts in your code. And maybe you have a mental  model of what they represent. So I would love for you to see  how signposts work in concert  with Instruments. And for that, I'm going to turn  it over for the rest of the  session to my colleague, Chad.

我说过你不必改变呼叫站点，但是也许你有一些特定于仪器的功能。也就是说，它可能是昂贵的，但它可能只用于调试时使用。因此，在这种情况下，您可以检查特定的日志句柄，查看是否启用了signposts属性为其打开了路标。然后可以使用启用标志的属性来引导该附加操作。可以。到目前为止，我所展示的所有示例都在Swift中，但是路标也可以在C中使用。到目前为止，我所讨论的所有功能都是可用的：长句柄、发出三种不同类型的路标以及管理您的路标标识符。对于那些在C中有兴趣采纳的人，我鼓励你们阅读头文档。而头文档涵盖了我所拥有的所有信息，但从C开发者的角度来看。好的。现在，您已经看到了如何在代码中采用路标。也许你有他们所代表的心理模型。所以我想让你们看看路标如何与乐器一起工作。为此，我将把剩下的时间交给我的同事，乍得。

 Thank you.  All right. Thank you, Shane. Now today I want to show you and  demonstrate for you three new  important features in  Instruments 10 to help you work  with signpost data. The first is the new os signpost  instrument. And that instrument allows you  to record, visualize, and  analyze all of the signpost  activity in your application. The next feature is points of  interest. I'll talk a little bit about  what points of interest are and  when you might want to emit one. And then I'm also going to show  you the new custom instruments  feature and how you can use it  with os signposts to get a more,  I guess, refined presentation of  your signposts. So let's take a look at that in  a demonstration. Okay. Now to start with, we're going  to take a look at our example  application first. And that is our Trailblazer  application. This app is -- shows you the  local hiking trails. And it basically downloads these  beautiful images for you as we  scroll.

谢谢您。好的。谢谢你，尚恩·斯蒂芬·菲南。今天，我想向你们展示和演示仪器10中的三个新特性，以帮助你们处理路标数据。第一个是新的OS标志站仪器。该工具允许您记录、可视化和分析应用程序中所有的路标活动。下一个特征是兴趣点。我会讲一点什么兴趣点，什么时候你想发射一个。然后，我还将向您展示新的定制乐器特性，以及如何将它与操作系统路标一起使用，以获得更多（我猜）路标的精致表示。让我们在演示中看一下。可以。首先，我们先来看看我们的示例应用程序。这就是我们开拓者的应用。这个应用程序展示了当地的徒步旅行路线。它基本上为我们下载这些美丽的图像，因为我们滚动。

 Now you'll notice that initially  we have a white background and  then the image comes in later  and fills in. And this is a pretty common  pattern in an application like  this. And sometimes it's implemented  with a future or a promise but  this pattern -- as much as it  helps with performance, it's  also pretty difficult to  profile. And the reason for that is  because there are a lot of  asynchronous activities going  on. As the user scrolls, there are  downloads that are in-flight at  the same time. And if the user scrolls really  quickly like this then the  download may not complete before  the image cell needs to be  reused. And so then we have to cancel  that download. If we fail to do that, then we  end up with several downloads  running in parallel that we  didn't really want. So let's take a look at how we  can use signposts to analyze the  application of our Trailblazer. Now inside the trail cell, we  have a method called  startImageDownload. And this is invoked when we need  to download that new image, and  it's passed in the image name  that should be downloaded. Now we have a download helper  class here that we create an  instance of an pass in the name  and set ourself as the delegate  so it'll call us back when it's  downloaded. And in this case, since the  downloader represents the  concurrent activity that's going  on, this asynchronous work, it's  a great basis for a signpost ID. So we're going to create our  signpost ID using our downloader  object. Now to start our signposts,  we're going to do an os signpost  begin. And we're going to send it to  our networking log handle so  take a real quick look at our  networking log handle. You see we're using our  Trailblazer bundle ID and a  category of networking. Now we're going to pass an image  or, sorry, a signpost name of  background image so that way we  can see all of our background  image downloads. And it will pass that signpost  ID that we created. And we'll attach some metadata  to begin to convey the name of  the image that we are  downloading. So then we'll start our  download, and we'll set our  property to track that. We have it currently  runningDownloader. Now when that finishes, we'll  get this didReceiveImage  callback here. And we'll set our image view to  the image that we received. And we'll call end on the  signpost. And we'll use the exact same log  handle, the same name, the same  signpost ID but this time we're  going to attach some end  metadata to say finished with  size. And you'll notice here that  we've annotated this particular  parameter with Xcode colon  size-in-bytes. And what this does is it tells  Xcode and Instruments that this  argument should be treated as a  size-in-bytes for both display  and analysis. Now these are called engineering  types.

现在你会注意到，最初我们有一个白色背景，然后图像会在后面填充。在这样的应用程序中，这是一个非常常见的模式。有时候，它是用未来或承诺来实现的，但是这种模式——虽然对性能有帮助，但是也很难描述。原因是因为有很多异步活动正在进行。当用户滚动时，有同时在飞行中的下载。如果用户像这样滚动得很快，那么在需要重新使用图像单元之前，下载可能无法完成。所以我们必须取消下载。如果我们没有做到这一点，那么我们最终会有几个并行下载，我们并不真正想要。让我们来看看我们如何使用路标来分析我们的开拓者的应用。现在在TRAIL单元中，我们有一个名为StestMimaDeNoWoad的方法。当我们需要下载新的图像时，它被调用，并且它被传递到应该下载的图像名称中。现在我们有了一个下载助手类，在这个类中，我们创建了一个名为pass的实例，并将自己设置为委托，这样当它被下载时，它将回调我们。在本例中，由于下载器表示正在进行的并发活动，所以这个异步工作，它是路标ID的基础。所以我们将使用下载器对象创建路标ID。现在开始我们的路标，我们要做一个OS标志开始。我们将把它发送到我们的联网日志句柄，所以快速浏览一下我们的网络日志句柄。你看，我们正在使用我们的开拓者捆绑包ID和一个网络类别。现在我们要传递一个图像，或者抱歉，背景图像的路标名称，这样我们就可以看到所有的背景图像下载。它将通过我们创建的那个路标ID。我们将附加一些元数据来开始传递我们正在下载的图像的名称。然后我们开始下载，我们将设置我们的属性跟踪。我们有它正在运行下载程序。现在完成后，我们将在这里得到这个DeDeCiVIVICAL回调。我们将把我们的图像视图设置为我们接收到的图像。我们会在路标上呼叫终点。我们将使用完全相同的日志句柄、相同的名称、相同的路标ID，但是这次我们将附加一些最终元数据，以说明使用大小完成。您会注意到，我们已经用XCODE冒号大小的字节注释了这个特定的参数。这样做的目的是告诉Xcode和.ments这个参数应该被当作用于显示和分析的字节大小。现在这些被称为工程类型。

 And they can be read about in  the Instruments developer help  guide which is under the help  menu in Instruments. Now once we've completed our  downloading, we can set that  back to nil. Now there are two ways that we  can finish a download. That was the success path. And then we have to consider the  cancel path. So in prepare for reuse, if we  currently have a running  downloader, we're going to need  to first cancel that downloader. So in that case, we're going to  emit an end for the interval,  and we're going to use that same  logging handle, signpost name,  signpost ID. And we're going to use cancelled  as the end metadata to separate  it from when we finish  successfully. Now that's enough to actually do  some profiling. So we're going to go over here  to a product profile. And that will start up  Instruments once we've finished  building and installing. That will start up Instruments  here. And we can create a new blank  document.

它们可以在仪器帮助菜单中的“工具开发者指南”中阅读。现在，一旦我们完成了下载，我们可以将它设置为零。现在有两种方法可以完成下载。这就是成功之路。然后我们必须考虑取消路径。因此，在准备重用时，如果我们当前有一个运行的下载器，我们将需要首先取消那个下载器。因此，在这种情况下，我们将为间隔发出一个结束，我们将使用相同的日志记录句柄、路标名称、路标ID。我们将使用canceled作为结束元数据，以将其与成功完成时分离。这就足以做一些分析了。所以我们要到这里来看看产品简介。一旦我们完成建造和安装，就会启动仪器。这将启动仪器在这里。我们可以创建一个新的空白文档。

 Then we can go to the library,  and I can show you how to use  that new os signpost instrument. So we have our new os signpost  instrument here. And we'll just drag and drop  that out into the trace. We'll make a little bit of room  here for it and then we will  press record. And I'll bring our iPhone back  up here to the beginning. All right. So now we'll do some scrolling  and then we'll also do some  really, really quick scrolling. And then we'll let that settle  down. Now we can go back to  Instruments and see what kind of  data we recorded. So I'm going to stop the  recording. And now you'll notice here that,  in the track view, we have a  visualization of all of our  background image intervals.

然后我们可以去图书馆，我可以告诉你如何使用新的OS标志站仪器。所以我们这里有新的OS标志器。我们将拖拽到跟踪中。我们在这里做一点空间，然后按记录。我会把我们的iPhone带到这里。好的。所以现在我们做一些滚动，然后我们也会做一些非常快速的滚动。然后我们就让它安顿下来现在我们可以回到仪器，看看我们记录了什么样的数据。所以我要停止录音。现在你会注意到，在轨道视图中，我们有一个可视化的所有背景图像间隔。

 Now that's the signpost name. Now if we hold down the option  key and we zoom in, you can see  there are intervals. And intervals are annotated with  the start metadata and the end  metadata. Now if we zoom back out and then  take a look at the trace here  again, we'll notice that we have  no more than five images that  are running downloads in  parallel, which is a good thing. That means that our cancellation  worked. And if we want to confirm that,  we can come in here and you can  see that a lot of these  intervals have metadata that  says that it was cancelled in  the download. Now if you want to take -- if  you want to look at a numerical  -- or let's say you want to look  at the durations of these  intervals then you can come down  here to the summary of  intervals. And we see a breakdown by  category and then by signpost  name and then by the start  message and then by the end  message. So if we make this a little bit  smaller, you can see that we  made 93 image download requests. Of those, 12 were for location  one. Of those 12, seven were  cancelled and five finished with  a size of 3.31 megabytes. Now if you look over here, these  are the statistics about our  durations. And you can see that the minimum  and the average of the cancelled  intervals is significantly  smaller than when we finished  with the full downloads. And that's exactly what you  would expect to see in this  pattern. Now if you want to see all of  the cancelled events because  you're interested in seeing  those, you can put this -- focus  arrow and it will take you to a  list view where you can see all  the places where location one  had an end message of cancelled.

这是路标名称。现在，如果我们按住选项键，我们放大，你可以看到有间隔。使用起始元数据和结束元数据注释间隔。现在，如果我们往后缩放，然后再看一下这里的轨迹，就会发现并行下载的图像不超过5个，这很好。这意味着我们取消了工作。如果我们想确认一下，我们可以进来，你们可以看到，这些时间间隔中的很多都有元数据，表示在下载中取消了。现在，如果你想——如果你想看一个数字——或者假设你想看一下这些间隔的持续时间，你可以到这里来总结一下间隔。我们看到一个分类，然后通过路标名称，然后由开始消息，然后由结束消息。所以，如果我们稍微缩小一点，你可以看到我们制作了93个图像下载请求。其中，12个为第一个位置。在这12个国家中，七个被取消，五个完成了3.31兆字节的规模。现在，如果你看这里，这些是我们的持续时间的统计数据。您还可以看到，取消的间隔的最小值和平均值比我们完成完整下载时要小得多。这正是你在这个模式中所期望看到的。现在，如果您想查看所有取消的事件，因为您对查看这些事件感兴趣，那么可以把这个——焦点箭头，它将带您到一个列表视图，在该视图中，您可以看到一个位置有一个取消结束消息的所有位置。

 And as we go through this,  you'll see that the inspection  head on the top of the trace  will move forward to each one of  those intervals. So you can track all the failure  cases if that's what you're  interested in. Now that's a great way to view  the times of those intervals,  the timing of those intervals. But what if you wanted to do an  analysis of the metadata?  What if you wanted to determine  how many bytes of image data  that we've downloaded over the  network?  Well, we've emitted metadata  messages like finished with size  and then the size. It would be great if we could  total that argument up. So if you want to do that, you  can come over here to the  summary of metadata statistics. You can see that we have it  broken down by the subsystem,  the category, and then the  format string and then below the  format string, the arguments  within that format string. And since our format string only  has one, that's simply arg0. Now Instruments has totaled this  up. And it knows that this is a  size-in-bytes. And so it gives us a nice  calculation of 80 megabytes. So we've downloaded 80 megabytes  of image data total. Now you can see the different  columns here. You've got it min, max, average,  and standard deviation. So this is a great way to take a  look at just statistical  analysis of the values that  you're conveying through your  metadata. Now Shane mentioned that  signposts were very lightweight  and that is totally true except  when you run Instruments the way  I just ran Instruments. In what we call immediate mode,  which is the default recording  mode, Instruments is trying to  show and record the data in near  real time. And so when it goes into  immediate mode recording, all  the signposts have to be sent  directly to Instruments. And we have to bypass all of  those optimizations that you get  from buffering in the operating  system. Now with our signposts -- with  our signposts application here,  we're not really emitting enough  intervals to really notice that  overhead, but if you have a game  engine and you want to emit  thousands of signposts per  second, that overhead will start  to build up. So in order to work around that,  what you can do is change the  recording mode of Instruments  before you take your recording.

当我们检查时，您将看到轨迹顶部的检查头将向前移动到每个间隔。如果你感兴趣的话，你可以追踪所有的失败案例。这是一个很好的方法来查看这些间隔的时间，这些间隔的时间。但是，如果你想对元数据进行分析，该怎么办？如果你想确定我们在网络上下载了多少字节的图像数据呢？我们已经发出了像完成大小和大小一样的元数据消息。如果我们能把这个论点搞清楚，那就太好了。因此，如果你想这样做，你可以到这里来进行元数据统计的总结。您可以看到，我们按子系统、类别、然后是格式字符串，然后在格式字符串下面是格式字符串中的参数，对它进行了细分。因为我们的格式化字符串只有一个，那就是简单的ARG0。现在仪器已经合计了这一点。它知道这是一个字节大小。所以它给了我们一个80兆字节的好计算。所以我们总共下载了80兆字节的图像数据。现在你可以看到不同的列了。你得到了最小，最大，平均和标准偏差。因此，这是一个很好的方式来看看你通过元数据传递的价值的统计分析。现在，Shane提到路标非常轻，这完全正确，除非你像我刚才运行.ments那样运行.ments。在我们称为即时模式（即默认记录模式）中，.ments试图近乎实时地显示和记录数据。因此，当进入直接模式记录时，所有的路标必须直接发送到仪器。我们必须绕过在操作系统中从缓冲中获得的所有优化。现在，有了我们的路标——有了我们的路标应用程序，我们实际上没有发出足够的间隔来真正注意到开销，但是如果您有一个游戏引擎，并且您希望每秒发出数千个路标，那么开销将开始增加。所以为了解决这个问题，你可以做的是在录音之前改变仪器的记录模式。

 And the way you do that is by  holding down on the record  button and selecting recording  options. And then in this section here  for the global options, you can  see that we have our immediate  mode selected. And we can change that to last  five second mode. Now this is often called  windowed mode. And what it tells the operating  system and the recording  technology is that we don't need  every single event. We just want the last five  seconds worth. And when you do that,  Instruments will step out of the  way and let the operating system  do what it does. Now this is a very common mode. We use this in system trace. We use this in metal system  trace and the new game  performance template. And so it's a very common way to  look for stutters and hangs in  your application.

你这样做的方法是按下记录按钮并选择录音选项。然后在这里的全局选项中，您可以看到我们已经选择了我们的即时模式。我们可以把它变成最后五秒模式。现在这通常被称为窗口模式。它告诉操作系统和录音技术是我们不需要每一个事件。我们只需要最后五秒的价值。当你这样做的时候，仪器会让路，让操作系统做它所做的事情。这是一种非常常见的模式。我们在系统跟踪中使用这个。我们使用这个在金属系统跟踪和新的游戏性能模板。因此，在应用程序中寻找口吃和挂起是一种非常常见的方法。

 All right. So that is our os signpost  instrument. Now let's talk about points of  interest. Now if we come back to our  Trailblazer application here,  you notice that when I tap on a  trail, it pushes a detail. If I go back and tap on a  different trail, it'll push a  different detail. Now it would be great if we  could track every time these  detail views come forward  because then we can tell what  our user is trying to do, and we  can tell where our user is in  the application. Now you could certainly do this  with a signpost, but you'd have  to drag in the os signpost  instrument and record all of the  signpost activity on the  application. And it sort of dilutes how  important these user navigation  events are. So what we allow you to do is  promote them to what are called  points of interest. Now if I go to our code for the  detail controller and we look at  our viewDidAppear method, you  can see that I'm posting -- I'm  creating an os signpost event  saying that a detail appeared  and with the name of the detail. Now this is sent to a special  log handle that we've created  called points of interest. And the way that you create that  is by creating a log handle with  your subsystem identifier and  the systems points of interest  category. So this is a special category  that Instruments will be looking  for. And when it sees points here,  it'll place them into the points  of interest instrument. So if we come back here and take  a time profile, you can see that  we have our points of interest  instrument automatically  included. And if we do a recording and we  do that same basic action, we go  into the Matt Davis Trail and  then we'll come back here to  Skyline Trail and then we'll go  back and we'll do one more for  good measure. Now when you go back to  Instruments, you can see that we  have those points of interest  prominently displayed. So you can see where your user  was in the navigation of your  app. And you can correlate this with  other performance data. And so points of interest are  really a way for you to pick and  choose some of the most  important points of interest in  your application and make them  available to every developer  that's on your team or in your  development community.

好的。这就是我们的操作系统。现在让我们谈谈兴趣点。现在，如果我们回到这里的开拓者应用程序，你会发现，当我敲击一条小路时，它会推动一个细节。如果我回过头来看一条不同的路线，它会推动不同的细节。现在，如果我们可以跟踪每次这些详细视图出现的时间，那将是非常棒的，因为这样我们就可以知道我们的用户正在做什么，并且我们能够知道我们的用户在应用程序中的什么位置。现在你当然可以用路标来做到这一点，但是你必须拖入操作系统路标工具并在应用程序上记录所有的路标活动。并且它稀释了这些用户导航事件的重要性。因此，我们允许你们做的是将它们提升到所谓的兴趣点。现在，如果我查看详细控制器的代码，并查看view.Appear方法，您可以看到我发布了.——我创建了一个操作系统路标事件，表示出现了带有详细名称的细节。现在，它被发送到一个特殊的日志句柄，我们创建了称之为兴趣点的句柄。创建它的方法是使用子系统标识符和系统兴趣点类别创建日志句柄。所以这是一个特殊的类别，仪器将寻找。当它在这里看到点时，它会把它们放在兴趣点仪器中。所以，如果我们回到这里，做一个时间简介，你可以看到，我们自动包含了我们的兴趣点。如果我们做录音，做同样的基本动作，我们进入马特·戴维斯小道，然后我们回到天际小道，然后我们回去，再做一次。现在，当你回到仪器，你可以看到，我们有兴趣点突出显示。所以你可以看到你的用户在你的应用程序导航中。您可以将此与其他性能数据相关联。因此，兴趣点确实是您选择应用程序中一些最重要的兴趣点，并将它们提供给您的团队或开发社区中的每个开发人员的一种方式。

 And they can be seen right here  in the points of interest. All right. So that is the points of  interest instrument and how you  create points of interest from  signposts. Now another great feature of  Instruments 10 is the ability  for you to create custom  instruments. And so to demonstrate what you  can do with custom instruments  in os signpost, we've created,  as part of our project, a  Trailblazer instruments package. Now I'm going to build and run  that now. And you'll see when we do that,  we start a separate copy of  Instruments that has our just  built package installed. And if we bring that version  forward, we'll see that we now  have a Trailblazer networking  trace template. And if we choose that, we can  see that we have a Trailblazer  networking instrument in our  trace document. And let's take a recording and  see what the difference is  between our points of interest  or, I'm sorry, our os signpost  and what this custom instrument  can do. So we'll do the same type of  thing. We'll do some basic downloading.

他们可以在这里看到感兴趣的东西。好的。这就是兴趣点工具，以及如何从路标创建兴趣点。现在仪器10的另一个重要特点是你可以创建自定义仪器。因此，为了在操作系统路标中演示如何处理定制仪器，我们创建了一个开拓者仪器包，作为我们项目的一部分。现在我要建立和运行它。你会看到，当我们这样做的时候，我们会启动一个单独的拷贝工具来安装我们刚刚构建的软件包。如果我们把这个版本转发，我们会看到我们有一个开拓者的网络跟踪模板。如果我们选择这一点，我们可以看到我们的跟踪文件中有一个开拓者的网络工具。我们来做个录音，看看我们的兴趣点有什么不同，或者，对不起，我们的操作系统路标和这个定制仪器能做什么。所以我们也会做同样的事情。我们会做一些基本的下载。

 And then we'll come back and  we'll analyze our trace. Now the presentation here is  significantly different. So let's zoom in and take a look  at it. You'll notice here on the left,  instead of breaking it down by  signpost name, we've broken it  down by the image being  downloaded. So now we can see that image two  was downloaded at this point and  at this point. Now we've labeled each one with  the size in megabytes of the  download. And we've also colored them red  if the download size is larger  than 3 1/2 megabytes. So this is a custom graph that  we created as part of our custom  instrument. Now we've also defined some  details down here. We've got a very simple list of  our download events. And, again, you can navigate  through the trace with those. And we also have -- let me see  if I can get this back into  focus here. We also have a summary for all  the downloads. Very simple. We just want to do a count and a  sum. And then we also have this cool  thing called Timeslice. And in a Timeslice view, what  we're trying to do is answer  that question I was asking  before of how many of these  things are actually running in  parallel?  Well, if you want to take a look  at the intervals running in  parallel, you just scrub the  inspection head over here  through time, and you can see  exactly what is intersecting  that inspection head at any  given point in time. So it's a great and a different  way to look at your signpost  data. Now if you are working with  others on a project or you're  part of the development  community, using a custom  instrument is a great way to  take the signpost data and  reshape it in a way that someone  else can use and interpret  without having to know the  details of how your code works  so they are a very important  feature. Now the great news is that to  create an instrument like that,  the entire package definition is  about 115 lines of XML and so  custom instruments is very  expressive and very powerful but  also very easy. And that is the conclusion of  our demo. So in today's session, we took a  look at the signpost API, and we  showed you how to use it to  annotate interesting periods of  activity and intervals inside  your application.

然后我们再来分析我们的踪迹。现在这里的介绍有很大的不同。让我们放大并看一看。你会注意到在左边，我们没有用路标名称来划分，而是用正在下载的图像来划分。现在我们可以看到，在这一点上，在这一点上下载了图像二。现在我们已经把每一个标签的大小标注为兆字节的下载。如果下载量大于3兆兆字节，我们也将它们染成红色。这是我们创建的自定义图，作为自定义工具的一部分。现在我们也在这里定义了一些细节。我们有一个非常简单的下载事件列表。而且，您可以使用这些导航。我们也有，让我看看我能不能把注意力放回这里。我们也有一个总结的所有下载。很简单。我们只想计算一笔钱和一笔钱。然后我们还有一个很酷的东西叫做时间片。在《泰晤士报》看来，我们要做的就是回答我以前问过的问题，其中有多少是并行运行的？嗯，如果你想看一下平行运行的间隔，你只要通过时间擦洗检查头就可以了，而且在任何给定的时间点上，你都能确切地看到与检查头相交的是什么。所以这是一个伟大的和不同的方式看你的路标数据。现在，如果您正在与其他人一起处理一个项目或者您是开发社区的一员，那么使用自定义工具是获取路标数据并以其他人能够使用和解释的方式重塑路标数据的好方法，而不必知道您的代码如何工作的细节，以便它们能够正常工作。是一个非常重要的特征。现在好消息是，要创建这样的工具，整个包定义大约是115行XML，因此定制工具非常具有表现力，非常强大，但也非常简单。这就是我们演示的结论。因此，在今天的会议中，我们查看了路标API，并且向您展示了如何使用它来注释应用程序中有趣的活动周期和间隔。

 We showed you how to collect  metadata and get that metadata  into Instruments for  visualization and analysis. And we showed you how to combine  custom instruments in os  signpost to create a more  tailored presentation of your  signpost data. Now all this really comes down  to us being able to give you the  kind of information that you  need to help you tune the  performance of your application. And so we're really excited to  see how you use os signpost and  Instruments together to improve  the user experience of your  application. That is the content for today. For more information, you can  come see us in a lab, technology  lab 8 at 3:00 today. And I also have session 410,  creating custom instruments  tomorrow where I'll be going  over the details of how custom  instruments works and show you  how we created our Trailblazer  networking instruments package. Thank you very much. Enjoy the rest of your  conference.

我们向您展示了如何收集元数据并将元数据获取到可视化和分析的工具中。我们向您展示了如何在操作系统路标中组合定制的仪器，以创建更适合您的路标数据的呈现。现在，所有这一切都归结于我们能够提供您所需要的信息，以帮助您调整应用程序的性能。所以我们非常高兴地看到你们如何将操作系统路标和仪器一起使用，以改善应用程序的用户体验。这就是今天的内容。欲了解更多信息，您可以在今天凌晨3点在实验室、技术实验室8见我们。我还有会议410，明天创建定制乐器，我将详细介绍定制乐器的工作原理，并向您展示我们是如何创建Trailblazer网络乐器包的。非常感谢你。享受你余下的会议。

